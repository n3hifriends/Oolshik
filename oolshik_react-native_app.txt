# Consolidated source export
# Root: /Users/nitinkalokhe/Ni3/Oolshik
# Included: ['.bash', '.bat', '.c', '.cfg', '.cjs', '.conf', '.cpp', '.css', '.dart', '.editorconfig', '.env', '.gitattributes', '.gitignore', '.go', '.gradle', '.groovy', '.h', '.hpp', '.htm', '.html', '.ini', '.java', '.js', '.json', '.jsonc', '.jsx', '.kt', '.kts', '.less', '.lua', '.m', '.md', '.mdx', '.mjs', '.mm', '.php', '.properties', '.proto', '.ps1', '.py', '.rb', '.rs', '.scss', '.sh', '.sql', '.swift', '.ts', '.tsx', '.txt', '.xml', '.yaml', '.yml', '.zsh']
# Excluded dirs: ['.expo', '.git', '.gradle', '.idea', '.next', '.venv', '.vscode', 'Pods', 'android/build', 'build', 'coverage', 'dist', 'ios/build', 'node_modules', 'venv']
# Git ignored entries skipped: 59406 (if repo)
# ---



===== BEGIN FILE: index.tsx =====
import "@expo/metro-runtime" // this is for fast refresh on web w/o expo-router
import { registerRootComponent } from "expo"

import { App } from "@/app"

// registerRootComponent calls AppRegistry.registerComponent('main', () => App);
// It also ensures that whether you load the app in Expo Go or in a native build,
// the environment is set up appropriately
registerRootComponent(App)
===== END FILE: index.tsx =====


===== BEGIN FILE: oolshik_react-native_app.txt =====

===== END FILE: oolshik_react-native_app.txt =====


===== BEGIN FILE: app.json =====
{
  "name": "Oolshik",
  "slug": "Oolshik",
  "scheme": "oolshik",
  "version": "1.0.0",
  "orientation": "portrait",
  "userInterfaceStyle": "automatic",
  "icon": "./assets/images/app-icon-all.png",
  "updates": {
    "fallbackToCacheTimeout": 0
  },
  "newArchEnabled": true,
  "jsEngine": "hermes",
  "assetBundlePatterns": [
    "**/*"
  ],
  "android": {
    "icon": "./assets/images/app-icon-android-legacy.png",
    "package": "com.oolshik.aan",
    "adaptiveIcon": {
      "foregroundImage": "./assets/images/app-icon-android-adaptive-foreground.png",
      "backgroundImage": "./assets/images/app-icon-android-adaptive-background.png"
    },
    "allowBackup": false,
    "edgeToEdgeEnabled": true
  },
  "ios": {
    "icon": "./assets/images/app-icon-ios.png",
    "supportsTablet": true,
    "bundleIdentifier": "com.oolshik.aan"
  },
  "web": {
    "favicon": "./assets/images/app-icon-web-favicon.png",
    "bundler": "metro"
  },
  "plugins": [
    "expo-localization",
    "expo-font",
    [
      "expo-splash-screen",
      {
        "image": "./assets/images/app-icon-android-adaptive-foreground.png",
        "imageWidth": 300,
        "resizeMode": "contain",
        "backgroundColor": "#191015"
      }
    ],
    [
      "react-native-edge-to-edge",
      {
        "android": {
          "parentTheme": "Light",
          "enforceNavigationBarContrast": false
        }
      }
    ]
  ],
  "experiments": {
    "tsconfigPaths": true
  },
  "extra": {
    "ignite": {
      "version": "UNKNOWN"
    }
  }
}
===== END FILE: app.json =====


===== BEGIN FILE: flatten_code.py =====
#!/usr/bin/env python3
"""
flatten_code.py — Walk a project directory and concatenate selected source files
into a single text document with clear file headers/footers.

NEW: Respects .gitignore WITHOUT extra dependencies by using the local `git` CLI.
- If the directory is a Git repo and `git` is available, ignored files are skipped
  using: git ls-files --ignored --exclude-standard --others -z
- Tracked files are always included (even if patterns match .gitignore).
- If not a Git repo (or git missing), falls back to exclude list only.

Usage examples:
  python flatten_code.py --root . --output project-code.txt
  python flatten_code.py --root /path/to/repo --output all.txt --ext ".js,.ts,.tsx,.java,.kt,.py" --exclude ".git,node_modules,dist,build" --max-bytes 1048576
"""
import argparse, os, sys, subprocess, shutil
from pathlib import Path

DEFAULT_EXTS = [
    ".js",".jsx",".ts",".tsx",".mjs",".cjs",
    ".json",".jsonc",
    ".py",
    ".java",".kt",".kts",".gradle",".groovy",
    ".rb",".go",".php",".swift",".m",".mm",".c",".h",".cpp",".hpp",
    ".rs",".dart",".lua",
    ".xml",".html",".htm",".css",".scss",".less",
    ".yml",".yaml",".ini",".cfg",".conf",".properties",".env",
    ".md",".mdx",".txt",
    ".sh",".bash",".zsh",".ps1",".bat",
    ".sql",".proto",
    ".gitignore",".gitattributes",".editorconfig"
]

DEFAULT_EXCLUDES = [
    ".git","node_modules","dist","build",".next",".expo",".idea",".vscode",
    ".venv","venv","Pods","ios/build","android/build","coverage",".gradle"
]

def should_skip_dir(dirpath, excludes_set):
    parts = Path(dirpath).parts
    for token in excludes_set:
        token_parts = Path(token).parts
        if len(token_parts) > 1:
            if tuple(token_parts) == tuple(parts[-len(token_parts):]):
                return True
        else:
            if token in parts:
                return True
    return False

def get_git_ignored(root: Path):
    """
    Return a set of POSIX-style relative paths that are ignored by git.
    Uses: git ls-files --ignored --exclude-standard --others -z
    Only returns files that are ignored AND untracked; tracked files won't appear here.
    """
    if not (root / ".git").exists():
        return set()
    if shutil.which("git") is None:
        return set()
    try:
        out = subprocess.check_output(
            ["git", "ls-files", "--ignored", "--exclude-standard", "--others", "-z"],
            cwd=str(root)
        )
        items = out.decode("utf-8", errors="replace").split("\x00")
        rels = [i for i in items if i]
        # Normalize to POSIX-style
        return set(Path(r).as_posix() for r in rels)
    except Exception:
        return set()

def iter_files(root, exts_set, excludes_set, max_bytes, ignored_set):
    root = Path(root).resolve()
    for dirpath, dirnames, filenames in os.walk(root):
        # prune disallowed dirs
        pruned = []
        for d in list(dirnames):
            full = Path(dirpath) / d
            if should_skip_dir(full, excludes_set):
                pruned.append(d)
        for d in pruned:
            dirnames.remove(d)

        for name in filenames:
            p = Path(dirpath) / name
            rel_posix = p.resolve().relative_to(root).as_posix()

            # Skip git-ignored files if we have that info
            if rel_posix in ignored_set:
                continue

            if exts_set and p.suffix.lower() not in exts_set and name not in exts_set:
                continue
            try:
                if max_bytes and p.stat().st_size > max_bytes:
                    continue
            except OSError:
                continue
            yield p

def main():
    ap = argparse.ArgumentParser(description="Concatenate source files into a single doc with headers, honoring .gitignore if possible (no extra deps).")
    ap.add_argument("--root", default=".", help="Root directory to scan (default: .)")
    ap.add_argument("--output", default="project-code.txt", help="Output file path")
    ap.add_argument("--ext", default=",".join(DEFAULT_EXTS),
                    help="Comma-separated list of file extensions or exact filenames to include")
    ap.add_argument("--exclude", default=",".join(DEFAULT_EXCLUDES),
                    help="Comma-separated list of directories (or suffix paths) to exclude")
    ap.add_argument("--max-bytes", type=int, default=2*1024*1024,
                    help="Skip files larger than this (default 2 MiB)")
    args = ap.parse_args()

    exts = [e.strip() for e in args.ext.split(",") if e.strip()]
    norm_exts = set()
    for e in exts:
        if e.startswith(".") or "." in e:
            norm_exts.add(e.lower())
        else:
            norm_exts.add("." + e.lower())

    excludes = set([e.strip() for e in args.exclude.split(",") if e.strip()])

    root = Path(args.root).resolve()
    ignored_set = get_git_ignored(root)

    out_path = Path(args.output)
    out_path.parent.mkdir(parents=True, exist_ok=True)

    total_files = 0
    with out_path.open("w", encoding="utf-8", errors="replace") as out:
        out.write("# Consolidated source export\n")
        out.write(f"# Root: {root}\n")
        out.write(f"# Included: {sorted(norm_exts)}\n")
        out.write(f"# Excluded dirs: {sorted(excludes)}\n")
        out.write(f"# Git ignored entries skipped: {len(ignored_set)} (if repo)\n")
        out.write("# ---\n\n")

        for p in iter_files(root, norm_exts, excludes, args.max_bytes, ignored_set):
            rel = p.resolve().relative_to(root)
            try:
                content = p.read_text(encoding="utf-8", errors="replace")
            except Exception:
                continue
            out.write(f"\n\n===== BEGIN FILE: {rel} =====\n")
            out.write(content)
            if not content.endswith("\n"):
                out.write("\n")
            out.write(f"===== END FILE: {rel} =====\n")
            total_files += 1

    print(f"Done. Wrote {total_files} files into {out_path}")

if __name__ == "__main__":
    sys.exit(main())
===== END FILE: flatten_code.py =====


===== BEGIN FILE: .yarnrc.yml =====
nodeLinker: node-modules
===== END FILE: .yarnrc.yml =====


===== BEGIN FILE: jest.config.js =====
/** @type {import('@jest/types').Config.ProjectConfig} */
module.exports = {
  preset: "jest-expo",
  setupFiles: ["<rootDir>/test/setup.ts"],
}
===== END FILE: jest.config.js =====


===== BEGIN FILE: eas.json =====
{
  "cli": {
    "version": ">= 3.15.1"
  },
  "build": {
    "development": {
      "extends": "production",
      "distribution": "internal",
      "android": {
        "gradleCommand": ":app:assembleDebug"
      },
      "ios": {
        "buildConfiguration": "Debug",
        "simulator": true
      }
    },
    "development:device": {
      "extends": "development",
      "distribution": "internal",
      "ios": {
        "buildConfiguration": "Debug",
        "simulator": false
      }
    },
    "preview": {
      "extends": "production",
      "distribution": "internal",
      "ios": { "simulator": true },
      "android": { "buildType": "apk" }
    },
    "preview:device": {
      "extends": "preview",
      "ios": { "simulator": false }
    },
    "production": {}
  },
  "submit": {
    "production": {}
  }
}
===== END FILE: eas.json =====


===== BEGIN FILE: README.md =====
# Welcome to your new ignited app!

> The latest and greatest boilerplate for Infinite Red opinions

This is the boilerplate that [Infinite Red](https://infinite.red) uses as a way to test bleeding-edge changes to our React Native stack.

- [Quick start documentation](https://github.com/infinitered/ignite/blob/master/docs/boilerplate/Boilerplate.md)
- [Full documentation](https://github.com/infinitered/ignite/blob/master/docs/README.md)

## Getting Started

```bash
yarn install
yarn start
```

To make things work on your local simulator, or on your phone, you need first to [run `eas build`](https://github.com/infinitered/ignite/blob/master/docs/expo/EAS.md). We have many shortcuts on `package.json` to make it easier:

```bash
yarn build:ios:sim # build for ios simulator
yarn build:ios:dev # build for ios device
yarn build:ios:prod # build for ios device
```

### `./assets` directory

This directory is designed to organize and store various assets, making it easy for you to manage and use them in your application. The assets are further categorized into subdirectories, including `icons` and `images`:

```tree
assets
├── icons
└── images
```

**icons**
This is where your icon assets will live. These icons can be used for buttons, navigation elements, or any other UI components. The recommended format for icons is PNG, but other formats can be used as well.

Ignite comes with a built-in `Icon` component. You can find detailed usage instructions in the [docs](https://github.com/infinitered/ignite/blob/master/docs/boilerplate/app/components/Icon.md).

**images**
This is where your images will live, such as background images, logos, or any other graphics. You can use various formats such as PNG, JPEG, or GIF for your images.

Another valuable built-in component within Ignite is the `AutoImage` component. You can find detailed usage instructions in the [docs](https://github.com/infinitered/ignite/blob/master/docs/Components-AutoImage.md).

How to use your `icon` or `image` assets:

```typescript
import { Image } from 'react-native';

const MyComponent = () => {
  return (
    <Image source={require('assets/images/my_image.png')} />
  );
};
```

## Running Maestro end-to-end tests

Follow our [Maestro Setup](https://ignitecookbook.com/docs/recipes/MaestroSetup) recipe.

## Next Steps

### Ignite Cookbook

[Ignite Cookbook](https://ignitecookbook.com/) is an easy way for developers to browse and share code snippets (or “recipes”) that actually work.

### Upgrade Ignite boilerplate

Read our [Upgrade Guide](https://ignitecookbook.com/docs/recipes/UpdatingIgnite) to learn how to upgrade your Ignite project.

## Community

⭐️ Help us out by [starring on GitHub](https://github.com/infinitered/ignite), filing bug reports in [issues](https://github.com/infinitered/ignite/issues) or [ask questions](https://github.com/infinitered/ignite/discussions).

💬 Join us on [Slack](https://join.slack.com/t/infiniteredcommunity/shared_invite/zt-1f137np4h-zPTq_CbaRFUOR_glUFs2UA) to discuss.

📰 Make our Editor-in-chief happy by [reading the React Native Newsletter](https://reactnativenewsletter.com/).
===== END FILE: README.md =====


===== BEGIN FILE: metro.config.js =====
/* eslint-env node */
// Learn more https://docs.expo.io/guides/customizing-metro
const { getDefaultConfig } = require("expo/metro-config")

/** @type {import('expo/metro-config').MetroConfig} */
const config = getDefaultConfig(__dirname)

config.transformer.getTransformOptions = async () => ({
  transform: {
    // Inline requires are very useful for deferring loading of large dependencies/components.
    // For example, we use it in app.tsx to conditionally load Reactotron.
    // However, this comes with some gotchas.
    // Read more here: https://reactnative.dev/docs/optimizing-javascript-loading
    // And here: https://github.com/expo/expo/issues/27279#issuecomment-1971610698
    inlineRequires: true,
  },
})

// This is a temporary fix that helps fixing an issue with axios/apisauce.
// See the following issues in Github for more details:
// https://github.com/infinitered/apisauce/issues/331
// https://github.com/axios/axios/issues/6899
// The solution was taken from the following issue:
// https://github.com/facebook/metro/issues/1272
config.resolver.unstable_conditionNames = ["require", "default", "browser"]

// This helps support certain popular third-party libraries
// such as Firebase that use the extension cjs.
config.resolver.sourceExts.push("cjs")

module.exports = config
===== END FILE: metro.config.js =====


===== BEGIN FILE: app.config.ts =====
import { ExpoConfig, ConfigContext } from "@expo/config"

/**
 * Use ts-node here so we can use TypeScript for our Config Plugins
 * and not have to compile them to JavaScript
 */
require("ts-node/register")

/**
 * @param config ExpoConfig coming from the static config app.json if it exists
 *
 * You can read more about Expo's Configuration Resolution Rules here:
 * https://docs.expo.dev/workflow/configuration/#configuration-resolution-rules
 */
module.exports = ({ config }: ConfigContext): Partial<ExpoConfig> => {
  const existingPlugins = config.plugins ?? []

  return {
    ...config,
    ios: {
      ...config.ios,
      // This privacyManifests is to get you started.
      // See Expo's guide on apple privacy manifests here:
      // https://docs.expo.dev/guides/apple-privacy/
      // You may need to add more privacy manifests depending on your app's usage of APIs.
      // More details and a list of "required reason" APIs can be found in the Apple Developer Documentation.
      // https://developer.apple.com/documentation/bundleresources/privacy-manifest-files
      privacyManifests: {
        NSPrivacyAccessedAPITypes: [
          {
            NSPrivacyAccessedAPIType: "NSPrivacyAccessedAPICategoryUserDefaults",
            NSPrivacyAccessedAPITypeReasons: ["CA92.1"], // CA92.1 = "Access info from same app, per documentation"
          },
        ],
      },
    },
    plugins: [...existingPlugins, require("./plugins/withSplashScreen").withSplashScreen],
  }
}
===== END FILE: app.config.ts =====


===== BEGIN FILE: babel.config.js =====
/** @type {import('@babel/core').TransformOptions} */
module.exports = function (api) {
  api.cache(true)
  return {
    presets: ["babel-preset-expo"],
  }
}
===== END FILE: babel.config.js =====


===== BEGIN FILE: .gitignore =====
# OSX
#
.DS_Store

# Xcode
#
build/
*.pbxuser
!default.pbxuser
*.mode1v3
!default.mode1v3
*.mode2v3
!default.mode2v3
*.perspectivev3
!default.perspectivev3
xcuserdata
*.xccheckout
*.moved-aside
DerivedData
*.hmap
*.ipa
*.xcuserstate
ios/.xcode.env.local

# Android/IntelliJ
#
build/
.idea
.gradle
local.properties
*.iml
*.hprof
.cxx/

# node.js
#
node_modules/
npm-debug.log
yarn-error.log

# BUCK
buck-out/
\.buckd/
*.keystore
!debug.keystore

# fastlane
#
# It is recommended to not store the screenshots in the git repo. Instead, use fastlane to re-generate the
# screenshots whenever they are needed.
# For more information about the recommended setup visit:
# https://docs.fastlane.tools/best-practices/source-control/

**/fastlane/report.xml
**/fastlane/Preview.html
**/fastlane/screenshots
**/fastlane/test_output

# Bundle artifact
*.jsbundle

# Ignite-specific items below
# You can safely replace everything above this comment with whatever is
# in the default .gitignore generated by React-Native CLI

# VS Code
.vscode

# Expo
.expo/*
bin/Exponent.app
expo-env.d.ts

## Secrets
npm-debug.*
*.jks
*.p8
*.p12
*.key
*.mobileprovision
*.orig.*
web-build/

# Configurations
!env.js

/coverage

# Yarn
.yarn/*
!.yarn/patches
!.yarn/plugins
!.yarn/releases
!.yarn/sdks
!.yarn/versions
===== END FILE: .gitignore =====


===== BEGIN FILE: package.json =====
{
  "name": "oolshik",
  "version": "0.0.1",
  "private": true,
  "main": "index.tsx",
  "scripts": {
    "start": "expo start --dev-client",
    "android": "expo run:android",
    "ios": "expo run:ios",
    "web": "expo start --web",
    "bundle:web": "npx expo export --platform web",
    "serve:web": "npx serve dist",
    "prebuild:clean": "npx expo prebuild --clean",
    "compile": "tsc --noEmit -p . --pretty",
    "lint": "eslint . --fix",
    "lint:check": "eslint .",
    "align-deps": "npx expo install --fix",
    "test": "jest",
    "test:watch": "jest --watch",
    "test:maestro": "maestro test -e MAESTRO_APP_ID=com.oolshik.aan .maestro/flows",
    "adb": "adb reverse tcp:9090 tcp:9090 && adb reverse tcp:3000 tcp:3000 && adb reverse tcp:9001 tcp:9001 && adb reverse tcp:8081 tcp:8081",
    "build:ios:sim": "eas build --profile development --platform ios --local",
    "build:ios:dev": "eas build --profile development:device --platform ios --local",
    "build:ios:preview": "eas build --profile preview --platform ios --local",
    "build:ios:prod": "eas build --profile production --platform ios --local",
    "build:android:sim": "eas build --profile development --platform android --local",
    "build:android:dev": "eas build --profile development:device --platform android --local",
    "build:android:preview": "eas build --profile preview --platform android --local",
    "build:android:prod": "eas build --profile production --platform android --local"
  },
  "dependencies": {
    "@expo-google-fonts/space-grotesk": "^0.4.0",
    "@expo/metro-runtime": "~5.0.4",
    "@react-native-community/slider": "^5.0.1",
    "@react-navigation/bottom-tabs": "^7.2.0",
    "@react-navigation/native": "^7.0.14",
    "@react-navigation/native-stack": "^7.2.0",
    "apisauce": "^3.2.0",
    "date-fns": "^4.1.0",
    "eventemitter3": "^5.0.1",
    "expo": "^53.0.15",
    "expo-application": "~6.1.4",
    "expo-av": "~15.1.7",
    "expo-build-properties": "~0.14.6",
    "expo-dev-client": "~5.2.1",
    "expo-file-system": "~18.1.11",
    "expo-font": "~13.3.0",
    "expo-linking": "~7.1.4",
    "expo-localization": "~16.1.5",
    "expo-location": "~18.1.6",
    "expo-notifications": "~0.31.4",
    "expo-splash-screen": "~0.30.9",
    "expo-system-ui": "~5.0.9",
    "i18next": "^23.14.0",
    "intl-pluralrules": "^2.0.1",
    "react": "19.0.0",
    "react-dom": "19.0.0",
    "react-i18next": "^15.0.1",
    "react-native": "0.79.4",
    "react-native-drawer-layout": "^4.0.1",
    "react-native-edge-to-edge": "1.6.0",
    "react-native-fs": "^2.20.0",
    "react-native-gesture-handler": "~2.24.0",
    "react-native-keyboard-controller": "^1.12.7",
    "react-native-mmkv": "^3.2.0",
    "react-native-reanimated": "~3.17.4",
    "react-native-safe-area-context": "5.4.0",
    "react-native-screens": "~4.11.1",
    "react-native-web": "^0.20.0",
    "zustand": "^5.0.7"
  },
  "devDependencies": {
    "@babel/core": "^7.20.0",
    "@babel/preset-env": "^7.20.0",
    "@babel/runtime": "^7.20.0",
    "@testing-library/react-native": "^13.2.0",
    "@types/jest": "^29.5.14",
    "@types/react": "~19.0.10",
    "babel-jest": "^29.2.1",
    "eslint": "^8.57.0",
    "eslint-config-expo": "~9.2.0",
    "eslint-config-prettier": "^9.1.0",
    "eslint-plugin-prettier": "^5.2.1",
    "eslint-plugin-react-native": "^4.1.0",
    "eslint-plugin-reactotron": "^0.1.2",
    "jest": "~29.7.0",
    "jest-expo": "~53.0.7",
    "prettier": "^3.3.3",
    "react-test-renderer": "19.0.0",
    "reactotron-core-client": "^2.9.4",
    "reactotron-react-js": "^3.3.11",
    "reactotron-react-native": "^5.0.5",
    "reactotron-react-native-mmkv": "^0.2.6",
    "ts-jest": "^29.1.1",
    "ts-node": "^10.9.2",
    "typescript": "~5.8.3"
  },
  "engines": {
    "node": ">=20.0.0"
  }
}
===== END FILE: package.json =====


===== BEGIN FILE: .eslintrc.js =====
// https://docs.expo.dev/guides/using-eslint/
module.exports = {
  root: true,
  extends: [
    "plugin:@typescript-eslint/recommended",
    "plugin:react/recommended",
    "plugin:react-native/all",
    // `expo` must come after `standard` or its globals configuration will be overridden
    "expo",
    // `jsx-runtime` must come after `expo` or it will be overridden
    "plugin:react/jsx-runtime",
    "prettier",
  ],
  plugins: ["reactotron", "prettier"],
  rules: {
    "prettier/prettier": "error",
    // typescript-eslint
    "@typescript-eslint/array-type": 0,
    "@typescript-eslint/ban-ts-comment": 0,
    "@typescript-eslint/no-explicit-any": 0,
    "@typescript-eslint/no-unused-vars": [
      "error",
      {
        argsIgnorePattern: "^_",
        varsIgnorePattern: "^_",
      },
    ],
    "@typescript-eslint/no-var-requires": 0,
    "@typescript-eslint/no-require-imports": 0,
    "@typescript-eslint/no-empty-object-type": 0,
    // eslint
    "no-use-before-define": 0,
    "no-restricted-imports": [
      "error",
      {
        paths: [
          // Prefer named exports from 'react' instead of importing `React`
          {
            name: "react",
            importNames: ["default"],
            message: "Import named exports from 'react' instead.",
          },
          {
            name: "react-native",
            importNames: ["SafeAreaView"],
            message: "Use the SafeAreaView from 'react-native-safe-area-context' instead.",
          },
          {
            name: "react-native",
            importNames: ["Text", "Button", "TextInput"],
            message: "Use the custom wrapper component from '@/components'.",
          },
        ],
      },
    ],
    // react
    "react/prop-types": 0,
    // react-native
    "react-native/no-raw-text": 0,
    // reactotron
    "reactotron/no-tron-in-production": "error",
    // eslint-config-standard overrides
    "comma-dangle": 0,
    "no-global-assign": 0,
    "quotes": 0,
    "space-before-function-paren": 0,
    // eslint-import
    "import/order": [
      "error",
      {
        "alphabetize": {
          order: "asc",
          caseInsensitive: true,
        },
        "newlines-between": "always",
        "groups": [["builtin", "external"], "internal", "unknown", ["parent", "sibling"], "index"],
        "distinctGroup": false,
        "pathGroups": [
          {
            pattern: "react",
            group: "external",
            position: "before",
          },
          {
            pattern: "react-native",
            group: "external",
            position: "before",
          },
          {
            pattern: "expo{,-*}",
            group: "external",
            position: "before",
          },
          {
            pattern: "@/**",
            group: "unknown",
            position: "after",
          },
        ],
        "pathGroupsExcludedImportTypes": ["react", "react-native", "expo", "expo-*"],
      },
    ],
    "import/newline-after-import": 1,
  },
}
===== END FILE: .eslintrc.js =====


===== BEGIN FILE: tsconfig.json =====
{
  "extends": "expo/tsconfig.base",
  "compilerOptions": {
    "allowJs": false,
    "allowSyntheticDefaultImports": true,
    "experimentalDecorators": true,
    "jsx": "react-native",
    "customConditions": [
      "react-native"
    ],
    "module": "esnext",
    "moduleResolution": "bundler",
    "strict": true,
    "noImplicitAny": true,
    "noImplicitReturns": true,
    "noImplicitThis": true,
    "sourceMap": true,
    "target": "esnext",
    "lib": [
      "esnext",
      "dom"
    ],
    "skipLibCheck": true,
    "resolveJsonModule": true,
    "baseUrl": ".",
    "paths": {
      "@/*": [
        "./app/*"
      ],
      "@assets/*": [
        "./assets/*"
      ]
    },
    "typeRoots": [
      "./node_modules/@types",
      "./types"
    ]
  },
  "ts-node": {
    "compilerOptions": {
      "module": "commonjs"
    }
  },
  "include": [
    "**/*.ts",
    "**/*.tsx"
  ],
  "exclude": [
    "node_modules",
    "test/**/*"
  ]
}
===== END FILE: tsconfig.json =====


===== BEGIN FILE: types/lib.es5.d.ts =====
/**
 * Fixes https://github.com/microsoft/TypeScript/issues/16655 for `Array.prototype.filter()`
 * For example, using the fix the type of `bar` is `string[]` in the below snippet as it should be.
 *
 *  const foo: (string | null | undefined)[] = [];
 *  const bar = foo.filter(Boolean);
 *
 * For related definitions, see https://github.com/microsoft/TypeScript/blob/master/src/lib/es5.d.ts
 *
 * Original licenses apply, see
 *  - https://github.com/microsoft/TypeScript/blob/master/LICENSE.txt
 *  - https://stackoverflow.com/help/licensing
 */

/** See https://stackoverflow.com/a/51390763/1470607  */
type Falsy = false | 0 | "" | null | undefined

interface Array<T> {
  /**
   * Returns the elements of an array that meet the condition specified in a callback function.
   * @param predicate A function that accepts up to three arguments. The filter method calls the predicate function one time for each element in the array.
   * @param thisArg An object to which the this keyword can refer in the predicate function. If thisArg is omitted, undefined is used as the this value.
   */
  filter<S extends T>(predicate: BooleanConstructor, thisArg?: any): Exclude<S, Falsy>[]
}
===== END FILE: types/lib.es5.d.ts =====


===== BEGIN FILE: app/app.tsx =====
/* eslint-disable import/first */
/**
 * Welcome to the main entry point of the app. In this file, we'll
 * be kicking off our app.
 *
 * Most of this file is boilerplate and you shouldn't need to modify
 * it very often. But take some time to look through and understand
 * what is going on here.
 *
 * The app navigation resides in ./app/navigators, so head over there
 * if you're interested in adding screens and navigators.
 */
if (__DEV__) {
  // Load Reactotron in development only.
  // Note that you must be using metro's `inlineRequires` for this to work.
  // If you turn it off in metro.config.js, you'll have to manually import it.
  require("./devtools/ReactotronConfig.ts")
}
import "./utils/gestureHandler"

import { useEffect, useState } from "react"
import { useFonts } from "expo-font"
import * as Linking from "expo-linking"
import { KeyboardProvider } from "react-native-keyboard-controller"
import { initialWindowMetrics, SafeAreaProvider } from "react-native-safe-area-context"

import { AuthProvider } from "./context/AuthContext" // @demo remove-current-line
import { initI18n } from "./i18n"
import { AppNavigator } from "./navigators/AppNavigator"
import { useNavigationPersistence } from "./navigators/navigationUtilities"
import { ThemeProvider } from "./theme/context"
import { customFontsToLoad } from "./theme/typography"
import { loadDateFnsLocale } from "./utils/formatDate"
import * as storage from "./utils/storage"

export const NAVIGATION_PERSISTENCE_KEY = "NAVIGATION_STATE"

// Web linking configuration
const prefix = Linking.createURL("/")
const config = {
  screens: {
    Login: {
      path: "",
    },
    Welcome: "welcome",
    Demo: {
      screens: {
        DemoShowroom: {
          path: "showroom/:queryIndex?/:itemIndex?",
        },
        DemoDebug: "debug",
        DemoPodcastList: "podcast",
        DemoCommunity: "community",
      },
    },
  },
}

/**
 * This is the root component of our app.
 * @param {AppProps} props - The props for the `App` component.
 * @returns {JSX.Element} The rendered `App` component.
 */
export function App() {
  const {
    initialNavigationState,
    onNavigationStateChange,
    isRestored: isNavigationStateRestored,
  } = useNavigationPersistence(storage, NAVIGATION_PERSISTENCE_KEY)

  const [areFontsLoaded, fontLoadError] = useFonts(customFontsToLoad)
  const [isI18nInitialized, setIsI18nInitialized] = useState(false)

  useEffect(() => {
    initI18n()
      .then(() => setIsI18nInitialized(true))
      .then(() => loadDateFnsLocale())
  }, [])

  // Before we show the app, we have to wait for our state to be ready.
  // In the meantime, don't render anything. This will be the background
  // color set in native by rootView's background color.
  // In iOS: application:didFinishLaunchingWithOptions:
  // In Android: https://stackoverflow.com/a/45838109/204044
  // You can replace with your own loading component if you wish.
  if (!isNavigationStateRestored || !isI18nInitialized || (!areFontsLoaded && !fontLoadError)) {
    return null
  }

  const linking = {
    prefixes: [prefix],
    config,
  }

  // otherwise, we're ready to render the app
  return (
    <SafeAreaProvider initialMetrics={initialWindowMetrics}>
      <KeyboardProvider>
        {/* @demo remove-block-start */}
        <AuthProvider>
          {/* @demo remove-block-end */}
          <ThemeProvider>
            <AppNavigator
              linking={linking}
              initialState={initialNavigationState}
              onStateChange={onNavigationStateChange}
            />
          </ThemeProvider>
          {/* @demo remove-block-start */}
        </AuthProvider>
        {/* @demo remove-block-end */}
      </KeyboardProvider>
    </SafeAreaProvider>
  )
}
===== END FILE: app/app.tsx =====


===== BEGIN FILE: app/mocks/nearbyTasks.ts =====
export type MockTask = {
  id: string
  voiceUrl?: string | null
  description?: string
  distanceMtr?: number
  status: "PENDING" | "ASSIGNED" | "COMPLETED"
  createdById: string
  createdByName: string
  createdAt?: string // 10 min ago
}

export const MOCK_NEARBY_TASKS: MockTask[] = [
  {
    id: "T-1001",
    description: "Switch on motor",
    distanceMtr: 0.3,
    status: "PENDING",
    voiceUrl: "https://www.soundhelix.com/examples/mp3/SoundHelix-Song-1.mp3",
    createdById: "U-01",
    createdByName: "Amit",
    createdAt: new Date(Date.now() - 10 * 60 * 1000).toISOString(), // 10 min ago
  },
  {
    id: "T-1002",
    description: "Bring 1L milk",
    distanceMtr: 0.9,
    status: "PENDING",
    voiceUrl: null,
    createdById: "U-01",
    createdByName: "Rahul",
    createdAt: new Date(Date.now() - 35 * 60 * 1000).toISOString(), // 10 min ago
  },
  {
    id: "T-1003",
    description: "Parcel pickup at main gate",
    distanceMtr: 1.6,
    status: "PENDING",
    voiceUrl: null,
    createdById: "U-01",
    createdByName: "Sagar",
    createdAt: new Date(Date.now() - 45 * 60 * 1000).toISOString(), // 10 min ago
  },
  {
    id: "T-1004",
    description: "Need help lifting a box",
    distanceMtr: 2.4,
    status: "PENDING",
    voiceUrl: null,
    createdById: "U-01",
    createdByName: "Gorakh",
    createdAt: new Date(Date.now() - 55 * 60 * 1000).toISOString(), // 10 min ago
  },
]
===== END FILE: app/mocks/nearbyTasks.ts =====


===== BEGIN FILE: app/context/EpisodeContext.tsx =====
import {
  createContext,
  FC,
  PropsWithChildren,
  useCallback,
  useContext,
  useMemo,
  useState,
} from "react"

import { translate } from "@/i18n/translate"
import { api } from "@/services/api"
import type { EpisodeItem } from "@/services/api/types"
import { formatDate } from "@/utils/formatDate"

export type EpisodeContextType = {
  totalEpisodes: number
  totalFavorites: number
  episodesForList: EpisodeItem[]
  fetchEpisodes: () => Promise<void>
  favoritesOnly: boolean
  toggleFavoritesOnly: () => void
  hasFavorite: (episode: EpisodeItem) => boolean
  toggleFavorite: (episode: EpisodeItem) => void
}

export const EpisodeContext = createContext<EpisodeContextType | null>(null)

export interface EpisodeProviderProps {}

export const EpisodeProvider: FC<PropsWithChildren<EpisodeProviderProps>> = ({ children }) => {
  const [episodes, setEpisodes] = useState<EpisodeItem[]>([])
  const [favorites, setFavorites] = useState<string[]>([])
  const [favoritesOnly, setFavoritesOnly] = useState<boolean>(false)

  const fetchEpisodes = useCallback(async () => {
    const response = await api.getEpisodes()
    if (response.kind === "ok") {
      setEpisodes(response.episodes)
    } else {
      console.error(`Error fetching episodes: ${JSON.stringify(response)}`)
    }
  }, [])

  const toggleFavoritesOnly = useCallback(() => {
    setFavoritesOnly((prev) => !prev)
  }, [])

  const toggleFavorite = useCallback(
    (episode: EpisodeItem) => {
      if (favorites.some((fav) => fav === episode.guid)) {
        setFavorites((prev) => prev.filter((fav) => fav !== episode.guid))
      } else {
        setFavorites((prev) => [...prev, episode.guid])
      }
    },
    [favorites],
  )

  const hasFavorite = useCallback(
    (episode: EpisodeItem) => favorites.some((fav) => fav === episode.guid),
    [favorites],
  )

  const episodesForList = useMemo(() => {
    return favoritesOnly ? episodes.filter((episode) => favorites.includes(episode.guid)) : episodes
  }, [episodes, favorites, favoritesOnly])

  const value = {
    totalEpisodes: episodes.length,
    totalFavorites: favorites.length,
    episodesForList,
    fetchEpisodes,
    favoritesOnly,
    toggleFavoritesOnly,
    hasFavorite,
    toggleFavorite,
  }

  return <EpisodeContext.Provider value={value}>{children}</EpisodeContext.Provider>
}

export const useEpisodes = () => {
  const context = useContext(EpisodeContext)
  if (!context) throw new Error("useEpisodes must be used within an EpisodeProvider")
  return context
}

// A helper hook to extract and format episode details
export const useEpisode = (episode: EpisodeItem) => {
  const { hasFavorite } = useEpisodes()

  const isFavorite = hasFavorite(episode)

  let datePublished
  try {
    const formatted = formatDate(episode.pubDate)
    datePublished = {
      textLabel: formatted,
      accessibilityLabel: translate("demoPodcastListScreen:accessibility.publishLabel", {
        date: formatted,
      }),
    }
  } catch {
    datePublished = { textLabel: "", accessibilityLabel: "" }
  }

  const seconds = Number(episode.enclosure?.duration ?? 0)
  const h = Math.floor(seconds / 3600)
  const m = Math.floor((seconds % 3600) / 60)
  const s = Math.floor((seconds % 3600) % 60)
  const duration = {
    textLabel: `${h > 0 ? `${h}:` : ""}${m > 0 ? `${m}:` : ""}${s}`,
    accessibilityLabel: translate("demoPodcastListScreen:accessibility.durationLabel", {
      hours: h,
      minutes: m,
      seconds: s,
    }),
  }

  const trimmedTitle = episode.title?.trim()
  const titleMatches = trimmedTitle?.match(/^(RNR.*\d)(?: - )(.*$)/)
  const parsedTitleAndSubtitle =
    titleMatches && titleMatches.length === 3
      ? { title: titleMatches[1], subtitle: titleMatches[2] }
      : { title: trimmedTitle, subtitle: "" }

  return {
    isFavorite,
    datePublished,
    duration,
    parsedTitleAndSubtitle,
  }
}

// @demo remove-file
===== END FILE: app/context/EpisodeContext.tsx =====


===== BEGIN FILE: app/context/AuthContext.tsx =====
import { setLoginTokens } from "@/api/client"
import { authEvents } from "@/auth/events"
import { navigationRef } from "@/navigators/navigationUtilities"
import React, {
  createContext,
  useContext,
  useMemo,
  PropsWithChildren,
  useCallback,
  useEffect, // ✅ added
} from "react"
import { useMMKVString } from "react-native-mmkv"

export type AuthContextType = {
  isAuthenticated: boolean
  authToken?: string
  authEmail?: string
  userId?: string
  userName?: string
  setAuthToken: (token?: string) => void
  setAuthEmail: (email?: string) => void
  setUserId: (id?: string) => void
  setUserName: (name?: string) => void
  logout: () => void
  validationError: string
}
export const MMKV_AUTH_TOKEN = "auth.token"
export const MMKV_AUTH_EMAIL = "auth.email"
export const MMKV_USER_ID = "auth.userId"
export const MMKV_USER_NAME = "auth.userName"

export const AuthContext = createContext<AuthContextType | null>(null)

export interface AuthProviderProps {}

export function AuthProvider({ children }: PropsWithChildren<AuthProviderProps>) {
  const [authToken, setAuthTokenMMKV] = useMMKVString(MMKV_AUTH_TOKEN)
  const [authEmail, setAuthEmailMMKV] = useMMKVString(MMKV_AUTH_EMAIL)
  const [userId, setUserIdMMKV] = useMMKVString(MMKV_USER_ID)
  const [userName, setUserNameMMKV] = useMMKVString(MMKV_USER_NAME)

  // Defaults for local/dev use
  const effectiveUserId = userId || "U-LOCAL-1"
  const effectiveUserName = userName || "You"

  const setAuthToken = useCallback(
    (token?: string) => {
      setAuthTokenMMKV(token ?? "")
      // ✅ keep HTTP client Authorization header in sync immediately
      // setLoginTokens(token || undefined) // (refresh stays as-is, managed by client after OTP/refresh)
    },
    [setAuthTokenMMKV],
  )

  const setAuthEmail = useCallback(
    (email?: string) => setAuthEmailMMKV(email ?? ""),
    [setAuthEmailMMKV],
  )

  const setUserId = useCallback((id?: string) => setUserIdMMKV(id ?? ""), [setUserIdMMKV])

  const setUserName = useCallback((name?: string) => setUserNameMMKV(name ?? ""), [setUserNameMMKV])

  const logout = useCallback(() => {
    // ✅ clear persisted state
    setAuthTokenMMKV("")
    setAuthEmailMMKV("")
    setUserIdMMKV("")
    setUserNameMMKV("")
    // ✅ clear Authorization header in the HTTP client
    setLoginTokens(undefined, undefined)
    // (navigation back to Login is handled by your app’s routing on isAuthenticated=false)
  }, [setAuthTokenMMKV, setAuthEmailMMKV, setUserIdMMKV, setUserNameMMKV])

  // ✅ on mount & whenever authToken changes (e.g., app relaunch), sync header once
  // useEffect(() => {
  //   setLoginTokens(authToken || undefined)
  // }, [authToken])

  useEffect(() => {
    const handler = () => {
      logout()
    }
    authEvents.on("logout", handler)
    return () => {
      authEvents.off("logout", handler)
    }
  }, [])

  // 🔑 email validation logic preserved
  const validationError = useMemo(() => {
    if (!authEmail || authEmail.length === 0) return "can't be blank"
    if (authEmail.length < 6) return "must be at least 6 characters"
    if (!/^[^\s@]+@[^\s@]+\.[^\s@]+$/.test(authEmail)) return "must be a valid email address"
    return ""
  }, [authEmail])

  const value: AuthContextType = useMemo(
    () => ({
      isAuthenticated: !!authToken,
      authToken: authToken || undefined,
      authEmail: authEmail || undefined,
      userId: effectiveUserId,
      userName: effectiveUserName,
      setAuthToken,
      setAuthEmail,
      setUserId,
      setUserName,
      logout,
      validationError,
    }),
    [
      authToken,
      authEmail,
      effectiveUserId,
      effectiveUserName,
      setAuthToken,
      setAuthEmail,
      setUserId,
      setUserName,
      logout,
      validationError,
    ],
  )

  return <AuthContext.Provider value={value}>{children}</AuthContext.Provider>
}

export const useAuth = () => {
  const ctx = useContext(AuthContext)
  if (!ctx) throw new Error("useAuth must be used within an AuthProvider")
  return ctx
}
===== END FILE: app/context/AuthContext.tsx =====


===== BEGIN FILE: app/config/config.base.ts =====
export interface ConfigBaseProps {
  persistNavigation: "always" | "dev" | "prod" | "never"
  catchErrors: "always" | "dev" | "prod" | "never"
  exitRoutes: string[]
}

export type PersistNavigationConfig = ConfigBaseProps["persistNavigation"]

const BaseConfig: ConfigBaseProps = {
  // This feature is particularly useful in development mode, but
  // can be used in production as well if you prefer.
  persistNavigation: "dev",

  /**
   * Only enable if we're catching errors in the right environment
   */
  catchErrors: "always",

  /**
   * This is a list of all the route names that will exit the app if the back button
   * is pressed while in that screen. Only affects Android.
   */
  exitRoutes: ["Welcome"],
}

export default BaseConfig
===== END FILE: app/config/config.base.ts =====


===== BEGIN FILE: app/config/config.prod.ts =====
/**
 * These are configuration settings for the production environment.
 *
 * Do not include API secrets in this file or anywhere in your JS.
 *
 * https://reactnative.dev/docs/security#storing-sensitive-info
 */
export default {
  API_URL: "",
}
===== END FILE: app/config/config.prod.ts =====


===== BEGIN FILE: app/config/flags.ts =====
// Flip this to false when backend is live
export const FLAGS = {
  USE_MOCK_NEARBY: false,
  USE_MOCK_UPLOAD_CREATE: false,
}
===== END FILE: app/config/flags.ts =====


===== BEGIN FILE: app/config/index.ts =====
/**
 * This file imports configuration objects from either the config.dev.js file
 * or the config.prod.js file depending on whether we are in __DEV__ or not.
 *
 * Note that we do not gitignore these files. Unlike on web servers, just because
 * these are not checked into your repo doesn't mean that they are secure.
 * In fact, you're shipping a JavaScript bundle with every
 * config variable in plain text. Anyone who downloads your app can easily
 * extract them.
 *
 * If you doubt this, just bundle your app, and then go look at the bundle and
 * search it for one of your config variable values. You'll find it there.
 *
 * Read more here: https://reactnative.dev/docs/security#storing-sensitive-info
 */
import BaseConfig from "./config.base"
import DevConfig from "./config.dev"
import ProdConfig from "./config.prod"

let ExtraConfig = ProdConfig

if (__DEV__) {
  ExtraConfig = DevConfig
}

const Config = { ...BaseConfig, ...ExtraConfig }

export default Config
===== END FILE: app/config/index.ts =====


===== BEGIN FILE: app/config/config.dev.ts =====
/**
 * These are configuration settings for the dev environment.
 *
 * Do not include API secrets in this file or anywhere in your JS.
 *
 * https://reactnative.dev/docs/security#storing-sensitive-info
 */
export default {
  API_URL: "http://10.0.2.2:8080/api",
}
===== END FILE: app/config/config.dev.ts =====


===== BEGIN FILE: app/auth/tokens.ts =====
import { storage } from "@/utils/storage"

// app/auth/tokens.ts
const K = {
  access: "auth.accessToken",
  refresh: "auth.refreshToken",
} as const

export const tokens = {
  get access() {
    return storage.getString(K.access) ?? null
  },
  get refresh() {
    return storage.getString(K.refresh) ?? null
  },
  setBoth(access?: string | null, refresh?: string | null) {
    if (access) {
      storage.set(K.access, access)
    } else {
      storage.delete(K.access)
    }
    if (refresh) {
      storage.set(K.refresh, refresh)
    } else {
      storage.delete(K.refresh)
    }
  },
  clear() {
    storage.delete(K.access)
    storage.delete(K.refresh)
  },
}
===== END FILE: app/auth/tokens.ts =====


===== BEGIN FILE: app/auth/events.ts =====
import { EventEmitter } from "eventemitter3"

// app/auth/events.ts
export const authEvents = new EventEmitter()
// elsewhere: authEvents.on("logout", () => { /* navigate to Login */ })
===== END FILE: app/auth/events.ts =====


===== BEGIN FILE: app/navigators/OolshikNavigator.tsx =====
import React, { useEffect, useState } from "react"
import { createNativeStackNavigator } from "@react-navigation/native-stack"
import OnboardingConsentScreen from "@/screens/OnboardingConsentScreen"
import HomeFeedScreen from "@/screens/HomeFeedScreen"
import CreateTaskScreen from "@/screens/CreateTaskScreen"
import TaskDetailScreen from "@/screens/TaskDetailScreen"
import MyTasksScreen from "@/screens/MyTasksScreen"
import ChatScreen from "@/screens/ChatScreen"
import ProfileScreen from "@/screens/ProfileScreen"
import ReportScreen from "@/screens/ReportScreen"
import { useMMKVString } from "react-native-mmkv"
import { storage } from "@/utils/storage"

/**
 * IMPORTANT
 * We decide the initial route at runtime so that:
 * - Onboarding is shown ONLY the first time after login OR when we detect it hasn't been completed.
 * - Otherwise, users go straight to Home.
 *
 * We persist a single boolean flag after a successful onboarding flow:
 *   key: "onboarding.v1.completed" -> "true" | undefined
 *
 * If your OnboardingConsentScreen already handles permissions, call:
 *   await AsyncStorage.setItem("onboarding.v1.completed", "true")
 * when the user finishes granting or explicitly skipping with your app's policy.
 */

export type OolshikParamList = {
  OolshikOnboard: undefined
  OolshikHome: undefined
  OolshikCreate: undefined
  OolshikDetail: { id: string }
  OolshikMy: undefined
  OolshikChat: { taskId: string }
  OolshikProfile: undefined
  OolshikReport: { taskId?: string; targetUserId?: string }
}

const Stack = createNativeStackNavigator<OolshikParamList>()

export function OolshikNavigator() {
  const [initialRoute, setInitialRoute] = useState<keyof OolshikParamList | null>(null)
  const [onboardingComplete, setOnboardingComplete] = useMMKVString(
    "onboarding.v1.completed",
    storage,
  )

  useEffect(() => {
    const decide = async () => {
      try {
        // If flag not set, show onboarding; else jump to Home
        setInitialRoute(onboardingComplete === "true" ? "OolshikHome" : "OolshikOnboard")
      } catch {
        // Fail-safe: if anything goes wrong, keep user functional and go to Home
        setInitialRoute("OolshikHome")
      }
    }
    decide()
  }, [])

  // Avoid rendering the navigator until we know the initial route
  if (!initialRoute) return null

  return (
    <Stack.Navigator
      screenOptions={{ headerShown: false, animation: "slide_from_right" }}
      initialRouteName={initialRoute}
    >
      <Stack.Screen name="OolshikOnboard" component={OnboardingConsentScreen} />
      <Stack.Screen name="OolshikHome" component={HomeFeedScreen} />
      <Stack.Screen name="OolshikCreate" component={CreateTaskScreen} />
      <Stack.Screen name="OolshikDetail" component={TaskDetailScreen} />
      <Stack.Screen name="OolshikMy" component={MyTasksScreen} />
      <Stack.Screen name="OolshikChat" component={ChatScreen} />
      <Stack.Screen name="OolshikProfile" component={ProfileScreen} />
      <Stack.Screen name="OolshikReport" component={ReportScreen} />
    </Stack.Navigator>
  )
}
===== END FILE: app/navigators/OolshikNavigator.tsx =====


===== BEGIN FILE: app/navigators/AppNavigator.tsx =====
/**
 * The app navigator (formerly "AppNavigator" and "MainNavigator") is used for the primary
 * navigation flows of your app.
 * Generally speaking, it will contain an auth flow (registration, login, forgot password)
 * and a "main" flow which the user will use once logged in.
 */
import { ComponentProps } from "react"
import {
  NavigationContainer,
  NavigatorScreenParams, // @demo remove-current-line
} from "@react-navigation/native"
import { createNativeStackNavigator, NativeStackScreenProps } from "@react-navigation/native-stack"

import Config from "@/config"
import { useAuth } from "@/context/AuthContext" // @demo remove-current-line
import { ErrorBoundary } from "@/screens/ErrorScreen/ErrorBoundary"
import { LoginScreen } from "@/screens/LoginScreen" // @demo remove-current-line
import { WelcomeScreen } from "@/screens/WelcomeScreen"
import { useAppTheme } from "@/theme/context"

import { DemoNavigator, DemoTabParamList } from "./DemoNavigator" // @demo remove-current-line
import { navigationRef, useBackButtonHandler } from "./navigationUtilities"
import { OolshikNavigator } from "@/navigators/OolshikNavigator"
/**
 * This type allows TypeScript to know what routes are defined in this navigator
 * as well as what properties (if any) they might take when navigating to them.
 *
 * For more information, see this documentation:
 *   https://reactnavigation.org/docs/params/
 *   https://reactnavigation.org/docs/typescript#type-checking-the-navigator
 *   https://reactnavigation.org/docs/typescript/#organizing-types
 */
export type AppStackParamList = {
  Welcome: undefined
  Login: undefined // @demo remove-current-line
  Demo: NavigatorScreenParams<DemoTabParamList> // @demo remove-current-line
  // 🔥 Your screens go here
  // IGNITE_GENERATOR_ANCHOR_APP_STACK_PARAM_LIST
  Oolshik: undefined
}

/**
 * This is a list of all the route names that will exit the app if the back button
 * is pressed while in that screen. Only affects Android.
 */
const exitRoutes = Config.exitRoutes

export type AppStackScreenProps<T extends keyof AppStackParamList> = NativeStackScreenProps<
  AppStackParamList,
  T
>

// Documentation: https://reactnavigation.org/docs/stack-navigator/
const Stack = createNativeStackNavigator<AppStackParamList>()

const AppStack = () => {
  // @demo remove-block-start
  const { isAuthenticated } = useAuth()
  // @demo remove-block-end
  const {
    theme: { colors },
  } = useAppTheme()

  return (
    <Stack.Navigator
      screenOptions={{
        headerShown: false,
        navigationBarColor: colors.background,
        contentStyle: {
          backgroundColor: colors.background,
        },
      }}
      initialRouteName={isAuthenticated ? "Oolshik" : "Login"} // @demo remove-current-line
    >
      {/* @demo remove-block-start */}
      {isAuthenticated ? (
        <>
          <Stack.Screen
            name="Oolshik"
            component={OolshikNavigator}
            options={{ headerShown: false }}
          />
          {/* @demo remove-block-end */}
          <Stack.Screen name="Welcome" component={WelcomeScreen} />
          {/* @demo remove-block-start */}
          {/* <Stack.Screen name="Demo" component={DemoNavigator} /> */}
        </>
      ) : (
        <>
          <Stack.Screen name="Login" component={LoginScreen} />
        </>
      )}
      {/* @demo remove-block-end */}
      {/** 🔥 Your screens go here */}
      {/* IGNITE_GENERATOR_ANCHOR_APP_STACK_SCREENS */}
    </Stack.Navigator>
  )
}

export interface NavigationProps
  extends Partial<ComponentProps<typeof NavigationContainer<AppStackParamList>>> {}

export const AppNavigator = (props: NavigationProps) => {
  const { navigationTheme } = useAppTheme()

  useBackButtonHandler((routeName) => exitRoutes.includes(routeName))

  return (
    <NavigationContainer ref={navigationRef} theme={navigationTheme} {...props}>
      <ErrorBoundary catchErrors={Config.catchErrors}>
        <AppStack />
      </ErrorBoundary>
    </NavigationContainer>
  )
}
===== END FILE: app/navigators/AppNavigator.tsx =====


===== BEGIN FILE: app/navigators/DemoNavigator.tsx =====
import { TextStyle, ViewStyle } from "react-native"
import { BottomTabScreenProps, createBottomTabNavigator } from "@react-navigation/bottom-tabs"
import { CompositeScreenProps } from "@react-navigation/native"
import { useSafeAreaInsets } from "react-native-safe-area-context"

import { Icon } from "@/components/Icon"
import { EpisodeProvider } from "@/context/EpisodeContext"
import { translate } from "@/i18n/translate"
import { DemoCommunityScreen } from "@/screens/DemoCommunityScreen"
import { DemoDebugScreen } from "@/screens/DemoDebugScreen"
import { DemoPodcastListScreen } from "@/screens/DemoPodcastListScreen"
import { DemoShowroomScreen } from "@/screens/DemoShowroomScreen/DemoShowroomScreen"
import type { ThemedStyle } from "@/theme/types"
import { useAppTheme } from "@/theme/context"

import { AppStackParamList, AppStackScreenProps } from "./AppNavigator"

export type DemoTabParamList = {
  DemoCommunity: undefined
  DemoShowroom: { queryIndex?: string; itemIndex?: string }
  DemoDebug: undefined
  DemoPodcastList: undefined
}

/**
 * Helper for automatically generating navigation prop types for each route.
 *
 * More info: https://reactnavigation.org/docs/typescript/#organizing-types
 */
export type DemoTabScreenProps<T extends keyof DemoTabParamList> = CompositeScreenProps<
  BottomTabScreenProps<DemoTabParamList, T>,
  AppStackScreenProps<keyof AppStackParamList>
>

const Tab = createBottomTabNavigator<DemoTabParamList>()

/**
 * This is the main navigator for the demo screens with a bottom tab bar.
 * Each tab is a stack navigator with its own set of screens.
 *
 * More info: https://reactnavigation.org/docs/bottom-tab-navigator/
 * @returns {JSX.Element} The rendered `DemoNavigator`.
 */
export function DemoNavigator() {
  const { bottom } = useSafeAreaInsets()
  const {
    themed,
    theme: { colors },
  } = useAppTheme()

  return (
    <EpisodeProvider>
      <Tab.Navigator
        screenOptions={{
          headerShown: false,
          tabBarHideOnKeyboard: true,
          tabBarStyle: themed([$tabBar, { height: bottom + 70 }]),
          tabBarActiveTintColor: colors.text,
          tabBarInactiveTintColor: colors.text,
          tabBarLabelStyle: themed($tabBarLabel),
          tabBarItemStyle: themed($tabBarItem),
        }}
      >
        <Tab.Screen
          name="DemoShowroom"
          component={DemoShowroomScreen}
          options={{
            tabBarLabel: translate("demoNavigator:componentsTab"),
            tabBarIcon: ({ focused }) => (
              <Icon
                icon="components"
                color={focused ? colors.tint : colors.tintInactive}
                size={30}
              />
            ),
          }}
        />

        <Tab.Screen
          name="DemoCommunity"
          component={DemoCommunityScreen}
          options={{
            tabBarLabel: translate("demoNavigator:communityTab"),
            tabBarIcon: ({ focused }) => (
              <Icon
                icon="community"
                color={focused ? colors.tint : colors.tintInactive}
                size={30}
              />
            ),
          }}
        />

        <Tab.Screen
          name="DemoPodcastList"
          component={DemoPodcastListScreen}
          options={{
            tabBarAccessibilityLabel: translate("demoNavigator:podcastListTab"),
            tabBarLabel: translate("demoNavigator:podcastListTab"),
            tabBarIcon: ({ focused }) => (
              <Icon icon="podcast" color={focused ? colors.tint : colors.tintInactive} size={30} />
            ),
          }}
        />

        <Tab.Screen
          name="DemoDebug"
          component={DemoDebugScreen}
          options={{
            tabBarLabel: translate("demoNavigator:debugTab"),
            tabBarIcon: ({ focused }) => (
              <Icon icon="debug" color={focused ? colors.tint : colors.tintInactive} size={30} />
            ),
          }}
        />
      </Tab.Navigator>
    </EpisodeProvider>
  )
}

const $tabBar: ThemedStyle<ViewStyle> = ({ colors }) => ({
  backgroundColor: colors.background,
  borderTopColor: colors.transparent,
})

const $tabBarItem: ThemedStyle<ViewStyle> = ({ spacing }) => ({
  paddingTop: spacing.md,
})

const $tabBarLabel: ThemedStyle<TextStyle> = ({ colors, typography }) => ({
  fontSize: 12,
  fontFamily: typography.primary.medium,
  lineHeight: 16,
  color: colors.text,
})

// @demo remove-file
===== END FILE: app/navigators/DemoNavigator.tsx =====


===== BEGIN FILE: app/navigators/navigationUtilities.ts =====
import { useState, useEffect, useRef } from "react"
import { BackHandler, Linking, Platform } from "react-native"
import {
  NavigationState,
  PartialState,
  createNavigationContainerRef,
} from "@react-navigation/native"

import Config from "@/config"
import type { PersistNavigationConfig } from "@/config/config.base"
import * as storage from "@/utils/storage"
import { useIsMounted } from "@/utils/useIsMounted"

import type { AppStackParamList, NavigationProps } from "./AppNavigator"

type Storage = typeof storage

/**
 * Reference to the root App Navigator.
 *
 * If needed, you can use this to access the navigation object outside of a
 * `NavigationContainer` context. However, it's recommended to use the `useNavigation` hook whenever possible.
 * @see [Navigating Without Navigation Prop]{@link https://reactnavigation.org/docs/navigating-without-navigation-prop/}
 *
 * The types on this reference will only let you reference top level navigators. If you have
 * nested navigators, you'll need to use the `useNavigation` with the stack navigator's ParamList type.
 */
export const navigationRef = createNavigationContainerRef<AppStackParamList>()

/**
 * Gets the current screen from any navigation state.
 * @param {NavigationState | PartialState<NavigationState>} state - The navigation state to traverse.
 * @returns {string} - The name of the current screen.
 */
export function getActiveRouteName(state: NavigationState | PartialState<NavigationState>): string {
  const route = state.routes[state.index ?? 0]

  // Found the active route -- return the name
  if (!route.state) return route.name as keyof AppStackParamList

  // Recursive call to deal with nested routers
  return getActiveRouteName(route.state as NavigationState<AppStackParamList>)
}

const iosExit = () => false

/**
 * Hook that handles Android back button presses and forwards those on to
 * the navigation or allows exiting the app.
 * @see [BackHandler]{@link https://reactnative.dev/docs/backhandler}
 * @param {(routeName: string) => boolean} canExit - Function that returns whether we can exit the app.
 * @returns {void}
 */
export function useBackButtonHandler(canExit: (routeName: string) => boolean) {
  // The reason we're using a ref here is because we need to be able
  // to update the canExit function without re-setting up all the listeners
  const canExitRef = useRef(Platform.OS !== "android" ? iosExit : canExit)

  useEffect(() => {
    canExitRef.current = canExit
  }, [canExit])

  useEffect(() => {
    // We'll fire this when the back button is pressed on Android.
    const onBackPress = () => {
      if (!navigationRef.isReady()) {
        return false
      }

      // grab the current route
      const routeName = getActiveRouteName(navigationRef.getRootState())

      // are we allowed to exit?
      if (canExitRef.current(routeName)) {
        // exit and let the system know we've handled the event
        BackHandler.exitApp()
        return true
      }

      // we can't exit, so let's turn this into a back action
      if (navigationRef.canGoBack()) {
        navigationRef.goBack()
        return true
      }

      return false
    }

    // Subscribe when we come to life
    const subscription = BackHandler.addEventListener("hardwareBackPress", onBackPress)

    // Unsubscribe when we're done
    return () => subscription.remove()
  }, [])
}

/**
 * This helper function will determine whether we should enable navigation persistence
 * based on a config setting and the __DEV__ environment (dev or prod).
 * @param {PersistNavigationConfig} persistNavigation - The config setting for navigation persistence.
 * @returns {boolean} - Whether to restore navigation state by default.
 */
function navigationRestoredDefaultState(persistNavigation: PersistNavigationConfig) {
  if (persistNavigation === "always") return false
  if (persistNavigation === "dev" && __DEV__) return false
  if (persistNavigation === "prod" && !__DEV__) return false

  // all other cases, disable restoration by returning true
  return true
}

/**
 * Custom hook for persisting navigation state.
 * @param {Storage} storage - The storage utility to use.
 * @param {string} persistenceKey - The key to use for storing the navigation state.
 * @returns {object} - The navigation state and persistence functions.
 */
export function useNavigationPersistence(storage: Storage, persistenceKey: string) {
  const [initialNavigationState, setInitialNavigationState] =
    useState<NavigationProps["initialState"]>()
  const isMounted = useIsMounted()

  const initNavState = navigationRestoredDefaultState(Config.persistNavigation)
  const [isRestored, setIsRestored] = useState(initNavState)

  const routeNameRef = useRef<keyof AppStackParamList | undefined>(undefined)

  const onNavigationStateChange = (state: NavigationState | undefined) => {
    const previousRouteName = routeNameRef.current
    if (state !== undefined) {
      const currentRouteName = getActiveRouteName(state)

      if (previousRouteName !== currentRouteName) {
        // track screens.
        if (__DEV__) {
          console.log(currentRouteName)
        }
      }

      // Save the current route name for later comparison
      routeNameRef.current = currentRouteName as keyof AppStackParamList

      // Persist state to storage
      storage.save(persistenceKey, state)
    }
  }

  const restoreState = async () => {
    try {
      const initialUrl = await Linking.getInitialURL()

      // Only restore the state if app has not started from a deep link
      if (!initialUrl) {
        const state = (await storage.load(persistenceKey)) as NavigationProps["initialState"] | null
        if (state) setInitialNavigationState(state)
      }
    } finally {
      if (isMounted()) setIsRestored(true)
    }
  }

  useEffect(() => {
    if (!isRestored) restoreState()
    // runs once on mount
    // eslint-disable-next-line react-hooks/exhaustive-deps
  }, [])

  return { onNavigationStateChange, restoreState, isRestored, initialNavigationState }
}

/**
 * use this to navigate without the navigation
 * prop. If you have access to the navigation prop, do not use this.
 * @see {@link https://reactnavigation.org/docs/navigating-without-navigation-prop/}
 * @param {unknown} name - The name of the route to navigate to.
 * @param {unknown} params - The params to pass to the route.
 */
export function navigate(name: unknown, params?: unknown) {
  if (navigationRef.isReady()) {
    // @ts-expect-error
    navigationRef.navigate(name as never, params as never)
  }
}

/**
 * This function is used to go back in a navigation stack, if it's possible to go back.
 * If the navigation stack can't go back, nothing happens.
 * The navigationRef variable is a React ref that references a navigation object.
 * The navigationRef variable is set in the App component.
 */
export function goBack() {
  if (navigationRef.isReady() && navigationRef.canGoBack()) {
    navigationRef.goBack()
  }
}

/**
 * resetRoot will reset the root navigation state to the given params.
 * @param {Parameters<typeof navigationRef.resetRoot>[0]} state - The state to reset the root to.
 * @returns {void}
 */
export function resetRoot(
  state: Parameters<typeof navigationRef.resetRoot>[0] = { index: 0, routes: [] },
) {
  if (navigationRef.isReady()) {
    navigationRef.resetRoot(state)
  }
}
===== END FILE: app/navigators/navigationUtilities.ts =====


===== BEGIN FILE: app/utils/gestureHandler.native.ts =====
// Only import react-native-gesture-handler on native platforms
// https://reactnavigation.org/docs/drawer-navigator/#installation
import "react-native-gesture-handler"
===== END FILE: app/utils/gestureHandler.native.ts =====


===== BEGIN FILE: app/utils/useSafeAreaInsetsStyle.ts =====
import { Edge, useSafeAreaInsets } from "react-native-safe-area-context"

export type ExtendedEdge = Edge | "start" | "end"

const propertySuffixMap = {
  top: "Top",
  bottom: "Bottom",
  left: "Start",
  right: "End",
  start: "Start",
  end: "End",
}

const edgeInsetMap: Record<string, Edge> = {
  start: "left",
  end: "right",
}

export type SafeAreaInsetsStyle<
  Property extends "padding" | "margin" = "padding",
  Edges extends Array<ExtendedEdge> = Array<ExtendedEdge>,
> = {
  [K in Edges[number] as `${Property}${Capitalize<K>}`]: number
}

/**
 * A hook that can be used to create a safe-area-aware style object that can be passed directly to a View.
 * @see [Documentation and Examples]{@link https://docs.infinite.red/ignite-cli/boilerplate/app/utils/useSafeAreaInsetsStyle.ts/}
 * @param {ExtendedEdge[]} safeAreaEdges - The edges to apply the safe area insets to.
 * @param {"padding" | "margin"} property - The property to apply the safe area insets to.
 * @returns {SafeAreaInsetsStyle<Property, Edges>} - The style object with the safe area insets applied.
 */
export function useSafeAreaInsetsStyle<
  Property extends "padding" | "margin" = "padding",
  Edges extends Array<ExtendedEdge> = [],
>(
  safeAreaEdges: Edges = [] as unknown as Edges,
  property: Property = "padding" as Property,
): SafeAreaInsetsStyle<Property, Edges> {
  const insets = useSafeAreaInsets()

  return safeAreaEdges.reduce((acc, e) => {
    const value = edgeInsetMap[e] ?? e
    return { ...acc, [`${property}${propertySuffixMap[e]}`]: insets[value] }
  }, {}) as SafeAreaInsetsStyle<Property, Edges>
}
===== END FILE: app/utils/useSafeAreaInsetsStyle.ts =====


===== BEGIN FILE: app/utils/delay.ts =====
/**
 * A "modern" sleep statement.
 *
 * @param ms The number of milliseconds to wait.
 */
export const delay = (ms: number) => new Promise((resolve) => setTimeout(resolve, ms))
===== END FILE: app/utils/delay.ts =====


===== BEGIN FILE: app/utils/openLinkInBrowser.ts =====
import { Linking } from "react-native"

/**
 * Helper for opening a give URL in an external browser.
 */
export function openLinkInBrowser(url: string) {
  Linking.canOpenURL(url).then((canOpen) => canOpen && Linking.openURL(url))
}
===== END FILE: app/utils/openLinkInBrowser.ts =====


===== BEGIN FILE: app/utils/hasValidStringProp.ts =====
// Type-safe utility to check if an unknown object has a valid string property.
// This is particularly useful in React 19 where props are typed as unknown by default.
// The function safely narrows down the type by checking both property existence and type.
export function hasValidStringProp(props: unknown, propName: string): boolean {
  return (
    props !== null &&
    typeof props === "object" &&
    propName in props &&
    typeof (props as Record<string, unknown>)[propName] === "string"
  )
}
===== END FILE: app/utils/hasValidStringProp.ts =====


===== BEGIN FILE: app/utils/useIsMounted.ts =====
import { useEffect, useCallback, useRef } from "react"
/**
 * A common react custom hook to check if the component is mounted.
 * @returns {() => boolean} - A function that returns true if the component is mounted.
 */
export function useIsMounted() {
  const isMounted = useRef(false)

  useEffect(() => {
    isMounted.current = true

    return () => {
      isMounted.current = false
    }
  }, [])

  return useCallback(() => isMounted.current, [])
}
===== END FILE: app/utils/useIsMounted.ts =====


===== BEGIN FILE: app/utils/formatDate.ts =====
// Note the syntax of these imports from the date-fns library.
// If you import with the syntax: import { format } from "date-fns" the ENTIRE library
// will be included in your production bundle (even if you only use one function).
// This is because react-native does not support tree-shaking.
import { format } from "date-fns/format"
import type { Locale } from "date-fns/locale"
import { parseISO } from "date-fns/parseISO"
import i18n from "i18next"

type Options = Parameters<typeof format>[2]

let dateFnsLocale: Locale
export const loadDateFnsLocale = () => {
  const primaryTag = i18n.language.split("-")[0]
  switch (primaryTag) {
    case "en":
      dateFnsLocale = require("date-fns/locale/en-US").default
      break
    case "ar":
      dateFnsLocale = require("date-fns/locale/ar").default
      break
    case "ko":
      dateFnsLocale = require("date-fns/locale/ko").default
      break
    case "es":
      dateFnsLocale = require("date-fns/locale/es").default
      break
    case "fr":
      dateFnsLocale = require("date-fns/locale/fr").default
      break
    case "hi":
      dateFnsLocale = require("date-fns/locale/hi").default
      break
    case "ja":
      dateFnsLocale = require("date-fns/locale/ja").default
      break
    default:
      dateFnsLocale = require("date-fns/locale/en-US").default
      break
  }
}

export const formatDate = (date: string, dateFormat?: string, options?: Options) => {
  const dateOptions = {
    ...options,
    locale: dateFnsLocale,
  }
  return format(parseISO(date), dateFormat ?? "MMM dd, yyyy", dateOptions)
}
===== END FILE: app/utils/formatDate.ts =====


===== BEGIN FILE: app/utils/useHeader.tsx =====
import { useEffect, useLayoutEffect } from "react"
import { Platform } from "react-native"
import { useNavigation } from "@react-navigation/native"

import { Header, HeaderProps } from "@/components/Header"

/**
 * A hook that can be used to easily set the Header of a react-navigation screen from within the screen's component.
 * @see [Documentation and Examples]{@link https://docs.infinite.red/ignite-cli/boilerplate/app/utils/useHeader.tsx/}
 * @param {HeaderProps} headerProps - The props for the `Header` component.
 * @param {any[]} deps - The dependencies to watch for changes to update the header.
 */
export function useHeader(
  headerProps: HeaderProps,
  deps: Parameters<typeof useLayoutEffect>[1] = [],
) {
  const navigation = useNavigation()

  /**
   * We need to have multiple implementations of this hook for web and mobile.
   * Web needs to use useEffect to avoid a rendering loop.
   * In mobile and also to avoid a visible header jump when navigating between screens, we use
   * `useLayoutEffect`, which will apply the settings before the screen renders.
   */
  const usePlatformEffect = Platform.OS === "web" ? useEffect : useLayoutEffect

  // To avoid a visible header jump when navigating between screens, we use
  // `useLayoutEffect`, which will apply the settings before the screen renders.
  usePlatformEffect(() => {
    navigation.setOptions({
      headerShown: true,
      header: () => <Header {...headerProps} />,
    })
    // intentionally created API to have user set when they want to update the header via `deps`
    // eslint-disable-next-line react-hooks/exhaustive-deps
  }, [...deps, navigation])
}
===== END FILE: app/utils/useHeader.tsx =====


===== BEGIN FILE: app/utils/haversine.ts =====
export function kmDistance(a: { lat: number; lon: number }, b: { lat: number; lon: number }) {
  const R = 6371
  const dLat = ((b.lat - a.lat) * Math.PI) / 180
  const dLon = ((b.lon - a.lon) * Math.PI) / 180
  const lat1 = (a.lat * Math.PI) / 180
  const lat2 = (b.lat * Math.PI) / 180
  const sinDLat = Math.sin(dLat / 2)
  const sinDLon = Math.sin(dLon / 2)
  const h = sinDLat * sinDLat + Math.cos(lat1) * Math.cos(lat2) * sinDLon * sinDLon
  const c = 2 * Math.atan2(Math.sqrt(h), Math.sqrt(1 - h))
  return R * c
}
===== END FILE: app/utils/haversine.ts =====


===== BEGIN FILE: app/utils/gestureHandler.ts =====
// Don't import react-native-gesture-handler on web
// https://reactnavigation.org/docs/drawer-navigator/#installation

// This however is needed at the moment
// https://github.com/software-mansion/react-native-gesture-handler/issues/2402
import "setimmediate"
===== END FILE: app/utils/gestureHandler.ts =====


===== BEGIN FILE: app/utils/crashReporting.ts =====
/**
 * If you're using Sentry
 *   Expo https://docs.expo.dev/guides/using-sentry/
 */
// import * as Sentry from "@sentry/react-native"

/**
 * If you're using Crashlytics: https://rnfirebase.io/crashlytics/usage
 */
// import crashlytics from "@react-native-firebase/crashlytics"

/**
 * If you're using Bugsnag:
 *   RN   https://docs.bugsnag.com/platforms/react-native/)
 *   Expo https://docs.bugsnag.com/platforms/react-native/expo/
 */
// import Bugsnag from "@bugsnag/react-native"
// import Bugsnag from "@bugsnag/expo"

/**
 *  This is where you put your crash reporting service initialization code to call in `./app/app.tsx`
 */
export const initCrashReporting = () => {
  // Sentry.init({
  //   dsn: "YOUR DSN HERE",
  //   debug: true, // If `true`, Sentry will try to print out useful debugging information if something goes wrong with sending the event. Set it to `false` in production
  // })
  // Bugsnag.start("YOUR API KEY")
}

/**
 * Error classifications used to sort errors on error reporting services.
 */
export enum ErrorType {
  /**
   * An error that would normally cause a red screen in dev
   * and force the user to sign out and restart.
   */
  FATAL = "Fatal",
  /**
   * An error caught by try/catch where defined using Reactotron.tron.error.
   */
  HANDLED = "Handled",
}

/**
 * Manually report a handled error.
 */
export const reportCrash = (error: Error, type: ErrorType = ErrorType.FATAL) => {
  if (__DEV__) {
    // Log to console and Reactotron in development
    const message = error.message || "Unknown"
    console.error(error)
    console.log(message, type)
  } else {
    // In production, utilize crash reporting service of choice below:
    // RN
    // Sentry.captureException(error)
    // crashlytics().recordError(error)
    // Bugsnag.notify(error)
  }
}
===== END FILE: app/utils/crashReporting.ts =====


===== BEGIN FILE: app/utils/storage/storage.test.ts =====
import { load, loadString, save, saveString, clear, remove, storage } from "."

const VALUE_OBJECT = { x: 1 }
const VALUE_STRING = JSON.stringify(VALUE_OBJECT)

describe("MMKV Storage", () => {
  beforeEach(() => {
    storage.clearAll()
    storage.set("string", "string")
    storage.set("object", JSON.stringify(VALUE_OBJECT))
  })

  it("should be defined", () => {
    expect(storage).toBeDefined()
  })

  it("should have default keys", () => {
    expect(storage.getAllKeys()).toEqual(["string", "object"])
  })

  it("should load data", () => {
    expect(load<object>("object")).toEqual(VALUE_OBJECT)
    expect(loadString("object")).toEqual(VALUE_STRING)

    expect(load<string>("string")).toEqual("string")
    expect(loadString("string")).toEqual("string")
  })

  it("should save strings", () => {
    saveString("string", "new string")
    expect(loadString("string")).toEqual("new string")
  })

  it("should save objects", () => {
    save("object", { y: 2 })
    expect(load<object>("object")).toEqual({ y: 2 })
    save("object", { z: 3, also: true })
    expect(load<object>("object")).toEqual({ z: 3, also: true })
  })

  it("should save strings and objects", () => {
    saveString("object", "new string")
    expect(loadString("object")).toEqual("new string")
  })

  it("should remove data", () => {
    remove("object")
    expect(load<object>("object")).toBeNull()
    expect(storage.getAllKeys()).toEqual(["string"])

    remove("string")
    expect(load<string>("string")).toBeNull()
    expect(storage.getAllKeys()).toEqual([])
  })

  it("should clear all data", () => {
    expect(storage.getAllKeys()).toEqual(["string", "object"])
    clear()
    expect(storage.getAllKeys()).toEqual([])
  })
})
===== END FILE: app/utils/storage/storage.test.ts =====


===== BEGIN FILE: app/utils/storage/index.ts =====
import { MMKV } from "react-native-mmkv"

export const storage = new MMKV()

/**
 * Loads a string from storage.
 *
 * @param key The key to fetch.
 */
export function loadString(key: string): string | null {
  try {
    return storage.getString(key) ?? null
  } catch {
    // not sure why this would fail... even reading the RN docs I'm unclear
    return null
  }
}

/**
 * Saves a string to storage.
 *
 * @param key The key to fetch.
 * @param value The value to store.
 */
export function saveString(key: string, value: string): boolean {
  try {
    storage.set(key, value)
    return true
  } catch {
    return false
  }
}

/**
 * Loads something from storage and runs it thru JSON.parse.
 *
 * @param key The key to fetch.
 */
export function load<T>(key: string): T | null {
  let almostThere: string | null = null
  try {
    almostThere = loadString(key)
    return JSON.parse(almostThere ?? "") as T
  } catch {
    return (almostThere as T) ?? null
  }
}

/**
 * Saves an object to storage.
 *
 * @param key The key to fetch.
 * @param value The value to store.
 */
export function save(key: string, value: unknown): boolean {
  try {
    saveString(key, JSON.stringify(value))
    return true
  } catch {
    return false
  }
}

/**
 * Removes something from storage.
 *
 * @param key The key to kill.
 */
export function remove(key: string): void {
  try {
    storage.delete(key)
  } catch {}
}

/**
 * Burn it all to the ground.
 */
export function clear(): void {
  try {
    storage.clearAll()
  } catch {}
}
===== END FILE: app/utils/storage/index.ts =====


===== BEGIN FILE: app/screens/MyTasksScreen.tsx =====
import React from "react"
import { View } from "react-native"
import { Screen } from "@/components/Screen"
import { Text } from "@/components/Text"

export default function MyTasksScreen() {
  return (
    <Screen preset="fixed" safeAreaEdges={["top","bottom"]} contentContainerStyle={{ padding: 16 }}>
      <Text preset="heading" text="My Tasks" />
      <View style={{ height: 12 }} />
    </Screen>
  )
}
===== END FILE: app/screens/MyTasksScreen.tsx =====


===== BEGIN FILE: app/screens/TaskDetailScreen.tsx =====
import React, { useState, useCallback } from "react"
import { View, ActivityIndicator, Pressable, Linking, Alert } from "react-native"
import { useRoute } from "@react-navigation/native"
import { Screen } from "@/components/Screen"
import { Text } from "@/components/Text"
import { Button } from "@/components/Button"
import { useAppTheme } from "@/theme/context"
import { useTaskStore } from "@/store/taskStore"
import { OolshikApi } from "@/api"
import { Audio } from "expo-av"
import { FLAGS } from "@/config/flags"
import { useForegroundLocation } from "@/hooks/useForegroundLocation"
import { SmileySlider } from "@/components/SmileySlider"
import { RatingBadge } from "@/components/RatingBadge"
import { Task } from "@/api/client"

type RouteParams = { id: string }

function getInitials(name?: string) {
  if (!name) return "👤"
  const parts = name.trim().split(/\s+/)
  return ((parts[0]?.[0] ?? "") + (parts[1]?.[0] ?? "")).toUpperCase()
}

function minsAgo(iso?: string) {
  if (!iso) return ""
  const date = new Date(iso)
  const diffMs = Date.now() - date.getTime()
  const mins = Math.max(0, Math.round(diffMs / 60000))

  if (mins < 1) return "just now"
  if (mins === 1) return "1 min ago"
  if (mins < 60) return `${mins} mins ago`
  const hrs = Math.round(mins / 60)
  if (hrs === 1) return "1 hr ago"
  if (hrs < 24) return `${hrs} hrs ago`

  // For older than a day, show readable date
  return date.toLocaleString(undefined, {
    day: "2-digit",
    month: "short",
    year: "numeric",
    hour: "2-digit",
    minute: "2-digit",
  })
}

function maskPhoneNumber(input?: string) {
  if (!input) return ""
  // keep non-digits as-is, mask all digits except the last 4
  const digits = input.replace(/\D/g, "")
  if (digits.length <= 4) return input
  const last4 = digits.slice(-4)
  let maskedDigitsIdx = 0
  const numDigitsToMask = Math.max(0, digits.length - 4)
  return input
    .split("")
    .map((ch) => {
      if (/\d/.test(ch)) {
        if (maskedDigitsIdx < numDigitsToMask) {
          maskedDigitsIdx += 1
          return "•"
        }
        // past masked portion -> reveal last 4
        return last4[maskedDigitsIdx++ - numDigitsToMask] || ch
      }
      return ch
    })
    .join("")
}

export default function TaskDetailScreen({ navigation }: any) {
  const { params } = useRoute<any>() as { params: RouteParams }
  const taskId = params?.id

  const { theme } = useAppTheme()
  const { spacing, colors } = theme

  const { tasks, accept } = useTaskStore()
  const taskFromStore = tasks.find((t) => String(t.id) === String(taskId))

  const [loading, setLoading] = React.useState(!taskFromStore)
  const [task, setTask] = React.useState(taskFromStore || null)

  const [sound, setSound] = React.useState<Audio.Sound | null>(null)
  const [playing, setPlaying] = React.useState(false)
  const { coords } = useForegroundLocation()
  const { radiusMeters } = useTaskStore()
  const [justCompleted, setJustCompleted] = React.useState(false)

  const [fullPhone, setFullPhone] = React.useState<string | null>(null)
  const [isRevealed, setIsRevealed] = React.useState(false)
  const [revealLoading, setRevealLoading] = React.useState(false)

  const primary = colors.palette.primary500
  const primarySoft = colors.palette.primary200
  const success = "#16A34A"
  const successSoft = "#BBF7D0"
  const warning = "#D97706"
  const warningSoft = "#FDE68A"
  const neutral600 = colors.palette.neutral600
  const neutral700 = colors.palette.neutral700

  const statusMap = {
    PENDING: { label: "Pending", bg: primarySoft, fg: primary },
    ASSIGNED: { label: "Assigned", bg: warningSoft, fg: warning },
    COMPLETED: { label: "Completed", bg: successSoft, fg: success },
  } as const

  const current = task || taskFromStore || null

  const [rating, setRating] = useState<number>(2.5) // center default (neutral)
  const [submitting, setSubmitting] = useState(false)

  React.useEffect(() => {
    if (current?.createdByPhoneNumber) {
      setFullPhone(String(current.createdByPhoneNumber))
      setIsRevealed(false) // always start masked on open
    }
  }, [current?.createdByPhoneNumber])

  // Normalize backend statuses (e.g., OPEN/CANCELLED) to UI statuses used in statusMap
  let normalizedStatus: "PENDING" | "ASSIGNED" | "COMPLETED" = "PENDING"
  const rawStatus = (current?.status as string | undefined) || undefined
  switch (rawStatus) {
    case "OPEN":
      normalizedStatus = "PENDING"
      break
    case "CANCELLED":
    case "CANCELED":
      normalizedStatus = "COMPLETED"
      break
    case "PENDING":
    case "ASSIGNED":
    case "COMPLETED":
      normalizedStatus = rawStatus as any
      break
    default:
      normalizedStatus = "PENDING"
  }

  // ensure we have the task (e.g., deep link / app resume)
  React.useEffect(() => {
    let cancelled = false
    const load = async () => {
      if (taskFromStore) return
      setLoading(true)
      try {
        const res = await OolshikApi.findTaskByTaskId(taskId)
        const fetchedTask = res?.ok ? (res.data as Task | null) : null
        if (!cancelled) setTask(fetchedTask)
      } finally {
        if (!cancelled) setLoading(false)
      }
    }
    load()
    return () => {
      cancelled = true
    }
    // eslint-disable-next-line react-hooks/exhaustive-deps
  }, [taskId])

  const S = statusMap[normalizedStatus] ?? statusMap.PENDING

  const onRevealPhone = async () => {
    if (!current) return
    try {
      setRevealLoading(true)
      setIsRevealed(true)

      // Calls backend to log & return full number
      const res = await OolshikApi.revealPhone(current.id as any)
      if (res?.ok) {
        const num = res.data?.phoneNumber ?? fullPhone
        if (num) setFullPhone(String(num))
        setIsRevealed(true)
      } else {
        const msg = res?.data?.message || "Unable to show number"
        alert(msg)
      }
    } finally {
      setRevealLoading(false)
    }
  }

  const onCall = () => {
    const num = (fullPhone || "").replace(/[^+\d]/g, "")
    if (num) Linking.openURL(`tel:${num}`)
  }

  const play = async () => {
    if (!current?.voiceUrl) return
    const { sound } = await Audio.Sound.createAsync({ uri: String(current.voiceUrl) })
    setSound(sound)
    setPlaying(true)
    await sound.playAsync()
    sound.setOnPlaybackStatusUpdate((st: any) => {
      if (!st.isPlaying) {
        setPlaying(false)
        sound.unloadAsync()
        setSound(null)
      }
    })
  }

  const onAccept = async () => {
    if (!current) return
    const result = await accept(current.id)
    if (result === "ALREADY") {
      alert("Already assigned")
    } else if (result === "OK") {
      alert("Task accepted")
    } else {
      alert("Error accepting task")
    }
    // reflect status locally
    setTask((t: any) => (t ? { ...t, status: "ASSIGNED" } : t))
  }

  const onComplete = async () => {
    if (!current) return
    const res = await OolshikApi.completeTask(current.id as any)
    if (res?.ok) {
      setTask((t: any) => (t ? { ...t, status: "COMPLETED" } : t))
      setJustCompleted(true)
      // Briefly show a success banner, then return to previous screen
      setTimeout(() => {
        try {
          navigation.goBack()
        } catch {
          // ignore
        }
      }, 1200)
    } else if (
      res?.status === 403 ||
      res?.status === 409 ||
      String(res?.data || "").includes("Only requester can complete")
    ) {
      alert("Only the requester can complete this task")
    } else {
      alert("Error completing task")
    }
  }

  const showRatings = normalizedStatus === "COMPLETED" ? true : false
  return (
    <Screen preset="scroll" safeAreaEdges={["top", "bottom"]}>
      {/* Header (fixed) */}
      <View style={{ padding: 16, flexDirection: "row", alignItems: "center" }}>
        <Text preset="heading" text="Task Detail" />
        {/* REPORT *** lightweight header action */}
        <View style={{ marginLeft: "auto" }}>
          <Button
            text="Report"
            onPress={() => {
              navigation.navigate("OolshikReport", { taskId: current?.id })
            }}
          />
        </View>
      </View>

      {/* Content */}
      <View style={{ flex: 1, paddingHorizontal: 16, paddingBottom: 32 }}>
        {loading || !current ? (
          <View style={{ flex: 1, alignItems: "center", justifyContent: "center" }}>
            {loading ? <ActivityIndicator /> : <Text text="Task not found" />}
          </View>
        ) : (
          <View style={{ gap: spacing.md }}>
            {/* Poster row */}
            <View style={{ flexDirection: "row", alignItems: "center", gap: spacing.sm }}>
              <View
                style={{
                  width: 36,
                  height: 36,
                  borderRadius: 18,
                  backgroundColor: "#E5E7EB",
                  alignItems: "center",
                  justifyContent: "center",
                }}
              >
                <Text text={getInitials(current.createdByName)} weight="bold" />
              </View>
              <View style={{ flex: 1 }}>
                <Text text={current.createdByName || "Someone nearby"} weight="medium" />
                <Text text={minsAgo(current.createdAt)} size="xs" style={{ color: neutral600 }} />
              </View>

              {/* Small play control on the right */}
              {!!current.voiceUrl && (
                <Pressable
                  onPress={play}
                  accessibilityRole="button"
                  accessibilityLabel={playing ? "Playing" : "Play voice"}
                  style={{
                    width: 44,
                    height: 44,
                    borderRadius: 22,
                    backgroundColor: primary,
                    alignItems: "center",
                    justifyContent: "center",
                  }}
                >
                  <Text
                    text={playing ? "…" : "▶︎"}
                    style={{ color: "white", fontWeight: "bold" }}
                  />
                </Pressable>
              )}
            </View>

            {/* Title / description */}
            <View style={{ gap: spacing.xs }}>
              <Text
                text={current.description || "Voice task"}
                weight="bold"
                style={{ color: neutral700 }}
              />
            </View>

            {/* Contact (masked -> reveal) */}
            {!!fullPhone && (
              <View
                style={{
                  gap: spacing.xs,
                  padding: spacing.sm,
                  borderRadius: 12,
                  borderWidth: 1,
                  borderColor: colors.palette.neutral300,
                  backgroundColor: colors.palette.neutral100,
                }}
              >
                <Text text="Contact" weight="medium" style={{ color: neutral700 }} />
                <View style={{ flexDirection: "row", alignItems: "center", gap: spacing.sm }}>
                  <Text
                    text={isRevealed ? String(fullPhone) : maskPhoneNumber(fullPhone || "")}
                    weight="bold"
                    style={{ flex: 1, color: neutral700 }}
                  />
                  {isRevealed ? (
                    <Button text="Call" onPress={onCall} style={{ paddingVertical: spacing.xs }} />
                  ) : (
                    <Button
                      text={revealLoading ? "…" : "Show"}
                      onPress={onRevealPhone}
                      style={{ paddingVertical: spacing.xs }}
                    />
                  )}
                </View>
              </View>
            )}

            {/* Distance + Status pill in one row */}
            <View
              style={{
                flexDirection: "row",
                justifyContent: "space-between",
              }}
            >
              {typeof current.distanceMtr === "number" ? (
                <Text
                  text={`${current.distanceMtr.toFixed(1)} km away`}
                  size="xs"
                  style={{ color: neutral700 }}
                />
              ) : (
                <View />
              )}

              <View
                style={{
                  paddingHorizontal: spacing.sm,
                  paddingVertical: spacing.xxs,
                  borderRadius: 999,
                  backgroundColor: S.bg,
                }}
              >
                <Text text={S.label} size="xs" weight="medium" style={{ color: S.fg }} />
              </View>
              {showRatings && <RatingBadge value={current.ratingValue} />}
            </View>
          </View>
        )}
      </View>
      <View style={{ height: 12 }} />

      {/* Bottom actions / success banner */}
      {current && (
        <>
          {normalizedStatus === "PENDING" || normalizedStatus === "ASSIGNED" ? (
            <View
              style={{
                flexDirection: "row",
                marginHorizontal: 16,
                gap: spacing.sm,
              }}
            >
              {normalizedStatus === "PENDING" ? (
                <Button
                  text="Accept"
                  onPress={onAccept}
                  style={{ flex: 2, paddingVertical: spacing.xs }}
                />
              ) : (
                <View
                  style={{
                    gap: spacing.md,
                    paddingHorizontal: spacing.sm,
                    borderRadius: 12,
                    borderWidth: 1,
                    borderColor: colors.palette.neutral300,
                    backgroundColor: colors.palette.neutral100,
                    flex: 1,
                    paddingBottom: 32,
                  }}
                >
                  <Text tx="oolshik:yourExperience" preset="subheading" />
                  <SmileySlider disabled={false} value={rating} onChange={setRating} />
                  <Text style={{ textAlign: "center", marginTop: 6, opacity: 0.6 }}>
                    {rating.toFixed(1)} / 5.0
                  </Text>

                  <Button
                    text="Mark as Complete"
                    onPress={onComplete}
                    style={{ flex: 2, paddingVertical: spacing.xs }}
                  />
                </View>
              )}
            </View>
          ) : null}
          {normalizedStatus === "COMPLETED" && (
            <View
              style={{
                paddingVertical: spacing.xs,
                paddingHorizontal: spacing.sm,
                marginHorizontal: 16,
                borderRadius: 8,
                backgroundColor: successSoft,
                borderWidth: 1,
                borderColor: success,
              }}
            >
              <Text text="Task completed ✓" weight="bold" style={{ color: success }} />
              <Text style={{ marginBottom: 5 }} text="Thanks for helping!" size="xs" />
              <Button
                text="Ok"
                onPress={() => navigation.goBack()}
                style={{ flex: 2, paddingVertical: spacing.xs }}
              />
            </View>
          )}
        </>
      )}
    </Screen>
  )
}
===== END FILE: app/screens/TaskDetailScreen.tsx =====


===== BEGIN FILE: app/screens/ReportScreen.tsx =====
// app/screens/ReportScreen.tsx
import React from "react"
import { View, Alert, Pressable } from "react-native"
import { Screen } from "@/components/Screen"
import { Text } from "@/components/Text"
import { Button } from "@/components/Button"
import { TextField } from "@/components/TextField"
import { useAppTheme } from "@/theme/context"
import { OolshikApi } from "@/api"
import { useRoute, useNavigation } from "@react-navigation/native"
import { RadioGroup } from "@/components/RadioGroup"

type Params = { taskId?: string; userId?: string }

type Reason = "SPAM" | "INAPPROPRIATE" | "UNSAFE" | "OTHER"

export default function ReportScreen() {
  const nav = useNavigation<any>()
  const { params } = useRoute<any>() as { params: Params }
  const { theme } = useAppTheme()
  const { spacing } = theme

  const [reason, setReason] = React.useState<Reason>("SPAM")
  const [text, setText] = React.useState("")
  const [loading, setLoading] = React.useState(false)

  const MAX_DESC = 500

  const validate = (): { ok: boolean; message?: string } => {
    if (!params?.taskId && !params?.userId) {
      return { ok: false, message: "Missing context. Please report from a task or a profile." }
    }
    if (reason === "OTHER" && !text.trim()) {
      return { ok: false, message: "Please add details when selecting Other." }
    }
    if (text.length > 1000) {
      return { ok: false, message: "Details are too long. Please keep under 1000 characters." }
    }
    return { ok: true }
  }

  const submit = async () => {
    const v = validate()
    if (!v.ok) {
      Alert.alert("Report", v.message)
      return
    }

    setLoading(true)
    try {
      console.log("🚀 ~ submit ~ params:", params)
      const res = await OolshikApi.report({
        taskId: params?.taskId,
        targetUserId: params?.userId,
        reason,
        text: text.trim() || undefined,
      })

      if (res?.ok) {
        Alert.alert("Thanks for reporting", "Our team will review this shortly.")
        nav.goBack()
      } else {
        Alert.alert("Report failed", res?.error ?? "Please try again.")
      }
    } catch (e: any) {
      Alert.alert("Report failed", e?.message ?? "Please try again.")
    } finally {
      setLoading(false)
    }
  }

  const reasons = [
    { label: "Spam / Advertising", value: "SPAM" },
    { label: "Inappropriate Content", value: "INAPPROPRIATE" },
    { label: "Unsafe / Harmful", value: "UNSAFE" },
    { label: "Other", value: "OTHER" },
  ]
  const Pill: React.FC<{
    label: string
    active?: boolean
    onPress?: () => void
    dotColor?: string
  }> = ({ label, active, onPress, dotColor = "#FF6B2C" }) => (
    <Pressable
      onPress={onPress}
      style={{
        flexDirection: "row",
        alignItems: "center",
        gap: 8,
        paddingHorizontal: 14,
        paddingVertical: 8,
        borderRadius: 999,
        backgroundColor: active ? "#111827" : "#F2F4F7",
      }}
    >
      <View
        style={{
          width: 8,
          height: 8,
          borderRadius: 4,
          backgroundColor: active ? "#fff" : dotColor,
          opacity: active ? 1 : 0.8,
        }}
      />
      <Text style={{ color: active ? "#fff" : "#111827", fontWeight: "600" }} text={label} />
    </Pressable>
  )
  return (
    <Screen
      preset="fixed"
      safeAreaEdges={["top", "bottom"]}
      contentContainerStyle={{ padding: 16 }}
    >
      <Text preset="heading" text="Report an issue" />
      <View style={{ height: spacing.md }} />

      <Text text="Reason" weight="medium" />
      <View style={{ height: spacing.xs }} />
      <View style={{ flexDirection: "row", flexWrap: "wrap", gap: 8 }}>
        {reasons.map((r) => (
          <Pill
            key={r.value}
            label={r.label}
            active={reason === r.value}
            onPress={() => setReason(r.value as Reason)}
          />
        ))}
      </View>

      <View style={{ height: spacing.md }} />
      <Text text="Details (optional)" weight="medium" />
      <View style={{ height: spacing.xs }} />
      <TextField
        multiline
        numberOfLines={6}
        value={text}
        onChangeText={(t) => setText(t.slice(0, MAX_DESC))}
        placeholder="Describe what happened…"
        style={{ minHeight: 120 }}
        editable={!loading}
      />
      <Text
        style={{ alignSelf: "flex-end", color: "#6B7280", marginTop: 4 }}
      >{`${text.length}/${MAX_DESC}`}</Text>

      <View style={{ height: spacing.lg }} />
      <Button
        text={loading ? "Submitting…" : "Submit Report"}
        onPress={submit}
        disabled={loading}
        style={{ width: "100%", paddingVertical: spacing.xs }}
      />
    </Screen>
  )
}
===== END FILE: app/screens/ReportScreen.tsx =====


===== BEGIN FILE: app/screens/WelcomeScreen.tsx =====
import { FC } from "react"
import { Image, ImageStyle, TextStyle, View, ViewStyle } from "react-native"

import { Button } from "@/components/Button" // @demo remove-current-line
import { Screen } from "@/components/Screen"
import { Text } from "@/components/Text"
import { useAuth } from "@/context/AuthContext" // @demo remove-current-line
import { isRTL } from "@/i18n"
import type { AppStackScreenProps } from "@/navigators/AppNavigator" // @demo remove-current-line
import type { ThemedStyle } from "@/theme/types"
import { useAppTheme } from "@/theme/context"
import { $styles } from "@/theme/styles"
import { useHeader } from "@/utils/useHeader" // @demo remove-current-line
import { useSafeAreaInsetsStyle } from "@/utils/useSafeAreaInsetsStyle"

const welcomeLogo = require("@assets/images/logo.png")
const welcomeFace = require("@assets/images/welcome-face.png")

interface WelcomeScreenProps extends AppStackScreenProps<"Welcome"> {} // @demo remove-current-line

// @demo replace-next-line export const WelcomeScreen: FC = function WelcomeScreen(
export const WelcomeScreen: FC<WelcomeScreenProps> = function WelcomeScreen(
  _props, // @demo remove-current-line
) {
  const { themed, theme } = useAppTheme()
  // @demo remove-block-start
  const { navigation } = _props
  const { logout } = useAuth()

  function goNext() {
    navigation.navigate("Demo", { screen: "DemoShowroom", params: {} })
  }

  useHeader(
    {
      rightTx: "common:logOut",
      onRightPress: logout,
    },
    [logout],
  )
  // @demo remove-block-end

  const $bottomContainerInsets = useSafeAreaInsetsStyle(["bottom"])

  return (
    <Screen preset="fixed" contentContainerStyle={$styles.flex1}>
      <View style={themed($topContainer)}>
        <Image style={themed($welcomeLogo)} source={welcomeLogo} resizeMode="contain" />
        <Text
          testID="welcome-heading"
          style={themed($welcomeHeading)}
          tx="welcomeScreen:readyForLaunch"
          preset="heading"
        />
        <Text tx="welcomeScreen:exciting" preset="subheading" />
        <Image
          style={$welcomeFace}
          source={welcomeFace}
          resizeMode="contain"
          tintColor={theme.colors.palette.neutral900}
        />
      </View>

      <View style={themed([$bottomContainer, $bottomContainerInsets])}>
        <Text tx="welcomeScreen:postscript" size="md" />
        {/* @demo remove-block-start */}
        <Button
          testID="next-screen-button"
          preset="reversed"
          tx="welcomeScreen:letsGo"
          onPress={goNext}
        />
        {/* @demo remove-block-end */}
      </View>
    </Screen>
  )
}

const $topContainer: ThemedStyle<ViewStyle> = ({ spacing }) => ({
  flexShrink: 1,
  flexGrow: 1,
  flexBasis: "57%",
  justifyContent: "center",
  paddingHorizontal: spacing.lg,
})

const $bottomContainer: ThemedStyle<ViewStyle> = ({ colors, spacing }) => ({
  flexShrink: 1,
  flexGrow: 0,
  flexBasis: "43%",
  backgroundColor: colors.palette.neutral100,
  borderTopLeftRadius: 16,
  borderTopRightRadius: 16,
  paddingHorizontal: spacing.lg,
  justifyContent: "space-around",
})

const $welcomeLogo: ThemedStyle<ImageStyle> = ({ spacing }) => ({
  height: 88,
  width: "100%",
  marginBottom: spacing.xxl,
})

const $welcomeFace: ImageStyle = {
  height: 169,
  width: 269,
  position: "absolute",
  bottom: -47,
  right: -80,
  transform: [{ scaleX: isRTL ? -1 : 1 }],
}

const $welcomeHeading: ThemedStyle<TextStyle> = ({ spacing }) => ({
  marginBottom: spacing.md,
})
===== END FILE: app/screens/WelcomeScreen.tsx =====


===== BEGIN FILE: app/screens/HomeFeedScreen.tsx =====
import React, { useEffect, useMemo, useCallback, useState } from "react"
import { View, ActivityIndicator, FlatList, ListRenderItem, Pressable, Alert } from "react-native"
import { useFocusEffect } from "@react-navigation/native"
import { Screen } from "@/components/Screen"
import { Text } from "@/components/Text"
import { TaskCard } from "@/components/TaskCard"
import { Button } from "@/components/Button"
import { useTaskStore } from "@/store/taskStore"
import { useForegroundLocation } from "@/hooks/useForegroundLocation"
// import { RadioGroup } from "@/components/RadioGroup" // removed – custom pills look cleaner
import { colors } from "@/theme/colors"
import { useAuth } from "@/context/AuthContext"

/**
 * HomeFeedScreen – refreshed UI
 * - Cleaner "segmented" header for For You | My Requests
 * - Card-like filter bar with Distance pills + Status chips
 * - Calmer colors and spacing for industry-standard feel
 * - No new deps; pure RN + existing components
 */

// Distances (km)
type Radius = 1 | 2 | 5

// Backend statuses
type Status = "OPEN" | "ASSIGNED" | "COMPLETED" | "CANCELLED"

const STATUS_ORDER: Status[] = ["OPEN", "ASSIGNED", "COMPLETED", "CANCELLED"]

// Chip colors
const STATUS_COLORS: Record<Status, string> = {
  OPEN: "#0EA5E9",
  ASSIGNED: "#F59E0B",
  COMPLETED: "#10B981",
  CANCELLED: "#EF4444",
}

const STATUS_BG: Record<Status, string> = {
  OPEN: "rgba(14,165,233,0.10)",
  ASSIGNED: "rgba(245,158,11,0.10)",
  COMPLETED: "rgba(16,185,129,0.10)",
  CANCELLED: "rgba(239,68,68,0.12)",
}

const LOGOUT_COLOR = "#FF6B2C"

// NEW: view switch
type ViewMode = "forYou" | "mine"

export default function HomeFeedScreen({ navigation }: any) {
  const { coords } = useForegroundLocation()
  const { tasks, fetchNearby, loading, radiusMeters, setRadius, accept } = useTaskStore()
  const { logout, user } = useAuth() as any

  // Who am I? Try common shapes; keep it simple & resilient
  // const myId: string | undefined = user?.id ?? user?.userId ?? user?.uid ?? user?.sub
  const myId: string | undefined = user?.id

  // Status filter (default = OPEN + ASSIGNED)
  const [selectedStatuses, setSelectedStatuses] = useState<Set<Status>>(
    new Set(["OPEN", "ASSIGNED"]),
  )

  // NEW: tab to switch between "For You" (not mine) and "My Requests"
  const [viewMode, setViewMode] = useState<ViewMode>("forYou")

  const toggleStatus = (s: Status) => {
    setSelectedStatuses((prev) => {
      const next = new Set(prev)
      if (next.has(s)) next.delete(s)
      else next.add(s)
      return next
    })
  }

  useFocusEffect(
    useCallback(() => {
      if (coords) {
        const statusesArg = selectedStatuses.size ? Array.from(selectedStatuses) : undefined
        // If none selected, omit the statuses argument so backend returns all
        fetchNearby(coords.latitude, coords.longitude, statusesArg as any)
      }
    }, [coords?.latitude, coords?.longitude, radiusMeters, selectedStatuses]),
  )

  // Utility: is this task created by me?
  const isMine = useCallback(
    (t: any) => {
      if (!myId) return false
      // const owner = t?.requesterId ?? t?.createdById ?? t?.ownerId
      const owner = t?.requesterId
      return owner ? String(owner) === String(myId) : false
    },
    [myId],
  )

  const data = useMemo(() => {
    const list = Array.isArray(tasks) ? tasks : []
    console.log("🚀 ~ HomeFeedScreen ~ tasks:", tasks)

    // de-dupe by id
    const unique = Array.from(new Map(list.map((t: any) => [t.id, t])).values())

    // If none selected, include all statuses present in the response
    const statusesToUse: Status[] =
      selectedStatuses.size === 0
        ? (Array.from(new Set(unique.map((t: any) => t.status))).filter(Boolean) as Status[])
        : (Array.from(selectedStatuses) as Status[])

    // Filter by status
    let filtered = unique.filter((t: any) => statusesToUse.includes(t.status as Status))

    // Filter by view mode
    filtered = filtered.filter((t: any) => (viewMode === "mine" ? isMine(t) : !isMine(t)))

    // Sort: nearest first, then newest
    return filtered.sort((a: any, b: any) => {
      const d = (a.distanceMtr ?? 0) - (b.distanceMtr ?? 0)
      if (d !== 0) return d
      const at = new Date(a.createdAt ?? 0).getTime()
      const bt = new Date(b.createdAt ?? 0).getTime()
      return bt - at
    })
  }, [tasks, selectedStatuses, viewMode, isMine])

  // ---------- Small UI building blocks ----------

  const SectionCard: React.FC<{ children: React.ReactNode; style?: any }> = ({
    children,
    style,
  }) => (
    <View
      style={[
        {
          backgroundColor: "#fff",
          borderRadius: 16,
          borderWidth: 1,
          borderColor: "#ECECEC",
          padding: 12,
          shadowColor: "#000",
          shadowOpacity: 0.06,
          shadowRadius: 8,
          shadowOffset: { width: 0, height: 2 },
          elevation: 1,
        },
        style,
      ]}
    >
      {children}
    </View>
  )

  const Segmented: React.FC<{
    value: ViewMode
    onChange: (v: ViewMode) => void
  }> = ({ value, onChange }) => {
    const tabs: { key: ViewMode; tx: string; a11y: string }[] = [
      { key: "forYou", tx: "oolshik:tabForYou", a11y: "For you" },
      { key: "mine", tx: "oolshik:tabMyRequests", a11y: "My requests" },
    ]
    return (
      <View
        style={{
          flexDirection: "row",
          backgroundColor: "#F5F6F7",
          borderRadius: 12,
          padding: 4,
          gap: 4,
        }}
      >
        {tabs.map((t) => {
          const active = value === t.key
          return (
            <Pressable
              key={t.key}
              onPress={() => onChange(t.key)}
              accessibilityRole="button"
              accessibilityState={{ selected: active }}
              accessibilityLabel={t.a11y}
              style={{
                flex: 1,
                alignItems: "center",
                justifyContent: "center",
                paddingVertical: 10,
                borderRadius: 10,
                backgroundColor: active ? "#111827" : "transparent",
              }}
            >
              <Text tx={t.tx} style={{ fontWeight: "700", color: active ? "#fff" : "#111827" }} />
            </Pressable>
          )
        })}
      </View>
    )
  }

  const Pill: React.FC<{
    label: string
    active?: boolean
    onPress?: () => void
    dotColor?: string
  }> = ({ label, active, onPress, dotColor = "#FF6B2C" }) => (
    <Pressable
      onPress={onPress}
      style={{
        flexDirection: "row",
        alignItems: "center",
        gap: 8,
        paddingHorizontal: 14,
        paddingVertical: 8,
        borderRadius: 999,
        backgroundColor: active ? "#111827" : "#F2F4F7",
      }}
    >
      <View
        style={{
          width: 8,
          height: 8,
          borderRadius: 4,
          backgroundColor: active ? "#fff" : dotColor,
          opacity: active ? 1 : 0.8,
        }}
      />
      <Text style={{ color: active ? "#fff" : "#111827", fontWeight: "600" }} text={label} />
    </Pressable>
  )

  const StatusChip: React.FC<{ s: Status; active: boolean; onPress: () => void }> = ({
    s,
    active,
    onPress,
  }) => (
    <Pressable
      onPress={onPress}
      accessibilityRole="button"
      accessibilityState={{ selected: active }}
      accessibilityLabel={`Filter ${s}`}
      style={{
        paddingVertical: 8,
        paddingHorizontal: 14,
        borderRadius: 999,
        borderWidth: 1,
        borderColor: STATUS_COLORS[s],
        backgroundColor: active ? STATUS_COLORS[s] : STATUS_BG[s],
      }}
    >
      <Text tx={`status:${s}`} style={{ color: active ? "#fff" : STATUS_COLORS[s] }} />
    </Pressable>
  )

  const renderItem: ListRenderItem<(typeof data)[number]> = ({ item: t }) => (
    <TaskCard
      id={t.id}
      title={t.title}
      kmAway={t.distanceMtr}
      status={t.status}
      voiceUrl={t.voiceUrl ? String(t.voiceUrl) : undefined}
      onAccept={
        viewMode === "forYou" && t.status === "OPEN"
          ? async () => {
              const res = await accept(t.id)
              if (res === "ALREADY") alert("Already assigned")
              if (coords) fetchNearby(coords.latitude, coords.longitude)
            }
          : undefined
      }
      onPress={async () => {
        navigation.navigate("OolshikDetail", { id: t.id })
      }}
      createdByName={t.createdByName ?? t.requesterName}
      createdAt={t.createdAt}
      helperAvgRating={t.helperAvgRating}
    />
  )

  return (
    <Screen preset="fixed" safeAreaEdges={["top", "bottom"]} contentContainerStyle={{ flex: 1 }}>
      {/* Floating Logout */}
      <Pressable
        onPress={() => {
          Alert.alert(
            "Logout",
            "Are you sure you want to logout?",
            [
              { text: "Cancel", style: "cancel" },
              { text: "Logout", style: "destructive", onPress: () => logout() },
            ],
            { cancelable: true },
          )
        }}
        accessibilityRole="button"
        accessibilityLabel="Logout"
        style={({ pressed }) => ({
          position: "absolute",
          top: 12,
          right: 12,
          width: 44,
          height: 44,
          borderRadius: 22,
          backgroundColor: LOGOUT_COLOR,
          alignItems: "center",
          justifyContent: "center",
          zIndex: 1000,
          shadowColor: "#000",
          shadowOpacity: 0.14,
          shadowRadius: 8,
          shadowOffset: { width: 0, height: 2 },
          elevation: 5,
          transform: [{ scale: pressed ? 0.98 : 1 }],
        })}
        hitSlop={8}
      >
        <Text text="⎋" style={{ color: "#fff", fontSize: 18, lineHeight: 18 }} />
      </Pressable>

      {/* Header */}
      <View style={{ paddingHorizontal: 16, paddingTop: 8, paddingBottom: 12 }}>
        <Text
          preset="heading"
          tx={viewMode === "mine" ? "oolshik:myRequestsHeader" : "oolshik:nearbyForYouHeader"}
          style={{ marginBottom: 12 }}
        />

        {/* Segmented toggle */}
        <Segmented value={viewMode} onChange={setViewMode} />
      </View>

      {/* Filters Card */}
      <View style={{ paddingHorizontal: 16, marginBottom: 6 }}>
        <SectionCard>
          {/* Distance */}
          <Text tx="oolshik:distanceFilter" style={{ marginBottom: 8, color: "#6B7280" }} />
          <View style={{ flexDirection: "row", gap: 10 }}>
            {[1, 2, 5].map((km) => (
              <Pill
                key={km}
                label={`${km} km`}
                active={radiusMeters === km}
                onPress={() => setRadius(km as Radius)}
              />
            ))}
          </View>

          {/* Divider */}
          <View style={{ height: 12 }} />

          {/* Status */}
          <Text tx="oolshik:statusFilter" style={{ marginBottom: 8, color: "#6B7280" }} />
          <View style={{ flexDirection: "row", flexWrap: "wrap", gap: 10 }}>
            {STATUS_ORDER.map((s) => {
              const active = selectedStatuses.has(s)
              return <StatusChip key={s} s={s} active={active} onPress={() => toggleStatus(s)} />
            })}
          </View>
        </SectionCard>
      </View>

      {/* Scrollable list */}
      <View style={{ flex: 1, paddingHorizontal: 16, backgroundColor: colors.background }}>
        {loading ? (
          <View style={{ flex: 1, alignItems: "center", justifyContent: "center" }}>
            <ActivityIndicator />
          </View>
        ) : (
          <FlatList
            style={{ marginBottom: 16 }}
            data={data}
            keyExtractor={(item) => String(item.id)}
            renderItem={renderItem}
            extraData={{
              radiusMeters,
              selected: Array.from(selectedStatuses).sort().join(","),
              viewMode,
            }}
            refreshing={loading}
            onRefresh={() => {
              if (coords) {
                const statusesArg = selectedStatuses.size ? Array.from(selectedStatuses) : undefined
                fetchNearby(coords.latitude, coords.longitude, statusesArg as any)
              }
            }}
            removeClippedSubviews
            contentContainerStyle={{ paddingBottom: 140 }}
            ListEmptyComponent={
              <Text
                tx={viewMode === "mine" ? "oolshik:emptyMine" : "oolshik:emptyForYou"}
                style={{ paddingVertical: 12 }}
              />
            }
          />
        )}
      </View>

      {/* Bottom fixed Create button */}
      <View style={{ position: "absolute", left: 16, right: 16, bottom: 0 }}>
        <Button
          tx="oolshik:create"
          onPress={() => navigation.navigate("OolshikCreate")}
          style={{ width: "100%", marginBottom: 0 }}
        />
      </View>
    </Screen>
  )
}
===== END FILE: app/screens/HomeFeedScreen.tsx =====


===== BEGIN FILE: app/screens/ChatScreen.tsx =====
import React from "react"
import { View } from "react-native"
import { Screen } from "@/components/Screen"
import { Text } from "@/components/Text"

export default function ChatScreen() {
  return (
    <Screen preset="fixed" safeAreaEdges={["top","bottom"]} contentContainerStyle={{ padding: 16 }}>
      <Text preset="heading" text="Chat (MVP text-only)" />
      <View style={{ height: 12 }} />
    </Screen>
  )
}
===== END FILE: app/screens/ChatScreen.tsx =====


===== BEGIN FILE: app/screens/DemoDebugScreen.tsx =====
import { FC, useCallback, useMemo } from "react"
import {
  LayoutAnimation,
  Linking,
  Platform,
  TextStyle,
  useColorScheme,
  View,
  ViewStyle,
} from "react-native"
import * as Application from "expo-application"

import { Button } from "@/components/Button"
import { ListItem } from "@/components/ListItem"
import { Screen } from "@/components/Screen"
import { Text } from "@/components/Text"
import { useAuth } from "@/context/AuthContext"
import { isRTL } from "@/i18n"
import { DemoTabScreenProps } from "@/navigators/DemoNavigator"
import type { ThemedStyle } from "@/theme/types"
import { useAppTheme } from "@/theme/context"
import { $styles } from "@/theme/styles"

/**
 * @param {string} url - The URL to open in the browser.
 * @returns {void} - No return value.
 */
function openLinkInBrowser(url: string) {
  Linking.canOpenURL(url).then((canOpen) => canOpen && Linking.openURL(url))
}

const usingHermes = typeof HermesInternal === "object" && HermesInternal !== null

export const DemoDebugScreen: FC<DemoTabScreenProps<"DemoDebug">> = function DemoDebugScreen(
  _props,
) {
  const { setThemeContextOverride, themeContext, themed } = useAppTheme()
  const { logout } = useAuth()

  // @ts-expect-error
  const usingFabric = global.nativeFabricUIManager != null

  const demoReactotron = useMemo(
    () => async () => {
      if (__DEV__) {
        console.tron.display({
          name: "DISPLAY",
          value: {
            appId: Application.applicationId,
            appName: Application.applicationName,
            appVersion: Application.nativeApplicationVersion,
            appBuildVersion: Application.nativeBuildVersion,
            hermesEnabled: usingHermes,
          },
          important: true,
        })
      }
    },
    [],
  )

  const toggleTheme = useCallback(() => {
    LayoutAnimation.configureNext(LayoutAnimation.Presets.easeInEaseOut) // Animate the transition
    setThemeContextOverride(themeContext === "dark" ? "light" : "dark")
  }, [themeContext, setThemeContextOverride])

  // Resets the theme to the system theme
  const colorScheme = useColorScheme()
  const resetTheme = useCallback(() => {
    LayoutAnimation.configureNext(LayoutAnimation.Presets.easeInEaseOut)
    setThemeContextOverride(undefined)
  }, [setThemeContextOverride])

  return (
    <Screen
      preset="scroll"
      safeAreaEdges={["top"]}
      contentContainerStyle={[$styles.container, themed($container)]}
    >
      <Text
        style={themed($reportBugsLink)}
        tx="demoDebugScreen:reportBugs"
        onPress={() => openLinkInBrowser("https://github.com/infinitered/ignite/issues")}
      />

      <Text style={themed($title)} preset="heading" tx="demoDebugScreen:title" />
      <Text preset="bold">Current system theme: {colorScheme}</Text>
      <Text preset="bold">Current app theme: {themeContext}</Text>
      <Button onPress={resetTheme} text={`Reset`} />

      <View style={themed($itemsContainer)}>
        <Button onPress={toggleTheme} text={`Toggle Theme: ${themeContext}`} />
      </View>
      <View style={themed($itemsContainer)}>
        <ListItem
          LeftComponent={
            <View style={themed($item)}>
              <Text preset="bold">App Id</Text>
              <Text>{Application.applicationId}</Text>
            </View>
          }
        />
        <ListItem
          LeftComponent={
            <View style={themed($item)}>
              <Text preset="bold">App Name</Text>
              <Text>{Application.applicationName}</Text>
            </View>
          }
        />
        <ListItem
          LeftComponent={
            <View style={themed($item)}>
              <Text preset="bold">App Version</Text>
              <Text>{Application.nativeApplicationVersion}</Text>
            </View>
          }
        />
        <ListItem
          LeftComponent={
            <View style={themed($item)}>
              <Text preset="bold">App Build Version</Text>
              <Text>{Application.nativeBuildVersion}</Text>
            </View>
          }
        />
        <ListItem
          LeftComponent={
            <View style={themed($item)}>
              <Text preset="bold">Hermes Enabled</Text>
              <Text>{String(usingHermes)}</Text>
            </View>
          }
        />
        <ListItem
          LeftComponent={
            <View style={themed($item)}>
              <Text preset="bold">Fabric Enabled</Text>
              <Text>{String(usingFabric)}</Text>
            </View>
          }
        />
      </View>
      <View style={themed($buttonContainer)}>
        <Button style={themed($button)} tx="demoDebugScreen:reactotron" onPress={demoReactotron} />
        <Text style={themed($hint)} tx={`demoDebugScreen:${Platform.OS}ReactotronHint` as const} />
      </View>
      <View style={themed($buttonContainer)}>
        <Button style={themed($button)} tx="common:logOut" onPress={logout} />
      </View>
    </Screen>
  )
}

const $container: ThemedStyle<ViewStyle> = ({ spacing }) => ({
  paddingBottom: spacing.xxl,
})

const $title: ThemedStyle<TextStyle> = ({ spacing }) => ({
  marginBottom: spacing.xxl,
})

const $reportBugsLink: ThemedStyle<TextStyle> = ({ colors, spacing }) => ({
  color: colors.tint,
  marginBottom: spacing.lg,
  alignSelf: isRTL ? "flex-start" : "flex-end",
})

const $item: ThemedStyle<ViewStyle> = ({ spacing }) => ({
  marginBottom: spacing.md,
})

const $itemsContainer: ThemedStyle<ViewStyle> = ({ spacing }) => ({
  marginVertical: spacing.xl,
})

const $button: ThemedStyle<ViewStyle> = ({ spacing }) => ({
  marginBottom: spacing.xs,
})

const $buttonContainer: ThemedStyle<ViewStyle> = ({ spacing }) => ({
  marginBottom: spacing.md,
})

const $hint: ThemedStyle<TextStyle> = ({ colors, spacing }) => ({
  color: colors.palette.neutral600,
  fontSize: 12,
  lineHeight: 15,
  paddingBottom: spacing.lg,
})

// @demo remove-file
===== END FILE: app/screens/DemoDebugScreen.tsx =====


===== BEGIN FILE: app/screens/ProfileScreen.tsx =====
import React from "react"
import { View } from "react-native"
import { Screen } from "@/components/Screen"
import { Text } from "@/components/Text"
import { Button } from "@/components/Button"
import { useTranslation } from "react-i18next"

export default function ProfileScreen() {
  const { i18n } = useTranslation()
  return (
    <Screen preset="fixed" safeAreaEdges={["top","bottom"]} contentContainerStyle={{ padding: 16, gap: 12 }}>
      <Text preset="heading" text="Profile" />
      <View style={{ flexDirection: "row", gap: 8 }}>
        <Button text="मराठी" onPress={() => i18n.changeLanguage("mr")} />
        <Button text="English" onPress={() => i18n.changeLanguage("en")} />
      </View>
    </Screen>
  )
}
===== END FILE: app/screens/ProfileScreen.tsx =====


===== BEGIN FILE: app/screens/DemoPodcastListScreen.tsx =====
import { ComponentType, FC, useCallback, useEffect, useMemo, useState } from "react"
import {
  AccessibilityProps,
  ActivityIndicator,
  FlatList,
  Image,
  ImageSourcePropType,
  ImageStyle,
  Platform,
  StyleSheet,
  TextStyle,
  View,
  ViewStyle,
} from "react-native"
import Animated, {
  Extrapolation,
  interpolate,
  useAnimatedStyle,
  useSharedValue,
  withSpring,
} from "react-native-reanimated"

import { Button, type ButtonAccessoryProps } from "@/components/Button"
import { Card } from "@/components/Card"
import { EmptyState } from "@/components/EmptyState"
import { Icon } from "@/components/Icon"
import { Screen } from "@/components/Screen"
import { Text } from "@/components/Text"
import { Switch } from "@/components/Toggle/Switch"
import { useEpisodes, useEpisode } from "@/context/EpisodeContext"
import { isRTL } from "@/i18n"
import { translate } from "@/i18n/translate"
import { DemoTabScreenProps } from "@/navigators/DemoNavigator"
import type { EpisodeItem } from "@/services/api/types"
import type { ThemedStyle } from "@/theme/types"
import { useAppTheme } from "@/theme/context"
import { $styles } from "@/theme/styles"
import { delay } from "@/utils/delay"
import { openLinkInBrowser } from "@/utils/openLinkInBrowser"

const ICON_SIZE = 14

const rnrImage1 = require("@assets/images/demo/rnr-image-1.png")
const rnrImage2 = require("@assets/images/demo/rnr-image-2.png")
const rnrImage3 = require("@assets/images/demo/rnr-image-3.png")

const rnrImages = [rnrImage1, rnrImage2, rnrImage3]

export const DemoPodcastListScreen: FC<DemoTabScreenProps<"DemoPodcastList">> = (_props) => {
  const { themed } = useAppTheme()
  const {
    totalEpisodes,
    totalFavorites,

    episodesForList,
    fetchEpisodes,
    favoritesOnly,
    toggleFavoritesOnly,
    toggleFavorite,
  } = useEpisodes()

  const [refreshing, setRefreshing] = useState(false)
  const [isLoading, setIsLoading] = useState(false)

  // initially, kick off a background refresh without the refreshing UI
  useEffect(() => {
    ;(async function load() {
      setIsLoading(true)
      await fetchEpisodes()
      setIsLoading(false)
    })()
  }, [fetchEpisodes])

  // simulate a longer refresh, if the refresh is too fast for UX
  async function manualRefresh() {
    setRefreshing(true)
    await Promise.allSettled([fetchEpisodes(), delay(750)])
    setRefreshing(false)
  }

  return (
    <Screen preset="fixed" safeAreaEdges={["top"]} contentContainerStyle={$styles.flex1}>
      <FlatList<EpisodeItem>
        contentContainerStyle={themed([$styles.container, $listContentContainer])}
        data={episodesForList}
        extraData={totalEpisodes + totalFavorites}
        refreshing={refreshing}
        onRefresh={manualRefresh}
        keyExtractor={(item) => item.guid}
        ListEmptyComponent={
          isLoading ? (
            <ActivityIndicator />
          ) : (
            <EmptyState
              preset="generic"
              style={themed($emptyState)}
              headingTx={
                favoritesOnly ? "demoPodcastListScreen:noFavoritesEmptyState.heading" : undefined
              }
              contentTx={
                favoritesOnly ? "demoPodcastListScreen:noFavoritesEmptyState.content" : undefined
              }
              button={favoritesOnly ? "" : undefined}
              buttonOnPress={manualRefresh}
              imageStyle={$emptyStateImage}
              ImageProps={{ resizeMode: "contain" }}
            />
          )
        }
        ListHeaderComponent={
          <View style={themed($heading)}>
            <Text preset="heading" tx="demoPodcastListScreen:title" />
            {(favoritesOnly || episodesForList.length > 0) && (
              <View style={themed($toggle)}>
                <Switch
                  value={favoritesOnly}
                  onValueChange={() => toggleFavoritesOnly()}
                  labelTx="demoPodcastListScreen:onlyFavorites"
                  labelPosition="left"
                  labelStyle={$labelStyle}
                  accessibilityLabel={translate("demoPodcastListScreen:accessibility.switch")}
                />
              </View>
            )}
          </View>
        }
        renderItem={({ item }) => (
          <EpisodeCard episode={item} onPressFavorite={() => toggleFavorite(item)} />
        )}
      />
    </Screen>
  )
}

const EpisodeCard = ({
  episode,
  onPressFavorite,
}: {
  episode: EpisodeItem
  onPressFavorite: () => void
}) => {
  const {
    theme: { colors },
    themed,
  } = useAppTheme()
  const { isFavorite, datePublished, duration, parsedTitleAndSubtitle } = useEpisode(episode)

  const liked = useSharedValue(isFavorite ? 1 : 0)
  const imageUri = useMemo<ImageSourcePropType>(() => {
    return rnrImages[Math.floor(Math.random() * rnrImages.length)]
  }, [])

  // Grey heart
  const animatedLikeButtonStyles = useAnimatedStyle(() => {
    return {
      transform: [
        {
          scale: interpolate(liked.value, [0, 1], [1, 0], Extrapolation.EXTEND),
        },
      ],
      opacity: interpolate(liked.value, [0, 1], [1, 0], Extrapolation.CLAMP),
    }
  })

  // Pink heart
  const animatedUnlikeButtonStyles = useAnimatedStyle(() => {
    return {
      transform: [
        {
          scale: liked.value,
        },
      ],
      opacity: liked.value,
    }
  })

  const handlePressFavorite = useCallback(() => {
    onPressFavorite()
    liked.value = withSpring(liked.value ? 0 : 1)
  }, [liked, onPressFavorite])

  /**
   * Android has a "longpress" accessibility action. iOS does not, so we just have to use a hint.
   * @see https://reactnative.dev/docs/accessibility#accessibilityactions
   */
  const accessibilityHintProps = useMemo(
    () =>
      Platform.select<AccessibilityProps>({
        ios: {
          accessibilityLabel: episode.title,
          accessibilityHint: translate("demoPodcastListScreen:accessibility.cardHint", {
            action: isFavorite ? "unfavorite" : "favorite",
          }),
        },
        android: {
          accessibilityLabel: episode.title,
          accessibilityActions: [
            {
              name: "longpress",
              label: translate("demoPodcastListScreen:accessibility.favoriteAction"),
            },
          ],
          onAccessibilityAction: ({ nativeEvent }) => {
            if (nativeEvent.actionName === "longpress") {
              handlePressFavorite()
            }
          },
        },
      }),
    [episode.title, handlePressFavorite, isFavorite],
  )

  const handlePressCard = () => {
    openLinkInBrowser(episode.enclosure.link)
  }

  const ButtonLeftAccessory: ComponentType<ButtonAccessoryProps> = useMemo(
    () =>
      function ButtonLeftAccessory() {
        return (
          <View>
            <Animated.View
              style={[
                $styles.row,
                themed($iconContainer),
                StyleSheet.absoluteFill,
                animatedLikeButtonStyles,
              ]}
            >
              <Icon
                icon="heart"
                size={ICON_SIZE}
                color={colors.palette.neutral800} // dark grey
              />
            </Animated.View>
            <Animated.View
              style={[$styles.row, themed($iconContainer), animatedUnlikeButtonStyles]}
            >
              <Icon
                icon="heart"
                size={ICON_SIZE}
                color={colors.palette.primary400} // pink
              />
            </Animated.View>
          </View>
        )
      },
    [animatedLikeButtonStyles, animatedUnlikeButtonStyles, colors, themed],
  )

  return (
    <Card
      style={themed($item)}
      verticalAlignment="force-footer-bottom"
      onPress={handlePressCard}
      onLongPress={handlePressFavorite}
      HeadingComponent={
        <View style={[$styles.row, themed($metadata)]}>
          <Text
            style={themed($metadataText)}
            size="xxs"
            accessibilityLabel={datePublished.accessibilityLabel}
          >
            {datePublished.textLabel}
          </Text>
          <Text
            style={themed($metadataText)}
            size="xxs"
            accessibilityLabel={duration.accessibilityLabel}
          >
            {duration.textLabel}
          </Text>
        </View>
      }
      content={
        parsedTitleAndSubtitle.subtitle
          ? `${parsedTitleAndSubtitle.title} - ${parsedTitleAndSubtitle.subtitle}`
          : parsedTitleAndSubtitle.title
      }
      {...accessibilityHintProps}
      RightComponent={<Image source={imageUri} style={themed($itemThumbnail)} />}
      FooterComponent={
        <Button
          onPress={handlePressFavorite}
          onLongPress={handlePressFavorite}
          style={themed([$favoriteButton, isFavorite && $unFavoriteButton])}
          accessibilityLabel={
            isFavorite
              ? translate("demoPodcastListScreen:accessibility.unfavoriteIcon")
              : translate("demoPodcastListScreen:accessibility.favoriteIcon")
          }
          LeftAccessory={ButtonLeftAccessory}
        >
          <Text
            size="xxs"
            accessibilityLabel={duration.accessibilityLabel}
            weight="medium"
            text={
              isFavorite
                ? translate("demoPodcastListScreen:unfavoriteButton")
                : translate("demoPodcastListScreen:favoriteButton")
            }
          />
        </Button>
      }
    />
  )
}

// #region Styles
const $listContentContainer: ThemedStyle<ViewStyle> = ({ spacing }) => ({
  paddingHorizontal: spacing.lg,
  paddingTop: spacing.lg + spacing.xl,
  paddingBottom: spacing.lg,
})

const $heading: ThemedStyle<ViewStyle> = ({ spacing }) => ({
  marginBottom: spacing.md,
})

const $item: ThemedStyle<ViewStyle> = ({ colors, spacing }) => ({
  padding: spacing.md,
  marginTop: spacing.md,
  minHeight: 120,
  backgroundColor: colors.palette.neutral100,
})

const $itemThumbnail: ThemedStyle<ImageStyle> = ({ spacing }) => ({
  marginTop: spacing.sm,
  borderRadius: 50,
  alignSelf: "flex-start",
})

const $toggle: ThemedStyle<ViewStyle> = ({ spacing }) => ({
  marginTop: spacing.md,
})

const $labelStyle: TextStyle = {
  textAlign: "left",
}

const $iconContainer: ThemedStyle<ViewStyle> = ({ spacing }) => ({
  height: ICON_SIZE,
  width: ICON_SIZE,
  marginEnd: spacing.sm,
})

const $metadata: ThemedStyle<TextStyle> = ({ colors, spacing }) => ({
  color: colors.textDim,
  marginTop: spacing.xs,
})

const $metadataText: ThemedStyle<TextStyle> = ({ colors, spacing }) => ({
  color: colors.textDim,
  marginEnd: spacing.md,
  marginBottom: spacing.xs,
})

const $favoriteButton: ThemedStyle<ViewStyle> = ({ colors, spacing }) => ({
  borderRadius: 17,
  marginTop: spacing.md,
  justifyContent: "flex-start",
  backgroundColor: colors.palette.neutral300,
  borderColor: colors.palette.neutral300,
  paddingHorizontal: spacing.md,
  paddingTop: spacing.xxxs,
  paddingBottom: 0,
  minHeight: 32,
  alignSelf: "flex-start",
})

const $unFavoriteButton: ThemedStyle<ViewStyle> = ({ colors }) => ({
  borderColor: colors.palette.primary100,
  backgroundColor: colors.palette.primary100,
})

const $emptyState: ThemedStyle<ViewStyle> = ({ spacing }) => ({
  marginTop: spacing.xxl,
})

const $emptyStateImage: ImageStyle = {
  transform: [{ scaleX: isRTL ? -1 : 1 }],
}
// #endregion

// @demo remove-file
===== END FILE: app/screens/DemoPodcastListScreen.tsx =====


===== BEGIN FILE: app/screens/OnboardingConsentScreen.tsx =====
import React, { useMemo, useState } from "react"
import { View, Pressable } from "react-native"
import { Screen } from "@/components/Screen"
import { Text } from "@/components/Text"
import { Button } from "@/components/Button"
import { RadioGroup } from "@/components/RadioGroup"
import { useAppTheme } from "@/theme/context"
import { useTranslation } from "react-i18next"
import { useForegroundLocation } from "@/hooks/useForegroundLocation"
import { storage } from "@/utils/storage"
import { useMMKVString } from "react-native-mmkv"

export default function OnboardingConsentScreen({ navigation }: any) {
  const { theme } = useAppTheme()
  const { spacing, colors } = theme
  const { i18n } = useTranslation()
  const [onboardingComplete, setOnboardingComplete] = useMMKVString(
    "onboarding.v1.completed",
    storage,
  )

  // location hook (assumes it exposes `granted` and maybe a `request` function)
  const { granted, request } = useForegroundLocation() as {
    granted?: boolean
    request?: () => Promise<void>
  }

  const [accepted, setAccepted] = useState(false)
  const [lang, setLang] = useState<"mr" | "en">(i18n.language === "mr" ? "mr" : "en")

  // change language on select
  React.useEffect(() => {
    i18n.changeLanguage(lang)
  }, [lang])

  const canContinue = useMemo(() => Boolean(accepted && granted), [accepted, granted])

  // tiny themed checkbox
  const Checkbox = ({ value, onToggle }: { value: boolean; onToggle: () => void }) => (
    <Pressable
      onPress={onToggle}
      accessibilityRole="checkbox"
      accessibilityState={{ checked: value }}
      style={{
        width: 22,
        height: 22,
        borderRadius: 6,
        borderWidth: 1,
        borderColor: colors.palette.neutral400,
        backgroundColor: value ? colors.palette.primary500 : colors.palette.neutral100,
        alignItems: "center",
        justifyContent: "center",
      }}
    >
      {value ? <Text text="✓" style={{ color: "white" }} /> : null}
    </Pressable>
  )

  return (
    <Screen preset="fixed" safeAreaEdges={["top", "bottom"]} contentContainerStyle={{ flex: 1 }}>
      {/* Header */}
      <View style={{ padding: spacing.md }}>
        <Text preset="heading" tx="oolshik:consentTitle" />
      </View>

      {/* Body (scrollable content area look, but inside fixed layout) */}
      <View style={{ flex: 1, paddingHorizontal: spacing.md, gap: spacing.lg }}>
        {/* Intro / copy */}
        <View style={{ gap: spacing.xs }}>
          <Text tx="oolshik:locationPermissionMsg" />
        </View>

        {/* Language selection as radio chips */}
        <View>
          <Text text="Language" weight="medium" style={{ marginBottom: spacing.xs }} />
          <RadioGroup
            value={lang}
            onChange={(v) => setLang(v as "mr" | "en")}
            options={[
              { label: "मराठी", value: "mr" },
              { label: "English", value: "en" },
            ]}
            size="md"
            gap={8}
          />
        </View>

        {/* Consent checkbox */}
        <View style={{ flexDirection: "row", alignItems: "center", gap: spacing.sm }}>
          <Checkbox value={accepted} onToggle={() => setAccepted((v) => !v)} />
          <Pressable onPress={() => setAccepted((v) => !v)} style={{ flex: 1 }}>
            <Text tx="oolshik:consentAgree" />
          </Pressable>
        </View>

        {/* Location permission call-to-action */}
        <View style={{ gap: spacing.xs }}>
          <Button
            tx="oolshik:allow"
            onPress={async () => {
              // request foreground location if hook exposes request(); otherwise this button
              // still communicates intent (granted should flip when permission granted)
              try {
                await request?.()
              } catch {}
            }}
            style={{ width: "100%", paddingVertical: spacing.xs }}
          />
          {/* Small status helper */}
          <Text
            text={granted ? "✓ Location permission granted" : "Location permission required"}
            size="xs"
            style={{ color: granted ? "#16A34A" : colors.palette.neutral600 }}
          />
        </View>
      </View>

      {/* Bottom fixed primary CTA */}
      <View
        style={{ position: "absolute", left: spacing.md, right: spacing.md, bottom: spacing.md }}
      >
        <Button
          tx="oolshik:home"
          onPress={() => {
            setOnboardingComplete("true")
            navigation.replace("OolshikHome")
          }}
          disabled={!canContinue}
          style={{ width: "100%", paddingVertical: spacing.xs, opacity: canContinue ? 1 : 0.6 }}
        />
      </View>
    </Screen>
  )
}
===== END FILE: app/screens/OnboardingConsentScreen.tsx =====


===== BEGIN FILE: app/screens/DemoCommunityScreen.tsx =====
import { FC } from "react"
import { Image, ImageStyle, TextStyle, View, ViewStyle } from "react-native"

import { ListItem } from "@/components/ListItem"
import { Screen } from "@/components/Screen"
import { Text } from "@/components/Text"
import { isRTL } from "@/i18n"
import { DemoTabScreenProps } from "@/navigators/DemoNavigator"
import type { ThemedStyle } from "@/theme/types"
import { useAppTheme } from "@/theme/context"
import { $styles } from "@/theme/styles"
import { openLinkInBrowser } from "@/utils/openLinkInBrowser"

const chainReactLogo = require("@assets/images/demo/cr-logo.png")
const reactNativeLiveLogo = require("@assets/images/demo/rnl-logo.png")
const reactNativeNewsletterLogo = require("@assets/images/demo/rnn-logo.png")
const reactNativeRadioLogo = require("@assets/images/demo/rnr-logo.png")

export const DemoCommunityScreen: FC<DemoTabScreenProps<"DemoCommunity">> =
  function DemoCommunityScreen(_props) {
    const { themed } = useAppTheme()
    return (
      <Screen preset="scroll" contentContainerStyle={$styles.container} safeAreaEdges={["top"]}>
        <Text preset="heading" tx="demoCommunityScreen:title" style={themed($title)} />
        <Text tx="demoCommunityScreen:tagLine" style={themed($tagline)} />

        <Text preset="subheading" tx="demoCommunityScreen:joinUsOnSlackTitle" />
        <Text tx="demoCommunityScreen:joinUsOnSlack" style={themed($description)} />
        <ListItem
          tx="demoCommunityScreen:joinSlackLink"
          leftIcon="slack"
          rightIcon={isRTL ? "caretLeft" : "caretRight"}
          onPress={() => openLinkInBrowser("https://community.infinite.red/")}
        />
        <Text
          preset="subheading"
          tx="demoCommunityScreen:makeIgniteEvenBetterTitle"
          style={themed($sectionTitle)}
        />
        <Text tx="demoCommunityScreen:makeIgniteEvenBetter" style={themed($description)} />
        <ListItem
          tx="demoCommunityScreen:contributeToIgniteLink"
          leftIcon="github"
          rightIcon={isRTL ? "caretLeft" : "caretRight"}
          onPress={() => openLinkInBrowser("https://github.com/infinitered/ignite")}
        />

        <Text
          preset="subheading"
          tx="demoCommunityScreen:theLatestInReactNativeTitle"
          style={themed($sectionTitle)}
        />
        <Text tx="demoCommunityScreen:theLatestInReactNative" style={themed($description)} />
        <ListItem
          tx="demoCommunityScreen:reactNativeRadioLink"
          bottomSeparator
          rightIcon={isRTL ? "caretLeft" : "caretRight"}
          LeftComponent={
            <View style={[$styles.row, themed($logoContainer)]}>
              <Image source={reactNativeRadioLogo} style={$logo} />
            </View>
          }
          onPress={() => openLinkInBrowser("https://reactnativeradio.com/")}
        />
        <ListItem
          tx="demoCommunityScreen:reactNativeNewsletterLink"
          bottomSeparator
          rightIcon={isRTL ? "caretLeft" : "caretRight"}
          LeftComponent={
            <View style={[$styles.row, themed($logoContainer)]}>
              <Image source={reactNativeNewsletterLogo} style={$logo} />
            </View>
          }
          onPress={() => openLinkInBrowser("https://reactnativenewsletter.com/")}
        />
        <ListItem
          tx="demoCommunityScreen:reactNativeLiveLink"
          bottomSeparator
          rightIcon={isRTL ? "caretLeft" : "caretRight"}
          LeftComponent={
            <View style={[$styles.row, themed($logoContainer)]}>
              <Image source={reactNativeLiveLogo} style={$logo} />
            </View>
          }
          onPress={() => openLinkInBrowser("https://rn.live/")}
        />
        <ListItem
          tx="demoCommunityScreen:chainReactConferenceLink"
          rightIcon={isRTL ? "caretLeft" : "caretRight"}
          LeftComponent={
            <View style={[$styles.row, themed($logoContainer)]}>
              <Image source={chainReactLogo} style={$logo} />
            </View>
          }
          onPress={() => openLinkInBrowser("https://cr.infinite.red/")}
        />
        <Text
          preset="subheading"
          tx="demoCommunityScreen:hireUsTitle"
          style={themed($sectionTitle)}
        />
        <Text tx="demoCommunityScreen:hireUs" style={themed($description)} />
        <ListItem
          tx="demoCommunityScreen:hireUsLink"
          leftIcon="clap"
          rightIcon={isRTL ? "caretLeft" : "caretRight"}
          onPress={() => openLinkInBrowser("https://infinite.red/contact")}
        />
      </Screen>
    )
  }

const $title: ThemedStyle<TextStyle> = ({ spacing }) => ({
  marginBottom: spacing.sm,
})

const $tagline: ThemedStyle<TextStyle> = ({ spacing }) => ({
  marginBottom: spacing.xxl,
})

const $description: ThemedStyle<TextStyle> = ({ spacing }) => ({
  marginBottom: spacing.lg,
})

const $sectionTitle: ThemedStyle<TextStyle> = ({ spacing }) => ({
  marginTop: spacing.xxl,
})

const $logoContainer: ThemedStyle<ViewStyle> = ({ spacing }) => ({
  marginEnd: spacing.md,
  flexWrap: "wrap",
  alignContent: "center",
  alignSelf: "stretch",
})

const $logo: ImageStyle = {
  height: 38,
  width: 38,
}

// @demo remove-file
===== END FILE: app/screens/DemoCommunityScreen.tsx =====


===== BEGIN FILE: app/screens/LoginScreen.tsx =====
import { FC, useEffect, useMemo, useRef, useState } from "react"
import { TextInput, TextStyle, View, ViewStyle, Pressable } from "react-native"

import { Button } from "@/components/Button"
import { Screen } from "@/components/Screen"
import { OolshikApi } from "@/api"
import { setLoginTokens } from "@/api/client"
import { Text } from "@/components/Text"
import { TextField } from "@/components/TextField"
import { useAuth } from "@/context/AuthContext"
import type { AppStackScreenProps } from "@/navigators/AppNavigator"
import type { ThemedStyle } from "@/theme/types"
import { useAppTheme } from "@/theme/context"

interface LoginScreenProps extends AppStackScreenProps<"Login"> {}

// A large, tap-to-focus 6-box OTP input optimized for accessibility
function OtpBoxes({
  value,
  length = 6,
  onChange,
  editable,
}: {
  value: string
  length?: number
  onChange: (v: string) => void
  editable: boolean
}) {
  const inputRef = useRef<TextInput>(null)
  const { theme } = useAppTheme()
  const { spacing, colors } = theme

  const digits = Array.from({ length }).map((_, i) => value[i] ?? "")

  return (
    <Pressable
      onPress={() => inputRef.current?.focus()}
      accessibilityRole="button"
      style={{ flexDirection: "row", justifyContent: "space-between", gap: spacing.sm }}
    >
      {digits.map((d, i) => (
        <View
          key={i}
          style={{
            width: 46,
            height: 56,
            borderRadius: 12,
            borderWidth: 1,
            borderColor: colors.palette.neutral400,
            backgroundColor: editable ? colors.palette.neutral100 : colors.palette.neutral200,
            alignItems: "center",
            justifyContent: "center",
          }}
        >
          <Text text={d ? d : ""} weight="bold" style={{ fontSize: 20 }} />
        </View>
      ))}

      {/* Hidden receiver */}
      <TextInput
        ref={inputRef}
        value={value}
        onChangeText={(t) => onChange(t.replace(/\D/g, "").slice(0, length))}
        keyboardType="number-pad"
        textContentType="oneTimeCode"
        maxLength={length}
        style={{ position: "absolute", opacity: 0, height: 0, width: 0 }}
        editable={editable}
      />
    </Pressable>
  )
}

export const LoginScreen: FC<LoginScreenProps> = ({ navigation }) => {
  // Mandatory phone & OTP
  const [phone, setPhone] = useState("") // 10 digits (India-style)
  const [otp, setOtp] = useState("")
  const [otpSent, setOtpSent] = useState(false)
  const [otpVerified, setOtpVerified] = useState(false)
  const [displayName, setDisplayName] = useState("")
  const [triedContinue, setTriedContinue] = useState(false)
  const [loading, setLoading] = useState<"send" | "verify" | null>(null)
  const [resendIn, setResendIn] = useState(0)
  const [showEmail, setShowEmail] = useState(false)
  const [pendingTokens, setPendingTokens] = useState<{
    accessToken: string
    refreshToken: string
  } | null>(null)

  const { setAuthEmail, authEmail, setAuthToken, setUserId, setUserName, validationError } =
    useAuth()

  const { themed, theme } = useAppTheme()
  const { spacing, colors } = theme

  // Clear email on mount (optional field)
  useEffect(() => {
    setAuthEmail("")
  }, [setAuthEmail])

  // Validation
  const phoneError = useMemo(() => {
    const t = phone.replace(/\D/g, "")
    if (t.length === 0) return "can't be blank"
    if (t.length < 10) return "must be 10 digits"
    return ""
  }, [phone])

  const nameError = useMemo(() => {
    return displayName.trim().length === 0 ? "can't be blank" : ""
  }, [displayName])

  // Real services
  async function sendOtp(p: string) {
    try {
      return await OolshikApi.requestOtp(p)
    } catch {
      return { ok: false } as any
    }
  }

  async function verifyOtp(p: string, code: string, dName?: string, email?: string) {
    try {
      return await OolshikApi.verifyOtp({ phone: p, code, displayName: dName, email })
    } catch {
      return { ok: false } as any
    }
  }

  // Resend timer
  useEffect(() => {
    if (resendIn <= 0) return
    const id = setInterval(() => setResendIn((s) => (s > 0 ? s - 1 : 0)), 1000)
    return () => clearInterval(id)
  }, [resendIn])

  const onSendOtp = async () => {
    if (phoneError) return
    setLoading("send")
    const res = await sendOtp(phone)
    setLoading(null)
    if (res.ok) {
      setOtpSent(true)
      setOtp("")
      setOtpVerified(false)
      setResendIn(30)
    } else {
      alert("Failed to send OTP")
    }
  }

  const onVerifyOtp = async () => {
    if (!otpSent) return
    if (!/^\d{6}$/.test(otp)) return
    setLoading("verify")
    const res = await verifyOtp(phone, otp, displayName || undefined, authEmail || undefined)
    setLoading(null)
    if (res.ok && res.data?.accessToken) {
      // Do not persist tokens here to avoid auto-navigation.
      setPendingTokens({ accessToken: res.data.accessToken, refreshToken: res.data.refreshToken })
      setOtpVerified(true)
    } else {
      alert("Invalid OTP")
    }
  }

  const onContinue = async () => {
    setTriedContinue(true)
    if (phoneError || displayName.trim().length === 0) return

    let tokens = pendingTokens

    // If OTP hasn't been verified yet, attempt verification now (no auto-verify on 6th digit)
    if (!otpVerified) {
      if (!otpSent || !/^\d{6}$/.test(otp)) {
        alert("Please enter the 6-digit code to continue.")
        return
      }
      setLoading("verify")
      const res = await verifyOtp(phone, otp, displayName || undefined, authEmail || undefined)
      setLoading(null)
      if (!(res.ok && res.data?.accessToken)) {
        alert("Invalid OTP")
        return
      }
      tokens = { accessToken: res.data.accessToken, refreshToken: res.data.refreshToken }
      setPendingTokens(tokens)
      setOtpVerified(true)
    }

    // Persist tokens now (and only now) to prevent auto-redirects earlier
    if (tokens?.accessToken) {
      setAuthToken(tokens.accessToken)
      setLoginTokens(tokens.accessToken, tokens.refreshToken)
    }

    // Fetch profile after token is set
    try {
      const prof = await OolshikApi.me()
      if (prof?.ok && prof.data) {
        const profile = prof.data as { id?: string | number; displayName?: string }
        setUserName(profile.displayName ?? (displayName || "You"))
        if (profile.id != null) setUserId(String(profile.id))
      } else {
        setUserName(displayName || "You")
      }
    } catch {
      setUserName(displayName || "You")
    }

    // // Navigate to HomeFeed only from here
    // try {
    //   ;(navigation as any)?.navigate?.("HomeFeed")
    // } catch {}
  }

  return (
    <Screen
      preset="scroll"
      safeAreaEdges={["top", "bottom"]}
      contentContainerStyle={themed($container)}
    >
      {/* Title */}
      <Text preset="heading" text="Log in" style={themed($title)} />

      {/* STEP 1: Phone */}
      <View style={themed($card)}>
        <View style={themed($cardHeader)}>
          <View style={themed($stepBadge)}>
            <Text text="1" weight="bold" style={{ color: "white" }} />
          </View>
          <Text text="Verify your mobile" weight="bold" />
          {otpVerified ? <Text text="✓" style={{ marginLeft: "auto", color: "#16A34A" }} /> : null}
        </View>

        <View style={{ flexDirection: "row", gap: spacing.sm, alignItems: "center" }}>
          <View style={themed($ccBadge)}>
            <Text text="+91" weight="bold" style={{ color: colors.palette.neutral800 }} />
          </View>
          <View style={{ flex: 1 }}>
            <TextField
              value={phone}
              onChangeText={(v) => setPhone(v.replace(/\D/g, "").slice(0, 10))}
              containerStyle={{ marginBottom: 0 }}
              keyboardType="phone-pad"
              placeholder="10-digit mobile"
              status={phoneError ? "error" : undefined}
              maxLength={10}
              editable={!otpVerified}
              inputWrapperStyle={themed($inputWrapperDense)}
              style={{ height: 50, paddingVertical: 0 }}
            />
          </View>
        </View>
        {!!phoneError && (
          <Text text={phoneError} size="xs" style={{ color: "#DC2626", marginTop: spacing.xs }} />
        )}

        <View style={{ flexDirection: "row", gap: spacing.sm, marginTop: spacing.sm }}>
          <Button
            text={
              otpSent
                ? resendIn > 0
                  ? `Resend in ${resendIn}s`
                  : loading === "send"
                    ? "Sending…"
                    : "Resend OTP"
                : loading === "send"
                  ? "Sending…"
                  : "Send OTP"
            }
            onPress={onSendOtp}
            disabled={!!phoneError || loading === "send" || (otpSent && resendIn > 0)}
            style={{ flex: 1, paddingVertical: spacing.xs }}
          />
        </View>
      </View>

      {/* STEP 2: OTP */}
      <View style={themed($card)}>
        <View style={themed($cardHeader)}>
          <View style={themed($stepBadge)}>
            <Text text="2" weight="bold" style={{ color: "white" }} />
          </View>
          <Text text="Enter 6-digit code" weight="bold" />
          {otpVerified ? (
            <Text text="✓ Verified" style={{ marginLeft: "auto", color: "#16A34A" }} />
          ) : null}
        </View>

        <OtpBoxes value={otp} onChange={setOtp} editable={otpSent && !otpVerified} />

        {!otpVerified && (
          <View style={{ marginTop: spacing.sm }}>
            <Button
              text={loading === "verify" ? "Verifying…" : "Verify"}
              onPress={onVerifyOtp}
              disabled={!otpSent || otp.length !== 6 || loading === "verify"}
              style={{ marginTop: spacing.md, paddingVertical: spacing.xs }}
            />
          </View>
        )}
      </View>

      {/* STEP 3: Name */}
      <View style={themed($card)}>
        <View style={themed($cardHeader)}>
          <View style={themed($stepBadge)}>
            <Text text="3" weight="bold" style={{ color: "white" }} />
          </View>
          <Text text="Your name" weight="bold" />
          {displayName.trim().length > 0 ? (
            <Text text="✓" style={{ marginLeft: "auto", color: "#16A34A" }} />
          ) : null}
        </View>
        <TextField
          value={displayName}
          onChangeText={setDisplayName}
          placeholder="Your name"
          autoCapitalize="words"
          status={triedContinue && nameError ? "error" : undefined}
          helper={triedContinue && nameError ? nameError : undefined}
        />
      </View>

      <View style={themed($card)}>
        <Pressable onPress={() => setShowEmail((v) => !v)} style={themed($cardHeader)}>
          <Text text="Email" weight="bold" />
          <Text text={showEmail ? "–" : "+"} style={{ marginLeft: "auto" }} />
        </Pressable>
        {showEmail && (
          <TextField
            value={authEmail}
            onChangeText={setAuthEmail}
            autoCapitalize="none"
            autoCorrect={false}
            keyboardType="email-address"
            placeholder="name@example.com"
            helper={validationError}
            status={validationError ? "error" : undefined}
          />
        )}
      </View>

      {/* Bottom fixed Continue */}
      <View
        pointerEvents="box-none"
        style={{ position: "absolute", left: spacing.md, right: spacing.md, bottom: spacing.md }}
      >
        <Button
          text="Continue"
          onPress={onContinue}
          disabled={!!phoneError || displayName.trim().length === 0}
          style={{ paddingVertical: spacing.sm }}
        />
      </View>
    </Screen>
  )
}

const $container: ThemedStyle<ViewStyle> = ({ spacing }) => ({
  // Do not set flex here; it can prevent ScrollView from scrolling
  padding: spacing.md,
  paddingBottom: 96,
})

const $title: ThemedStyle<TextStyle> = ({ spacing }) => ({
  marginBottom: spacing.md,
})

const $card: ThemedStyle<ViewStyle> = ({ colors, spacing }) => ({
  backgroundColor: colors.palette.neutral100,
  borderColor: colors.palette.neutral300,
  borderWidth: 1,
  borderRadius: spacing.md,
  padding: spacing.md,
  marginBottom: spacing.md,
})

const $cardHeader: ThemedStyle<ViewStyle> = ({ spacing }) => ({
  flexDirection: "row",
  alignItems: "center",
  gap: spacing.sm,
  marginBottom: spacing.md,
})

const $stepBadge: ThemedStyle<ViewStyle> = ({ colors }) => ({
  width: 28,
  height: 28,
  borderRadius: 14,
  backgroundColor: colors.palette.primary500,
  alignItems: "center",
  justifyContent: "center",
})

const $ccBadge: ThemedStyle<ViewStyle> = ({ colors, spacing }) => ({
  paddingHorizontal: spacing.sm,
  height: 50,
  borderRadius: spacing.sm,
  borderWidth: 1,
  borderColor: colors.palette.neutral300,
  alignItems: "center",
  justifyContent: "center",
  backgroundColor: colors.palette.neutral100,
})

const $inputWrapperDense: ThemedStyle<ViewStyle> = () => ({
  height: 50,
  minHeight: 50,
  alignItems: "center",
  paddingVertical: 0,
})

// @demo remove-file
===== END FILE: app/screens/LoginScreen.tsx =====


===== BEGIN FILE: app/screens/CreateTaskScreen.tsx =====
import React, { useState, useRef, useEffect } from "react"
import { View, Alert, ActivityIndicator } from "react-native"
import { Screen } from "@/components/Screen"
import { Text } from "@/components/Text"
import { TextField } from "@/components/TextField"
import { Button } from "@/components/Button"
import { useAudioRecorder } from "@/hooks/useAudioRecorder"
import { useForegroundLocation } from "@/hooks/useForegroundLocation"
import { OolshikApi } from "@/api"
import * as FileSystem from "expo-file-system"
import { Audio } from "expo-av"
import { RadioGroup } from "@/components/RadioGroup"
import { useAuth } from "@/context/AuthContext"
import { FLAGS } from "@/config/flags"
import { useTaskStore } from "@/store/taskStore"
import { Task } from "@/api/client"
import { uploadAudioSmart } from "@/audio/uploadAudio"

type Radius = 1 | 2 | 5

export default function CreateTaskScreen({ navigation }: any) {
  const [title, setTitle] = useState("")
  const [description, setDescription] = useState("")
  const [radiusKm, setRadiusKm] = useState<Radius>(1)
  const [submitting, setSubmitting] = useState(false)
  const [audioAccepted, setAudioAccepted] = useState(false)
  const soundRef = useRef<Audio.Sound | null>(null)
  const [isPlaying, setIsPlaying] = useState(false)
  const [playbackSecs, setPlaybackSecs] = useState(0)
  const MAX_DESC = 500

  const { uri, start, stop, recording, durationSec, reset } = useAudioRecorder(30)
  const { coords } = useForegroundLocation()
  const { userId, userName } = useAuth()
  const { tasks } = useTaskStore()

  // Load/unload preview sound when a new recording is available
  useEffect(() => {
    let mounted = true
    const load = async () => {
      if (!uri) {
        if (soundRef.current) {
          try {
            await soundRef.current.unloadAsync()
          } catch {}
          soundRef.current = null
        }
        setIsPlaying(false)
        setPlaybackSecs(0)
        setAudioAccepted(false)
        return
      }
      try {
        if (soundRef.current) {
          try {
            await soundRef.current.unloadAsync()
          } catch {}
          soundRef.current = null
        }
        const { sound } = await Audio.Sound.createAsync({ uri }, { shouldPlay: false })
        sound.setOnPlaybackStatusUpdate((status) => {
          if (!mounted) return
          if (!status.isLoaded) return
          setPlaybackSecs(Math.floor((status.positionMillis || 0) / 1000))
          setIsPlaying(!!status.isPlaying)
          if ((status as any).didJustFinish) {
            // when playback completes, keep the counter at the end
            setIsPlaying(false)
          }
        })
        soundRef.current = sound
      } catch {}
    }
    load()
    return () => {
      mounted = false
    }
  }, [uri])

  const togglePlay = async () => {
    const sound = soundRef.current
    if (!sound) return
    const status = await sound.getStatusAsync()
    if (!status.isLoaded) return
    if (status.isPlaying) {
      await sound.pauseAsync()
    } else {
      try {
        await sound.setPositionAsync(0)
      } catch {}
      setPlaybackSecs(0)
      await sound.playAsync()
    }
  }

  const discardRecording = async () => {
    try {
      await soundRef.current?.unloadAsync()
    } catch {}
    soundRef.current = null
    setIsPlaying(false)
    setPlaybackSecs(0)
    setAudioAccepted(false)
    reset()
  }

  const handlePost = async () => {
    if (!coords) {
      Alert.alert("Location not ready", "Please enable location to post your request.")
      return
    }
    if (!title.trim()) {
      Alert.alert("Missing title", "Please enter a title for your request.")
      return
    }

    setSubmitting(true)
    try {
      // Decide if we will actually upload a recorded file
      // const wantRealUpload = false && !!uri && audioAccepted

      const fallbackVoice = "https://www.soundhelix.com/examples/mp3/SoundHelix-Song-1.mp3"
      let finalVoiceUrl = fallbackVoice

      // if (!wantRealUpload) {
      // inside handlePost:
      let voiceUrl: string | undefined

      if (uri && audioAccepted) {
        const res = await uploadAudioSmart({
          uri,
          filename: `voice_${Date.now()}.m4a`,
          mimeType: "audio/m4a",
          durationMs: durationSec * 1000,
        })
        if (!res.ok) {
          Alert.alert("Upload failed", "Please try again.")
          setSubmitting(false)
          return
        }
        voiceUrl = res.url
      }
      finalVoiceUrl = "" + voiceUrl
      // }

      // 3) create (mock returns ok with fake task; real hits backend)
      const payload = {
        title: title.trim(),
        description: description.trim() || undefined,
        voiceUrl: finalVoiceUrl,
        latitude: coords.latitude,
        longitude: coords.longitude,
        radiusMeters: radiusKm * 1000,
        createdById: userId,
        createdByName: userName,
        createdAt: new Date().toISOString(),
      }

      const res = await OolshikApi.createTask(payload)

      if (res.ok && res.data) {
        try {
          await soundRef.current?.unloadAsync()
        } catch {}
        soundRef.current = null
        setAudioAccepted(false)
        setIsPlaying(false)
        setPlaybackSecs(0)
        reset()
        tasks.unshift(res.data as Task)
        Alert.alert("Posted", "Your request has been created successfully.", [
          { text: "OK", onPress: () => navigation.goBack() },
        ])
      } else {
        const errMsg =
          (res as any)?.data?.message ||
          (res as any)?.problem ||
          (res as any)?.originalError?.message ||
          "Please try again."
        Alert.alert("Create failed", errMsg)
      }
    } catch (e: any) {
      Alert.alert("Create failed", e?.message ?? "Unexpected error occurred.")
    } finally {
      setSubmitting(false)
    }
  }

  const onStartPress = async () => {
    try {
      await start()
    } catch (e: any) {
      Alert.alert("Recorder error", e?.message ?? "Microphone not available")
    }
  }

  return (
    <Screen
      preset="scroll"
      safeAreaEdges={["top", "bottom"]}
      contentContainerStyle={{ padding: 16, gap: 12 }}
    >
      <Text preset="heading" text="Create Task" />

      {/* Title */}
      <View style={{ gap: 6 }}>
        <Text text="Title" style={{ fontWeight: "600", opacity: 0.9 }} />
        <TextField
          value={title}
          onChangeText={setTitle}
          placeholder="Give a short title"
          maxLength={80}
          autoCapitalize="sentences"
          autoCorrect
          returnKeyType="next"
        />
      </View>

      {/* Description */}
      <View style={{ gap: 6 }}>
        <Text text="Description" style={{ fontWeight: "600", opacity: 0.9 }} />
        <TextField
          value={description}
          onChangeText={(t) => setDescription(t.slice(0, MAX_DESC))}
          placeholder="Describe what you need (optional)"
          multiline
          numberOfLines={5}
          style={{ minHeight: 120, textAlignVertical: "top" }}
          autoCapitalize="sentences"
          autoCorrect
        />
        <Text
          style={{ alignSelf: "flex-end" }}
          preset="default"
          text={`${description.length}/${MAX_DESC}`}
        />
      </View>

      {/* Radius */}
      <View style={{ gap: 6 }}>
        <Text
          text="Show my request to helpers within:"
          style={{ fontWeight: "600", opacity: 0.9 }}
        />
        <RadioGroup
          value={radiusKm}
          onChange={(v) => setRadiusKm(v as Radius)}
          options={[
            { label: "1 km", value: 1 },
            { label: "2 km", value: 2 },
            { label: "5 km", value: 5 },
          ]}
          size="md"
          gap={8}
        />
      </View>
      {/* Recorder */}
      <View style={{ flexDirection: "column", gap: 10, marginTop: 12, marginBottom: 24 }}>
        <Text text="Record Voice Note (30s max):" style={{ fontWeight: "600", opacity: 0.9 }} />
        {!recording && !uri && <Button text="Record ≤30s" onPress={onStartPress} />}
        {recording && (
          <View style={{ flexDirection: "row", alignItems: "center", gap: 8 }}>
            <ActivityIndicator />
            <Button text={`Stop (${durationSec}s)`} onPress={stop} />
          </View>
        )}
        {!recording && uri && (
          <View
            style={{
              borderWidth: 1,
              borderColor: "#e5e7eb",
              borderRadius: 12,
              padding: 12,
              backgroundColor: "#fafafa",
              gap: 10,
            }}
          >
            <Text preset="subheading" text="Preview your recording" />
            <View style={{ flexDirection: "row", alignItems: "center", gap: 12 }}>
              <Button text={isPlaying ? "Pause" : "Play"} onPress={togglePlay} />
              <Text
                text={`${playbackSecs}s / ${Math.max(durationSec, Math.ceil(playbackSecs))}s`}
              />
            </View>
            <View style={{ flexDirection: "row", gap: 8 }}>
              {!audioAccepted && (
                <Button text="Use this audio" onPress={() => setAudioAccepted(true)} />
              )}
              {audioAccepted && (
                <Text
                  text="Audio selected"
                  style={{ color: "#16a34a", fontWeight: "600", paddingVertical: 10 }}
                />
              )}
              <Button text="Discard & Re-record" onPress={discardRecording} />
            </View>
            {!audioAccepted && (
              <Text
                text={'(Audio will not be attached unless you tap "Use this audio")'}
                style={{ opacity: 0.7 }}
              />
            )}
          </View>
        )}
      </View>

      {/* Submit */}
      <Button
        text={submitting ? "Posting..." : "Post"}
        onPress={handlePost}
        disabled={submitting || !coords}
      />
    </Screen>
  )
}
===== END FILE: app/screens/CreateTaskScreen.tsx =====


===== BEGIN FILE: app/screens/DemoShowroomScreen/DemoUseCase.tsx =====
import { ReactNode } from "react"
import { TextStyle, View, ViewStyle } from "react-native"

import { Text } from "@/components/Text"
import type { TxKeyPath } from "@/i18n"
import { translate } from "@/i18n/translate"
import type { ThemedStyle } from "@/theme/types"
import { useAppTheme } from "@/theme/context"
import { $styles } from "@/theme/styles"

interface DemoUseCaseProps {
  name: TxKeyPath
  description?: TxKeyPath
  layout?: "column" | "row"
  itemStyle?: ViewStyle
  children: ReactNode
}

/**
 * @param {DemoUseCaseProps} props - The props for the `DemoUseCase` component.
 * @returns {JSX.Element} The rendered `DemoUseCase` component.
 */
export function DemoUseCase(props: DemoUseCaseProps) {
  const { name, description, children, layout = "column", itemStyle = {} } = props
  const { themed } = useAppTheme()

  return (
    <View>
      <Text style={themed($name)}>{translate(name)}</Text>
      {description && <Text style={themed($description)}>{translate(description)}</Text>}

      <View style={[itemStyle, layout === "row" && $styles.row, themed($item)]}>{children}</View>
    </View>
  )
}

const $description: ThemedStyle<TextStyle> = ({ spacing }) => ({
  marginTop: spacing.md,
})

const $item: ThemedStyle<ViewStyle> = ({ colors, spacing }) => ({
  backgroundColor: colors.palette.neutral100,
  borderRadius: 8,
  padding: spacing.lg,
  marginVertical: spacing.md,
})

const $name: ThemedStyle<TextStyle> = ({ typography }) => ({
  fontFamily: typography.primary.bold,
})

// @demo remove-file
===== END FILE: app/screens/DemoShowroomScreen/DemoUseCase.tsx =====


===== BEGIN FILE: app/screens/DemoShowroomScreen/DemoDivider.tsx =====
/* eslint-disable  react-native/no-inline-styles */
import { StyleProp, View, ViewStyle } from "react-native"

import type { ThemedStyle } from "@/theme/types"
import { useAppTheme } from "@/theme/context"

interface DemoDividerProps {
  type?: "vertical" | "horizontal"
  size?: number
  style?: StyleProp<ViewStyle>
  line?: boolean
}

/**
 * @param {DemoDividerProps} props - The props for the `DemoDivider` component.
 * @returns {JSX.Element} The rendered `DemoDivider` component.
 */
export function DemoDivider(props: DemoDividerProps) {
  const { type = "horizontal", size = 10, line = false, style: $styleOverride } = props
  const { themed } = useAppTheme()

  return (
    <View
      style={[
        $divider,
        type === "horizontal" && { height: size },
        type === "vertical" && { width: size },
        $styleOverride,
      ]}
    >
      {line && (
        <View
          style={[
            themed($line),
            type === "horizontal" && {
              width: 150,
              height: 1,
              marginStart: -75,
              marginTop: -1,
            },
            type === "vertical" && {
              height: 50,
              width: 1,
              marginTop: -25,
              marginStart: -1,
            },
          ]}
        />
      )}
    </View>
  )
}

const $divider: ViewStyle = {
  flexGrow: 0,
  flexShrink: 0,
}

const $line: ThemedStyle<ViewStyle> = ({ colors }) => ({
  backgroundColor: colors.border,
  position: "absolute",
  left: "50%",
  top: "50%",
})

// @demo remove-file
===== END FILE: app/screens/DemoShowroomScreen/DemoDivider.tsx =====


===== BEGIN FILE: app/screens/DemoShowroomScreen/SectionListWithKeyboardAwareScrollView.tsx =====
import { forwardRef, ReactElement, ReactNode, useCallback } from "react"
import { ScrollViewProps, SectionList, SectionListProps } from "react-native"
import { KeyboardAwareScrollView } from "react-native-keyboard-controller"

import { DEFAULT_BOTTOM_OFFSET } from "@/components/Screen"

type SectionType<ItemType> = {
  name: string
  description: string
  data: ItemType[]
}

type SectionListWithKeyboardAwareScrollViewProps<ItemType> = SectionListProps<ItemType> & {
  /* Optional function to pass a custom scroll component */
  renderScrollComponent?: (props: ScrollViewProps) => ReactNode
  /* Optional additional offset between TextInput bottom edge and keyboard top edge. See https://kirillzyusko.github.io/react-native-keyboard-controller/docs/api/components/keyboard-aware-scroll-view#bottomoffset */
  bottomOffset?: number
  /* The sections to be rendered in the list */
  sections: SectionType<ItemType>[]
  /* Function to render the header for each section */
  renderSectionHeader: ({ section }: { section: SectionType<ItemType> }) => React.ReactNode
}

function SectionListWithKeyboardAwareScrollView<ItemType = any>(
  {
    renderScrollComponent,
    bottomOffset = DEFAULT_BOTTOM_OFFSET,
    contentContainerStyle,
    ...props
  }: SectionListWithKeyboardAwareScrollViewProps<ItemType>,
  ref: React.Ref<SectionList<ItemType>>,
): ReactElement {
  const defaultRenderScrollComponent = useCallback(
    (props: ScrollViewProps) => (
      <KeyboardAwareScrollView
        contentContainerStyle={contentContainerStyle}
        bottomOffset={bottomOffset}
        {...props}
      />
    ),
    [contentContainerStyle, bottomOffset],
  )

  return (
    <SectionList
      {...props}
      ref={ref}
      renderScrollComponent={renderScrollComponent ?? defaultRenderScrollComponent}
    />
  )
}

export default forwardRef(SectionListWithKeyboardAwareScrollView) as <ItemType = any>(
  props: SectionListWithKeyboardAwareScrollViewProps<ItemType> & {
    ref?: React.Ref<SectionList<ItemType>>
  },
) => ReactElement

// @demo remove-file
===== END FILE: app/screens/DemoShowroomScreen/SectionListWithKeyboardAwareScrollView.tsx =====


===== BEGIN FILE: app/screens/DemoShowroomScreen/DrawerIconButton.tsx =====
import { Pressable, PressableProps, ViewStyle, Platform } from "react-native"
import { useDrawerProgress } from "react-native-drawer-layout"
import Animated, { interpolate, interpolateColor, useAnimatedStyle } from "react-native-reanimated"

import { isRTL } from "@/i18n"
import { useAppTheme } from "@/theme/context"

interface DrawerIconButtonProps extends PressableProps {}

const AnimatedPressable = Animated.createAnimatedComponent(Pressable)

/**
 * @param {DrawerIconButtonProps} props - The props for the `DrawerIconButton` component.
 * @returns {JSX.Element} The rendered `DrawerIconButton` component.
 */
export function DrawerIconButton(props: DrawerIconButtonProps) {
  const { ...PressableProps } = props
  const progress = useDrawerProgress()
  const isWeb = Platform.OS === "web"
  const {
    theme: { colors },
    themed,
  } = useAppTheme()

  const animatedContainerStyles = useAnimatedStyle(() => {
    const translateX = interpolate(progress.value, [0, 1], [0, isRTL ? 60 : -60])

    return {
      transform: [{ translateX }],
    }
  })

  const animatedTopBarStyles = useAnimatedStyle(() => {
    const backgroundColor = interpolateColor(progress.value, [0, 1], [colors.text, colors.tint])
    const marginStart = interpolate(progress.value, [0, 1], [0, -11.5])
    const rotate = interpolate(progress.value, [0, 1], [0, isRTL ? 45 : -45])
    const marginBottom = interpolate(progress.value, [0, 1], [0, -2])
    const width = interpolate(progress.value, [0, 1], [18, 12])
    const marginHorizontal =
      isWeb && isRTL
        ? { marginRight: marginStart }
        : {
            marginLeft: marginStart,
          }

    return {
      ...marginHorizontal,
      backgroundColor,
      marginBottom,
      width,
      transform: [{ rotate: `${rotate}deg` }],
    }
  })

  const animatedMiddleBarStyles = useAnimatedStyle(() => {
    const backgroundColor = interpolateColor(progress.value, [0, 1], [colors.text, colors.tint])
    const width = interpolate(progress.value, [0, 1], [18, 16])

    return {
      backgroundColor,
      width,
    }
  })

  const animatedBottomBarStyles = useAnimatedStyle(() => {
    const marginTop = interpolate(progress.value, [0, 1], [4, 2])
    const backgroundColor = interpolateColor(progress.value, [0, 1], [colors.text, colors.tint])
    const marginStart = interpolate(progress.value, [0, 1], [0, -11.5])
    const rotate = interpolate(progress.value, [0, 1], [0, isRTL ? -45 : 45])
    const width = interpolate(progress.value, [0, 1], [18, 12])
    const marginHorizontal =
      isWeb && isRTL
        ? { marginRight: marginStart }
        : {
            marginLeft: marginStart,
          }

    return {
      ...marginHorizontal,
      backgroundColor,
      width,
      marginTop,
      transform: [{ rotate: `${rotate}deg` }],
    }
  })

  return (
    <AnimatedPressable {...PressableProps} style={[$container, animatedContainerStyles]}>
      <Animated.View style={[$topBar, animatedTopBarStyles]} />

      <Animated.View style={[themed($middleBar), animatedMiddleBarStyles]} />

      <Animated.View style={[$bottomBar, animatedBottomBarStyles]} />
    </AnimatedPressable>
  )
}

const barHeight = 2

const $container: ViewStyle = {
  alignItems: "center",
  height: 56,
  justifyContent: "center",
  width: 56,
}

const $topBar: ViewStyle = {
  height: barHeight,
}

const $middleBar: ViewStyle = {
  height: barHeight,
  marginTop: 4,
}

const $bottomBar: ViewStyle = {
  height: barHeight,
}

// @demo remove-file
===== END FILE: app/screens/DemoShowroomScreen/DrawerIconButton.tsx =====


===== BEGIN FILE: app/screens/DemoShowroomScreen/DemoShowroomScreen.tsx =====
import { FC, ReactElement, useCallback, useEffect, useRef, useState } from "react"
import {
  FlatList,
  Image,
  ImageStyle,
  Platform,
  SectionList,
  TextStyle,
  View,
  ViewStyle,
} from "react-native"
import { Link, RouteProp, useRoute } from "@react-navigation/native"
import { Drawer } from "react-native-drawer-layout"

import { ListItem } from "@/components/ListItem"
import { Screen } from "@/components/Screen"
import { Text } from "@/components/Text"
import { TxKeyPath, isRTL } from "@/i18n"
import { translate } from "@/i18n/translate"
import { DemoTabParamList, DemoTabScreenProps } from "@/navigators/DemoNavigator"
import type { Theme, ThemedStyle } from "@/theme/types"
import { useAppTheme } from "@/theme/context"
import { $styles } from "@/theme/styles"
import { hasValidStringProp } from "@/utils/hasValidStringProp"
import { useSafeAreaInsetsStyle } from "@/utils/useSafeAreaInsetsStyle"

import * as Demos from "./demos"
import { DrawerIconButton } from "./DrawerIconButton"
import SectionListWithKeyboardAwareScrollView from "./SectionListWithKeyboardAwareScrollView"

const logo = require("@assets/images/logo.png")

export interface Demo {
  name: string
  description: TxKeyPath
  data: ({ themed, theme }: { themed: any; theme: Theme }) => ReactElement[]
}

interface DemoListItem {
  item: { name: string; useCases: string[] }
  sectionIndex: number
  handleScroll?: (sectionIndex: number, itemIndex?: number) => void
}

const slugify = (str: string) =>
  str
    .toLowerCase()
    .trim()
    .replace(/[^\w\s-]/g, "")
    .replace(/[\s_-]+/g, "-")
    .replace(/^-+|-+$/g, "")

const WebListItem: FC<DemoListItem> = ({ item, sectionIndex }) => {
  const sectionSlug = item.name.toLowerCase()
  const { themed } = useAppTheme()
  return (
    <View>
      <Link
        screen="DemoShowroom"
        params={{ queryIndex: sectionSlug }}
        style={themed($menuContainer)}
      >
        <Text preset="bold">{item.name}</Text>
      </Link>
      {item.useCases.map((u) => {
        const itemSlug = slugify(u)

        return (
          <Link
            key={`section${sectionIndex}-${u}`}
            screen="DemoShowroom"
            params={{ queryIndex: sectionSlug, itemIndex: itemSlug }}
          >
            <Text>{u}</Text>
          </Link>
        )
      })}
    </View>
  )
}

const NativeListItem: FC<DemoListItem> = ({ item, sectionIndex, handleScroll }) => {
  const { themed } = useAppTheme()
  return (
    <View>
      <Text
        onPress={() => handleScroll?.(sectionIndex)}
        preset="bold"
        style={themed($menuContainer)}
      >
        {item.name}
      </Text>
      {item.useCases.map((u, index) => (
        <ListItem
          key={`section${sectionIndex}-${u}`}
          onPress={() => handleScroll?.(sectionIndex, index)}
          text={u}
          rightIcon={isRTL ? "caretLeft" : "caretRight"}
        />
      ))}
    </View>
  )
}

const ShowroomListItem = Platform.select({ web: WebListItem, default: NativeListItem })
const isAndroid = Platform.OS === "android"

export const DemoShowroomScreen: FC<DemoTabScreenProps<"DemoShowroom">> =
  function DemoShowroomScreen(_props) {
    const [open, setOpen] = useState(false)
    const timeout = useRef<ReturnType<typeof setTimeout>>(null)
    const listRef = useRef<SectionList>(null)
    const menuRef = useRef<FlatList<DemoListItem["item"]>>(null)
    const route = useRoute<RouteProp<DemoTabParamList, "DemoShowroom">>()
    const params = route.params

    const { themed, theme } = useAppTheme()

    const toggleDrawer = useCallback(() => {
      if (!open) {
        setOpen(true)
      } else {
        setOpen(false)
      }
    }, [open])

    const handleScroll = useCallback((sectionIndex: number, itemIndex = 0) => {
      try {
        listRef.current?.scrollToLocation({
          animated: true,
          itemIndex,
          sectionIndex,
          viewPosition: 0.25,
        })
      } catch (e) {
        console.error(e)
      }
    }, [])

    // handle Web links
    useEffect(() => {
      if (params !== undefined && Object.keys(params).length > 0) {
        const demoValues = Object.values(Demos)
        const findSectionIndex = demoValues.findIndex(
          (x) => x.name.toLowerCase() === params.queryIndex,
        )
        let findItemIndex = 0
        if (params.itemIndex) {
          try {
            findItemIndex = demoValues[findSectionIndex].data({ themed, theme }).findIndex((u) => {
              if (hasValidStringProp(u.props, "name")) {
                return (
                  slugify(translate((u.props as { name: TxKeyPath }).name)) === params.itemIndex
                )
              }
              return false
            })
          } catch (err) {
            console.error(err)
          }
        }
        handleScroll(findSectionIndex, findItemIndex)
      }
    }, [handleScroll, params, theme, themed])

    const scrollToIndexFailed = (info: {
      index: number
      highestMeasuredFrameIndex: number
      averageItemLength: number
    }) => {
      listRef.current?.getScrollResponder()?.scrollToEnd()
      timeout.current = setTimeout(
        () =>
          listRef.current?.scrollToLocation({
            animated: true,
            itemIndex: info.index,
            sectionIndex: 0,
          }),
        50,
      )
    }

    useEffect(() => {
      return () => {
        if (timeout.current) {
          clearTimeout(timeout.current)
        }
      }
    }, [])

    const $drawerInsets = useSafeAreaInsetsStyle(["top"])

    return (
      <Drawer
        open={open}
        onOpen={() => setOpen(true)}
        onClose={() => setOpen(false)}
        drawerType="back"
        drawerPosition={isRTL ? "right" : "left"}
        renderDrawerContent={() => (
          <View style={themed([$drawer, $drawerInsets])}>
            <View style={themed($logoContainer)}>
              <Image source={logo} style={$logoImage} />
            </View>
            <FlatList<DemoListItem["item"]>
              ref={menuRef}
              contentContainerStyle={themed($listContentContainer)}
              data={Object.values(Demos).map((d) => ({
                name: d.name,
                useCases: d.data({ theme, themed }).map((u) => {
                  if (hasValidStringProp(u.props, "name")) {
                    return translate((u.props as { name: TxKeyPath }).name)
                  }
                  return ""
                }),
              }))}
              keyExtractor={(item) => item.name}
              renderItem={({ item, index: sectionIndex }) => (
                <ShowroomListItem {...{ item, sectionIndex, handleScroll }} />
              )}
            />
          </View>
        )}
      >
        <Screen
          preset="fixed"
          safeAreaEdges={["top"]}
          contentContainerStyle={$styles.flex1}
          {...(isAndroid ? { KeyboardAvoidingViewProps: { behavior: undefined } } : {})}
        >
          <DrawerIconButton onPress={toggleDrawer} />

          <SectionListWithKeyboardAwareScrollView
            ref={listRef}
            contentContainerStyle={themed($sectionListContentContainer)}
            stickySectionHeadersEnabled={false}
            sections={Object.values(Demos).map((d) => ({
              name: d.name,
              description: d.description,
              data: [d.data({ theme, themed })],
            }))}
            renderItem={({ item, index: sectionIndex }) => (
              <View>
                {item.map((demo: ReactElement, demoIndex: number) => (
                  <View key={`${sectionIndex}-${demoIndex}`}>{demo}</View>
                ))}
              </View>
            )}
            renderSectionFooter={() => <View style={themed($demoUseCasesSpacer)} />}
            ListHeaderComponent={
              <View style={themed($heading)}>
                <Text preset="heading" tx="demoShowroomScreen:jumpStart" />
              </View>
            }
            onScrollToIndexFailed={scrollToIndexFailed}
            renderSectionHeader={({ section }) => {
              return (
                <View>
                  <Text preset="heading" style={themed($demoItemName)}>
                    {section.name}
                  </Text>
                  <Text style={themed($demoItemDescription)}>{translate(section.description)}</Text>
                </View>
              )
            }}
          />
        </Screen>
      </Drawer>
    )
  }

const $drawer: ThemedStyle<ViewStyle> = ({ colors }) => ({
  backgroundColor: colors.background,
  flex: 1,
})

const $listContentContainer: ThemedStyle<ViewStyle> = ({ spacing }) => ({
  paddingHorizontal: spacing.lg,
})

const $sectionListContentContainer: ThemedStyle<ViewStyle> = ({ spacing }) => ({
  paddingHorizontal: spacing.lg,
})

const $heading: ThemedStyle<ViewStyle> = ({ spacing }) => ({
  marginBottom: spacing.xxxl,
})

const $logoImage: ImageStyle = {
  height: 42,
  width: 77,
}

const $logoContainer: ThemedStyle<ViewStyle> = ({ spacing }) => ({
  alignSelf: "flex-start",
  justifyContent: "center",
  height: 56,
  paddingHorizontal: spacing.lg,
})

const $menuContainer: ThemedStyle<ViewStyle> = ({ spacing }) => ({
  paddingBottom: spacing.xs,
  paddingTop: spacing.lg,
})

const $demoItemName: ThemedStyle<TextStyle> = ({ spacing }) => ({
  fontSize: 24,
  marginBottom: spacing.md,
})

const $demoItemDescription: ThemedStyle<TextStyle> = ({ spacing }) => ({
  marginBottom: spacing.xxl,
})

const $demoUseCasesSpacer: ThemedStyle<ViewStyle> = ({ spacing }) => ({
  paddingBottom: spacing.xxl,
})

// @demo remove-file
===== END FILE: app/screens/DemoShowroomScreen/DemoShowroomScreen.tsx =====


===== BEGIN FILE: app/screens/DemoShowroomScreen/demos/DemoText.tsx =====
/* eslint-disable react/jsx-key, react-native/no-inline-styles */
import { Text } from "@/components/Text"
import { translate } from "@/i18n/translate"

import { DemoDivider } from "../DemoDivider"
import { Demo } from "../DemoShowroomScreen"
import { DemoUseCase } from "../DemoUseCase"

export const DemoText: Demo = {
  name: "Text",
  description: "demoText:description",
  data: ({ theme }) => [
    <DemoUseCase
      name="demoText:useCase.presets.name"
      description="demoText:useCase.presets.description"
    >
      <Text>{translate("demoText:useCase.presets.default")}</Text>

      <DemoDivider />

      <Text preset="bold">{translate("demoText:useCase.presets.bold")}</Text>

      <DemoDivider />

      <Text preset="subheading">{translate("demoText:useCase.presets.subheading")}</Text>

      <DemoDivider />

      <Text preset="heading">{translate("demoText:useCase.presets.heading")}</Text>
    </DemoUseCase>,

    <DemoUseCase
      name="demoText:useCase.sizes.name"
      description="demoText:useCase.sizes.description"
    >
      <Text size="xs">{translate("demoText:useCase.sizes.xs")}</Text>

      <DemoDivider />

      <Text size="sm">{translate("demoText:useCase.sizes.sm")}</Text>

      <DemoDivider />

      <Text size="md">{translate("demoText:useCase.sizes.md")}</Text>

      <DemoDivider />

      <Text size="lg">{translate("demoText:useCase.sizes.lg")}</Text>

      <DemoDivider />

      <Text size="xl">{translate("demoText:useCase.sizes.xl")}</Text>

      <DemoDivider />

      <Text size="xxl">{translate("demoText:useCase.sizes.xxl")}</Text>
    </DemoUseCase>,

    <DemoUseCase
      name="demoText:useCase.weights.name"
      description="demoText:useCase.weights.description"
    >
      <Text weight="light">{translate("demoText:useCase.weights.light")}</Text>

      <DemoDivider />

      <Text weight="normal">{translate("demoText:useCase.weights.normal")}</Text>

      <DemoDivider />

      <Text weight="medium">{translate("demoText:useCase.weights.medium")}</Text>

      <DemoDivider />

      <Text weight="semiBold">{translate("demoText:useCase.weights.semibold")}</Text>

      <DemoDivider />

      <Text weight="bold">{translate("demoText:useCase.weights.bold")}</Text>
    </DemoUseCase>,

    <DemoUseCase
      name="demoText:useCase.passingContent.name"
      description="demoText:useCase.passingContent.description"
    >
      <Text text={translate("demoText:useCase.passingContent.viaText")} />

      <DemoDivider />

      <Text>
        <Text tx="demoText:useCase.passingContent.viaTx" />
        <Text tx="demoShowroomScreen:lorem2Sentences" />
      </Text>

      <DemoDivider />

      <Text>{translate("demoText:useCase.passingContent.children")}</Text>

      <DemoDivider />

      <Text>
        <Text>{translate("demoText:useCase.passingContent.nestedChildren")}</Text>
        <Text preset="bold">{translate("demoText:useCase.passingContent.nestedChildren2")}</Text>
        {` `}
        <Text preset="default">{translate("demoText:useCase.passingContent.nestedChildren3")}</Text>
        {` `}
        <Text preset="bold"> {translate("demoText:useCase.passingContent.nestedChildren4")}</Text>
      </Text>
    </DemoUseCase>,

    <DemoUseCase
      name="demoText:useCase.styling.name"
      description="demoText:useCase.styling.description"
    >
      <Text>
        <Text style={{ color: theme.colors.error }}>
          {translate("demoText:useCase.styling.text")}
        </Text>
        {` `}
        <Text
          style={{
            color: theme.colors.palette.neutral100,
            backgroundColor: theme.colors.error,
          }}
        >
          {translate("demoText:useCase.styling.text2")}
        </Text>
        {` `}
        <Text
          style={{
            textDecorationLine: "underline line-through",
            textDecorationStyle: "dashed",
            color: theme.colors.error,
            textDecorationColor: theme.colors.error,
          }}
        >
          {translate("demoText:useCase.styling.text3")}
        </Text>
      </Text>
    </DemoUseCase>,
  ],
}

// @demo remove-file
===== END FILE: app/screens/DemoShowroomScreen/demos/DemoText.tsx =====


===== BEGIN FILE: app/screens/DemoShowroomScreen/demos/DemoAutoImage.tsx =====
/* eslint-disable react/jsx-key, react-native/no-inline-styles */
import { Image, ImageStyle, TextStyle, View, ViewStyle } from "react-native"

import { AutoImage } from "@/components/AutoImage"
import { Text } from "@/components/Text"
import { translate } from "@/i18n/translate"
import type { ThemedStyle } from "@/theme/types"
import { $styles } from "@/theme/styles"

import { DemoDivider } from "../DemoDivider"
import { Demo } from "../DemoShowroomScreen"
import { DemoUseCase } from "../DemoUseCase"

const $imageContainer: ViewStyle = {
  alignItems: "center",
}

const $aspectRatioDescription: ThemedStyle<TextStyle> = ({ spacing }) => ({
  textAlign: "center",
  width: "100%",
  marginTop: spacing.xs,
})

const $aspectRatioWidthExampleContainer: ViewStyle = {
  justifyContent: "space-between",
}

const $aspectRatioHeightExampleContainer: ViewStyle = {
  alignItems: "stretch",
  justifyContent: "space-between",
  height: 130,
}

const $aspectRatioBox: ThemedStyle<ViewStyle & ImageStyle> = (theme) => ({
  borderRadius: 4,
  borderWidth: 3,
  borderColor: theme.colors.palette.secondary300,
  backgroundColor: theme.colors.palette.neutral800,
})

export const DemoAutoImage: Demo = {
  name: "AutoImage",
  description: "demoAutoImage:description",
  data: ({ theme, themed }) => [
    <DemoUseCase name="demoAutoImage:useCase.remoteUri.name">
      <View style={$imageContainer}>
        <AutoImage
          source={{
            uri: "https://user-images.githubusercontent.com/1775841/184508739-f90d0ce5-7219-42fd-a91f-3382d016eae0.png",
          }}
        />
      </View>
    </DemoUseCase>,

    <DemoUseCase name="demoAutoImage:useCase.base64Uri.name">
      <View style={$imageContainer}>
        <AutoImage
          source={{
            uri: `data:image/png;base64,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`,
          }}
        />
      </View>
    </DemoUseCase>,

    <DemoUseCase
      name="demoAutoImage:useCase.scaledToFitDimensions.name"
      description="demoAutoImage:useCase.scaledToFitDimensions.description"
    >
      <View style={[$styles.row, $aspectRatioWidthExampleContainer]}>
        <Text
          text="<View />"
          size="xxs"
          weight="bold"
          style={{ flexBasis: "33.3333%", color: theme.colors.palette.secondary400 }}
        />
        <Text
          text="<Image />"
          size="xxs"
          weight="bold"
          style={{
            flexBasis: "33.3333%",
            textAlign: "center",
            color: theme.colors.palette.secondary400,
          }}
        />
        <Text
          text="<AutoImage />"
          size="xxs"
          weight="bold"
          style={{
            flexBasis: "33.3333%",
            textAlign: "right",
            color: theme.colors.palette.secondary400,
          }}
        />
      </View>

      <DemoDivider size={5} />

      <View style={[$styles.row, $aspectRatioWidthExampleContainer, { height: 80 }]}>
        <View style={themed([$aspectRatioBox, { width: 60 }])} />
        <Image
          source={{
            uri: "https://user-images.githubusercontent.com/1775841/188244137-a35ab1b9-658d-4701-b1dd-7caa51173fa9.png",
          }}
          style={themed([$aspectRatioBox, { width: 60 }])}
          resizeMode="contain"
        />
        <AutoImage
          maxWidth={60}
          style={themed($aspectRatioBox)}
          source={{
            uri: "https://user-images.githubusercontent.com/1775841/188244137-a35ab1b9-658d-4701-b1dd-7caa51173fa9.png",
          }}
        />
      </View>

      <Text weight="bold" size="xs" style={themed($aspectRatioDescription)}>
        {translate("demoAutoImage:useCase.scaledToFitDimensions.heightAuto")}
      </Text>

      <DemoDivider size={40} />

      <View style={$styles.row}>
        <View style={$aspectRatioHeightExampleContainer}>
          <Text
            text="<View />"
            size="xxs"
            weight="bold"
            style={{ color: theme.colors.palette.secondary400 }}
          />
          <Text
            text="<Image />"
            size="xxs"
            weight="bold"
            style={{ color: theme.colors.palette.secondary400 }}
          />
          <Text
            text="<AutoImage />"
            size="xxs"
            weight="bold"
            style={{ color: theme.colors.palette.secondary400 }}
          />
        </View>

        <View
          style={[$aspectRatioHeightExampleContainer, { flex: 1, marginStart: theme.spacing.sm }]}
        >
          <View style={themed([$aspectRatioBox, { height: 32 }])} />
          <Image
            source={{
              uri: "https://user-images.githubusercontent.com/1775841/188244137-a35ab1b9-658d-4701-b1dd-7caa51173fa9.png",
            }}
            style={themed([$aspectRatioBox, { height: 32 }])}
            resizeMode="contain"
          />
          <AutoImage
            maxHeight={32}
            style={themed([$aspectRatioBox, { alignSelf: "center" }])}
            source={{
              uri: "https://user-images.githubusercontent.com/1775841/188244137-a35ab1b9-658d-4701-b1dd-7caa51173fa9.png",
            }}
          />
        </View>
      </View>

      <Text weight="bold" size="xs" style={themed($aspectRatioDescription)}>
        {translate("demoAutoImage:useCase.scaledToFitDimensions.widthAuto")}
      </Text>

      <DemoDivider size={40} />

      <View style={[$styles.row, $aspectRatioWidthExampleContainer]}>
        <Text
          text="<View />"
          size="xxs"
          weight="bold"
          style={{ flexBasis: "33.3333%", color: theme.colors.palette.secondary400 }}
        />
        <Text
          text="<Image />"
          size="xxs"
          weight="bold"
          style={{
            flexBasis: "33.3333%",
            textAlign: "center",
            color: theme.colors.palette.secondary400,
          }}
        />
        <Text
          text="<AutoImage />"
          size="xxs"
          weight="bold"
          style={{
            flexBasis: "33.3333%",
            textAlign: "right",
            color: theme.colors.palette.secondary400,
          }}
        />
      </View>

      <DemoDivider size={5} />

      <View style={[$styles.row, $aspectRatioWidthExampleContainer]}>
        <View style={themed([$aspectRatioBox, { width: 60, height: 60 }])} />
        <Image
          source={{
            uri: "https://user-images.githubusercontent.com/1775841/188244137-a35ab1b9-658d-4701-b1dd-7caa51173fa9.png",
          }}
          style={themed([$aspectRatioBox, { width: 60, height: 60 }])}
          resizeMode="contain"
        />
        <AutoImage
          maxWidth={60}
          maxHeight={60}
          style={themed($aspectRatioBox)}
          source={{
            uri: "https://user-images.githubusercontent.com/1775841/188244137-a35ab1b9-658d-4701-b1dd-7caa51173fa9.png",
          }}
        />
      </View>

      <Text weight="bold" size="xs" style={themed($aspectRatioDescription)}>
        {translate("demoAutoImage:useCase.scaledToFitDimensions.bothManual")}
      </Text>
    </DemoUseCase>,
  ],
}

// @demo remove-file
===== END FILE: app/screens/DemoShowroomScreen/demos/DemoAutoImage.tsx =====


===== BEGIN FILE: app/screens/DemoShowroomScreen/demos/DemoEmptyState.tsx =====
/* eslint-disable react/jsx-key, react-native/no-inline-styles */
import { EmptyState } from "@/components/EmptyState"

import { DemoDivider } from "../DemoDivider"
import { Demo } from "../DemoShowroomScreen"
import { DemoUseCase } from "../DemoUseCase"

export const DemoEmptyState: Demo = {
  name: "EmptyState",
  description: "demoEmptyState:description",
  data: ({ theme }) => [
    <DemoUseCase
      name="demoEmptyState:useCase.presets.name"
      description="demoEmptyState:useCase.presets.description"
    >
      <EmptyState preset="generic" />
    </DemoUseCase>,

    <DemoUseCase
      name="demoEmptyState:useCase.passingContent.name"
      description="demoEmptyState:useCase.passingContent.description"
    >
      <EmptyState
        imageSource={require("@assets/images/logo.png")}
        headingTx="demoEmptyState:useCase.passingContent.customizeImageHeading"
        contentTx="demoEmptyState:useCase.passingContent.customizeImageContent"
      />

      <DemoDivider size={30} line />

      <EmptyState
        headingTx="demoEmptyState:useCase.passingContent.viaHeadingProp"
        contentTx="demoEmptyState:useCase.passingContent.viaContentProp"
        buttonTx="demoEmptyState:useCase.passingContent.viaButtonProp"
      />

      <DemoDivider size={30} line />

      <EmptyState
        headingTx="demoShowroomScreen:demoViaSpecifiedTxProp"
        headingTxOptions={{ prop: "heading" }}
        contentTx="demoShowroomScreen:demoViaSpecifiedTxProp"
        contentTxOptions={{ prop: "content" }}
        buttonTx="demoShowroomScreen:demoViaSpecifiedTxProp"
        buttonTxOptions={{ prop: "button" }}
      />
    </DemoUseCase>,

    <DemoUseCase
      name="demoEmptyState:useCase.styling.name"
      description="demoEmptyState:useCase.styling.description"
    >
      <EmptyState
        preset="generic"
        style={{ backgroundColor: theme.colors.error, paddingVertical: 20 }}
        imageStyle={{ height: 75, tintColor: theme.colors.palette.neutral100 }}
        ImageProps={{ resizeMode: "contain" }}
        headingStyle={{
          color: theme.colors.palette.neutral100,
          textDecorationLine: "underline",
          textDecorationColor: theme.colors.palette.neutral100,
        }}
        contentStyle={{
          color: theme.colors.palette.neutral100,
          textDecorationLine: "underline",
          textDecorationColor: theme.colors.palette.neutral100,
        }}
        buttonStyle={{ alignSelf: "center", backgroundColor: theme.colors.palette.neutral100 }}
        buttonTextStyle={{ color: theme.colors.error }}
        ButtonProps={{
          preset: "reversed",
        }}
      />
    </DemoUseCase>,
  ],
}

// @demo remove-file
===== END FILE: app/screens/DemoShowroomScreen/demos/DemoEmptyState.tsx =====


===== BEGIN FILE: app/screens/DemoShowroomScreen/demos/DemoHeader.tsx =====
/* eslint-disable react/jsx-key, react-native/no-inline-styles */
import { TextStyle, View, ViewStyle } from "react-native"

import { Header } from "@/components/Header"
import { Icon } from "@/components/Icon"
import type { ThemedStyle } from "@/theme/types"
import { $styles } from "@/theme/styles"

import { DemoDivider } from "../DemoDivider"
import { Demo } from "../DemoShowroomScreen"
import { DemoUseCase } from "../DemoUseCase"

const $rightAlignTitle: TextStyle = {
  textAlign: "right",
}

const $customLeftAction: ThemedStyle<ViewStyle> = ({ colors }) => ({
  backgroundColor: colors.error,
  flexGrow: 0,
  flexBasis: 100,
  height: "100%",
  flexWrap: "wrap",
  overflow: "hidden",
})

const $customTitle: ThemedStyle<TextStyle> = ({ colors }) => ({
  textDecorationLine: "underline line-through",
  textDecorationStyle: "dashed",
  color: colors.error,
  textDecorationColor: colors.error,
})

const $customWhiteTitle: ThemedStyle<TextStyle> = ({ colors }) => ({
  color: colors.palette.neutral100,
})

export const DemoHeader: Demo = {
  name: "Header",
  description: "demoHeader:description",
  data: ({ theme, themed }) => [
    <DemoUseCase
      name="demoHeader:useCase.actionIcons.name"
      description="demoHeader:useCase.actionIcons.description"
    >
      <Header
        titleTx="demoHeader:useCase.actionIcons.leftIconTitle"
        leftIcon="ladybug"
        safeAreaEdges={[]}
      />
      <DemoDivider size={24} />
      <Header
        titleTx="demoHeader:useCase.actionIcons.rightIconTitle"
        rightIcon="ladybug"
        safeAreaEdges={[]}
      />
      <DemoDivider size={24} />
      <Header
        titleTx="demoHeader:useCase.actionIcons.bothIconsTitle"
        leftIcon="ladybug"
        rightIcon="ladybug"
        safeAreaEdges={[]}
      />
    </DemoUseCase>,

    <DemoUseCase
      name="demoHeader:useCase.actionText.name"
      description="demoHeader:useCase.actionText.description"
    >
      <Header
        titleTx="demoHeader:useCase.actionText.leftTxTitle"
        leftTx="demoShowroomScreen:demoHeaderTxExample"
        safeAreaEdges={[]}
      />
      <DemoDivider size={24} />
      <Header
        titleTx="demoHeader:useCase.actionText.rightTextTitle"
        rightText="Yay"
        safeAreaEdges={[]}
      />
    </DemoUseCase>,

    <DemoUseCase
      name="demoHeader:useCase.customActionComponents.name"
      description="demoHeader:useCase.customActionComponents.description"
    >
      <Header
        titleTx="demoHeader:useCase.customActionComponents.customLeftActionTitle"
        titleMode="flex"
        titleStyle={$rightAlignTitle}
        LeftActionComponent={
          <View style={themed([$styles.row, $customLeftAction])}>
            {Array.from({ length: 20 }, (x, i) => i).map((i) => (
              <Icon key={i} icon="ladybug" color={theme.colors.palette.neutral100} size={20} />
            ))}
          </View>
        }
        safeAreaEdges={[]}
      />
    </DemoUseCase>,

    <DemoUseCase
      name="demoHeader:useCase.titleModes.name"
      description="demoHeader:useCase.titleModes.description"
    >
      <Header
        titleTx="demoHeader:useCase.titleModes.centeredTitle"
        leftIcon="ladybug"
        rightText="Hooray"
        safeAreaEdges={[]}
      />
      <DemoDivider size={24} />
      <Header
        titleTx="demoHeader:useCase.titleModes.flexTitle"
        titleMode="flex"
        leftIcon="ladybug"
        rightText="Hooray"
        safeAreaEdges={[]}
      />
    </DemoUseCase>,

    <DemoUseCase
      name="demoHeader:useCase.styling.name"
      description="demoHeader:useCase.styling.description"
    >
      <Header
        titleTx="demoHeader:useCase.styling.styledTitle"
        titleStyle={themed($customTitle)}
        safeAreaEdges={[]}
      />
      <DemoDivider size={24} />
      <Header
        titleTx="demoHeader:useCase.styling.styledWrapperTitle"
        titleStyle={themed($customWhiteTitle)}
        backgroundColor={theme.colors.error}
        style={{ height: 35 }}
        safeAreaEdges={[]}
      />
      <DemoDivider size={24} />
      <Header
        titleTx="demoHeader:useCase.styling.tintedIconsTitle"
        titleStyle={themed($customWhiteTitle)}
        backgroundColor={theme.colors.error}
        leftIcon="ladybug"
        leftIconColor={theme.colors.palette.neutral100}
        safeAreaEdges={[]}
      />
    </DemoUseCase>,
  ],
}

// @demo remove-file
===== END FILE: app/screens/DemoShowroomScreen/demos/DemoHeader.tsx =====


===== BEGIN FILE: app/screens/DemoShowroomScreen/demos/DemoListItem.tsx =====
/* eslint-disable react/jsx-key */
import { TextStyle, View, ViewStyle } from "react-native"
import { FlatList } from "react-native-gesture-handler"

import { Icon } from "@/components/Icon"
import { ListItem } from "@/components/ListItem"
import { Text } from "@/components/Text"
import { translate } from "@/i18n/translate"
import type { ThemedStyle } from "@/theme/types"
import { $styles } from "@/theme/styles"

import { DemoDivider } from "../DemoDivider"
import { Demo } from "../DemoShowroomScreen"
import { DemoUseCase } from "../DemoUseCase"

const listData =
  `Tempor Id Ea Aliqua Pariatur Aliquip. Irure Minim Voluptate Consectetur Consequat Sint Esse Proident Irure. Nostrud Elit Veniam Nostrud Excepteur Minim Deserunt Quis Dolore Velit Nulla Irure Voluptate Tempor. Occaecat Amet Laboris Nostrud Qui Do Quis Lorem Ex Elit Fugiat Deserunt. In Pariatur Excepteur Exercitation Ex Incididunt Qui Mollit Dolor Sit Non. Culpa Officia Minim Cillum Exercitation Voluptate Proident Laboris Et Est Reprehenderit Quis Pariatur Nisi`
    .split(".")
    .map((item) => item.trim())

const $customLeft: ThemedStyle<ViewStyle> = ({ colors }) => ({
  backgroundColor: colors.error,
  flexGrow: 0,
  flexBasis: 60,
  height: "100%",
  flexWrap: "wrap",
  overflow: "hidden",
})

const $customTextStyle: ThemedStyle<TextStyle> = ({ colors }) => ({
  color: colors.error,
})

const $customTouchableStyle: ThemedStyle<ViewStyle> = ({ colors }) => ({
  backgroundColor: colors.error,
})

const $customContainerStyle: ThemedStyle<ViewStyle> = ({ colors }) => ({
  borderTopWidth: 5,
  borderTopColor: colors.palette.neutral100,
})

const $listStyle: ThemedStyle<ViewStyle> = ({ colors, spacing }) => ({
  height: 148,
  paddingHorizontal: spacing.xs,
  backgroundColor: colors.palette.neutral200,
})

export const DemoListItem: Demo = {
  name: "ListItem",
  description: "demoListItem:description",
  data: ({ theme, themed }) => [
    <DemoUseCase
      name="demoListItem:useCase.height.name"
      description="demoListItem:useCase.height.description"
    >
      <ListItem topSeparator>{translate("demoListItem:useCase.height.defaultHeight")}</ListItem>

      <ListItem topSeparator height={100}>
        {translate("demoListItem:useCase.height.customHeight")}
      </ListItem>

      <ListItem topSeparator>{translate("demoListItem:useCase.height.textHeight")}</ListItem>

      <ListItem topSeparator bottomSeparator TextProps={{ numberOfLines: 1 }}>
        {translate("demoListItem:useCase.height.longText")}
      </ListItem>
    </DemoUseCase>,

    <DemoUseCase
      name="demoListItem:useCase.separators.name"
      description="demoListItem:useCase.separators.description"
    >
      <ListItem topSeparator>{translate("demoListItem:useCase.separators.topSeparator")}</ListItem>

      <DemoDivider size={40} />

      <ListItem topSeparator bottomSeparator>
        {translate("demoListItem:useCase.separators.topAndBottomSeparator")}
      </ListItem>

      <DemoDivider size={40} />

      <ListItem bottomSeparator>
        {translate("demoListItem:useCase.separators.bottomSeparator")}
      </ListItem>
    </DemoUseCase>,

    <DemoUseCase
      name="demoListItem:useCase.icons.name"
      description="demoListItem:useCase.icons.description"
    >
      <ListItem topSeparator leftIcon="ladybug">
        {translate("demoListItem:useCase.icons.leftIcon")}
      </ListItem>

      <ListItem topSeparator rightIcon="ladybug">
        {translate("demoListItem:useCase.icons.rightIcon")}
      </ListItem>

      <ListItem topSeparator bottomSeparator rightIcon="ladybug" leftIcon="ladybug">
        {translate("demoListItem:useCase.icons.leftRightIcons")}
      </ListItem>
    </DemoUseCase>,

    <DemoUseCase
      name="demoListItem:useCase.customLeftRight.name"
      description="demoListItem:useCase.customLeftRight.description"
    >
      <ListItem
        topSeparator
        LeftComponent={
          <View style={themed([$styles.row, $customLeft, { marginEnd: theme.spacing.md }])}>
            {Array.from({ length: 9 }, (x, i) => i).map((i) => (
              <Icon key={i} icon="ladybug" color={theme.colors.palette.neutral100} size={20} />
            ))}
          </View>
        }
      >
        {translate("demoListItem:useCase.customLeftRight.customLeft")}
      </ListItem>

      <ListItem
        topSeparator
        bottomSeparator
        RightComponent={
          <View style={themed([$styles.row, $customLeft, { marginStart: theme.spacing.md }])}>
            {Array.from({ length: 9 }, (x, i) => i).map((i) => (
              <Icon key={i} icon="ladybug" color={theme.colors.palette.neutral100} size={20} />
            ))}
          </View>
        }
      >
        {translate("demoListItem:useCase.customLeftRight.customRight")}
      </ListItem>
    </DemoUseCase>,

    <DemoUseCase
      name="demoListItem:useCase.passingContent.name"
      description="demoListItem:useCase.passingContent.description"
    >
      <ListItem topSeparator text={translate("demoListItem:useCase.passingContent.children")} />
      <ListItem topSeparator tx="demoShowroomScreen:demoViaTxProp" />
      <ListItem topSeparator>{translate("demoListItem:useCase.passingContent.children")}</ListItem>
      <ListItem topSeparator bottomSeparator>
        <Text>
          <Text preset="bold">
            {translate("demoListItem:useCase.passingContent.nestedChildren1")}
          </Text>
          {` `}
          <Text preset="default">
            {translate("demoListItem:useCase.passingContent.nestedChildren2")}
          </Text>
        </Text>
      </ListItem>
    </DemoUseCase>,

    <DemoUseCase
      name="demoListItem:useCase.listIntegration.name"
      description="demoListItem:useCase.listIntegration.description"
    >
      <View style={themed($listStyle)}>
        <FlatList<string>
          data={listData}
          keyExtractor={(item, index) => `${item}-${index}`}
          renderItem={({ item, index }) => (
            <ListItem
              text={item}
              rightIcon="caretRight"
              TextProps={{ numberOfLines: 1 }}
              topSeparator={index !== 0}
            />
          )}
        />
      </View>
    </DemoUseCase>,

    <DemoUseCase
      name="demoListItem:useCase.styling.name"
      description="demoListItem:useCase.styling.description"
    >
      <ListItem topSeparator textStyle={themed($customTextStyle)}>
        {translate("demoListItem:useCase.styling.styledText")}
      </ListItem>

      <ListItem
        topSeparator
        textStyle={{ color: theme.colors.palette.neutral100 }}
        style={themed($customTouchableStyle)}
      >
        {translate("demoListItem:useCase.styling.styledText")}
      </ListItem>

      <ListItem
        topSeparator
        textStyle={{ color: theme.colors.palette.neutral100 }}
        style={themed($customTouchableStyle)}
        containerStyle={themed($customContainerStyle)}
      >
        {translate("demoListItem:useCase.styling.styledContainer")}
      </ListItem>
      <ListItem
        topSeparator
        textStyle={{ color: theme.colors.palette.neutral100 }}
        style={themed($customTouchableStyle)}
        containerStyle={themed($customContainerStyle)}
        rightIcon="ladybug"
        leftIcon="ladybug"
        rightIconColor={theme.colors.palette.neutral100}
        leftIconColor={theme.colors.palette.neutral100}
      >
        {translate("demoListItem:useCase.styling.tintedIcons")}
      </ListItem>
    </DemoUseCase>,
  ],
}

// @demo remove-file
===== END FILE: app/screens/DemoShowroomScreen/demos/DemoListItem.tsx =====


===== BEGIN FILE: app/screens/DemoShowroomScreen/demos/DemoIcon.tsx =====
/* eslint-disable react/jsx-key */
import { ImageStyle, TextStyle, View, ViewStyle } from "react-native"

import { Icon, iconRegistry, type IconTypes } from "@/components/Icon"
import { Text } from "@/components/Text"
import type { ThemedStyle } from "@/theme/types"
import { $styles } from "@/theme/styles"

import { Demo } from "../DemoShowroomScreen"
import { DemoUseCase } from "../DemoUseCase"

const $demoIconContainer: ThemedStyle<ViewStyle> = ({ spacing }) => ({
  padding: spacing.xs,
})

const $iconTile: ThemedStyle<ViewStyle> = ({ spacing }) => ({
  width: "33.333%",
  alignItems: "center",
  paddingVertical: spacing.xs,
})

const $iconTileLabel: ThemedStyle<TextStyle> = ({ colors, spacing }) => ({
  marginTop: spacing.xxs,
  color: colors.textDim,
})

const $customIconContainer: ThemedStyle<ViewStyle> = ({ colors, spacing }) => ({
  padding: spacing.md,
  backgroundColor: colors.palette.angry500,
})

const $customIcon: ThemedStyle<ImageStyle> = ({ colors }) => ({
  tintColor: colors.palette.neutral100,
})

export const DemoIcon: Demo = {
  name: "Icon",
  description: "demoIcon:description",
  data: ({ theme, themed }) => [
    <DemoUseCase
      name="demoIcon:useCase.icons.name"
      description="demoIcon:useCase.icons.description"
      layout="row"
      itemStyle={$styles.flexWrap}
    >
      {Object.keys(iconRegistry).map((icon) => (
        <View key={icon} style={themed($iconTile)}>
          <Icon icon={icon as IconTypes} color={theme.colors.tint} size={35} />

          <Text size="xs" style={themed($iconTileLabel)}>
            {icon}
          </Text>
        </View>
      ))}
    </DemoUseCase>,

    <DemoUseCase
      name="demoIcon:useCase.size.name"
      description="demoIcon:useCase.size.description"
      layout="row"
    >
      <Icon icon="ladybug" containerStyle={themed($demoIconContainer)} />
      <Icon icon="ladybug" size={35} containerStyle={themed($demoIconContainer)} />
      <Icon icon="ladybug" size={50} containerStyle={themed($demoIconContainer)} />
      <Icon icon="ladybug" size={75} containerStyle={themed($demoIconContainer)} />
    </DemoUseCase>,

    <DemoUseCase
      name="demoIcon:useCase.color.name"
      description="demoIcon:useCase.color.description"
      layout="row"
    >
      <Icon
        icon="ladybug"
        color={theme.colors.palette.accent500}
        containerStyle={themed($demoIconContainer)}
      />
      <Icon
        icon="ladybug"
        color={theme.colors.palette.primary500}
        containerStyle={themed($demoIconContainer)}
      />
      <Icon
        icon="ladybug"
        color={theme.colors.palette.secondary500}
        containerStyle={themed($demoIconContainer)}
      />
      <Icon
        icon="ladybug"
        color={theme.colors.palette.neutral700}
        containerStyle={themed($demoIconContainer)}
      />
      <Icon
        icon="ladybug"
        color={theme.colors.palette.angry500}
        containerStyle={themed($demoIconContainer)}
      />
    </DemoUseCase>,

    <DemoUseCase
      name="demoIcon:useCase.styling.name"
      description="demoIcon:useCase.styling.description"
      layout="row"
    >
      <Icon
        icon="ladybug"
        style={themed($customIcon)}
        size={40}
        containerStyle={themed($customIconContainer)}
      />
    </DemoUseCase>,
  ],
}

// @demo remove-file
===== END FILE: app/screens/DemoShowroomScreen/demos/DemoIcon.tsx =====


===== BEGIN FILE: app/screens/DemoShowroomScreen/demos/DemoCard.tsx =====
/* eslint-disable react/jsx-key, react-native/no-inline-styles */
import { AutoImage } from "@/components/AutoImage"
import { Button } from "@/components/Button"
import { Card } from "@/components/Card"
import { Icon } from "@/components/Icon"

import { DemoDivider } from "../DemoDivider"
import { Demo } from "../DemoShowroomScreen"
import { DemoUseCase } from "../DemoUseCase"

export const DemoCard: Demo = {
  name: "Card",
  description: "demoCard:description",
  data: ({ theme }) => [
    <DemoUseCase
      name="demoCard:useCase.presets.name"
      description="demoCard:useCase.presets.description"
    >
      <Card
        headingTx="demoCard:useCase.presets.default.heading"
        contentTx="demoCard:useCase.presets.default.content"
        footerTx="demoCard:useCase.presets.default.footer"
      />
      <DemoDivider />
      <Card
        headingTx="demoCard:useCase.presets.reversed.heading"
        contentTx="demoCard:useCase.presets.reversed.content"
        footerTx="demoCard:useCase.presets.reversed.footer"
        preset="reversed"
      />
    </DemoUseCase>,

    <DemoUseCase
      name="demoCard:useCase.verticalAlignment.name"
      description="demoCard:useCase.verticalAlignment.description"
    >
      <Card
        headingTx="demoCard:useCase.verticalAlignment.top.heading"
        contentTx="demoCard:useCase.verticalAlignment.top.content"
        footerTx="demoCard:useCase.verticalAlignment.top.footer"
        style={{ minHeight: 160 }}
      />
      <DemoDivider />
      <Card
        headingTx="demoCard:useCase.verticalAlignment.center.heading"
        verticalAlignment="center"
        preset="reversed"
        contentTx="demoCard:useCase.verticalAlignment.center.content"
        footerTx="demoCard:useCase.verticalAlignment.center.footer"
        style={{ minHeight: 160 }}
      />
      <DemoDivider />
      <Card
        headingTx="demoCard:useCase.verticalAlignment.spaceBetween.heading"
        verticalAlignment="space-between"
        contentTx="demoCard:useCase.verticalAlignment.spaceBetween.content"
        footerTx="demoCard:useCase.verticalAlignment.spaceBetween.footer"
        style={{ minHeight: 160 }}
      />
      <DemoDivider />
      <Card
        preset="reversed"
        headingTx="demoCard:useCase.verticalAlignment.reversed.heading"
        verticalAlignment="force-footer-bottom"
        contentTx="demoCard:useCase.verticalAlignment.reversed.content"
        footerTx="demoCard:useCase.verticalAlignment.reversed.footer"
        style={{ minHeight: 160 }}
      />
    </DemoUseCase>,

    <DemoUseCase
      name="demoCard:useCase.passingContent.name"
      description="demoCard:useCase.passingContent.description"
    >
      <Card
        headingTx="demoCard:useCase.passingContent.heading"
        contentTx="demoCard:useCase.passingContent.content"
        footerTx="demoCard:useCase.passingContent.footer"
      />
      <DemoDivider />
      <Card
        preset="reversed"
        headingTx="demoShowroomScreen:demoViaSpecifiedTxProp"
        headingTxOptions={{ prop: "heading" }}
        contentTx="demoShowroomScreen:demoViaSpecifiedTxProp"
        contentTxOptions={{ prop: "content" }}
        footerTx="demoShowroomScreen:demoViaSpecifiedTxProp"
        footerTxOptions={{ prop: "footer" }}
      />
    </DemoUseCase>,

    <DemoUseCase
      name="demoCard:useCase.customComponent.name"
      description="demoCard:useCase.customComponent.description"
    >
      <Card
        HeadingComponent={
          <Button
            preset="reversed"
            text="HeadingComponent"
            LeftAccessory={(props) => <Icon style={props.style} icon="ladybug" />}
          />
        }
        ContentComponent={
          <Button
            style={{ marginVertical: theme.spacing.sm }}
            text="ContentComponent"
            LeftAccessory={(props) => <Icon style={props.style} icon="ladybug" />}
          />
        }
        FooterComponent={
          <Button
            preset="reversed"
            text="FooterComponent"
            LeftAccessory={(props) => <Icon style={props.style} icon="ladybug" />}
          />
        }
      />
      <DemoDivider />
      <Card
        headingTx="demoCard:useCase.customComponent.rightComponent"
        verticalAlignment="center"
        RightComponent={
          <AutoImage
            maxWidth={80}
            maxHeight={60}
            style={{ alignSelf: "center" }}
            source={{
              uri: "https://user-images.githubusercontent.com/1775841/184508739-f90d0ce5-7219-42fd-a91f-3382d016eae0.png",
            }}
          />
        }
      />
      <DemoDivider />
      <Card
        preset="reversed"
        headingTx="demoCard:useCase.customComponent.leftComponent"
        verticalAlignment="center"
        LeftComponent={
          <AutoImage
            maxWidth={80}
            maxHeight={60}
            style={{ alignSelf: "center" }}
            source={{
              uri: "https://user-images.githubusercontent.com/1775841/184508739-f90d0ce5-7219-42fd-a91f-3382d016eae0.png",
            }}
          />
        }
      />
    </DemoUseCase>,

    <DemoUseCase
      name="demoCard:useCase.style.name"
      description="demoCard:useCase.style.description"
    >
      <Card
        headingTx="demoCard:useCase.style.heading"
        headingStyle={{ color: theme.colors.error }}
        contentTx="demoCard:useCase.style.content"
        contentStyle={{
          backgroundColor: theme.colors.error,
          color: theme.colors.palette.neutral100,
        }}
        footerTx="demoCard:useCase.style.footer"
        footerStyle={{
          textDecorationLine: "underline line-through",
          textDecorationStyle: "dashed",
          color: theme.colors.error,
          textDecorationColor: theme.colors.error,
        }}
        style={{
          shadowRadius: 5,
          shadowColor: theme.colors.error,
          shadowOpacity: 0.5,
        }}
      />
    </DemoUseCase>,
  ],
}

// @demo remove-file
===== END FILE: app/screens/DemoShowroomScreen/demos/DemoCard.tsx =====


===== BEGIN FILE: app/screens/DemoShowroomScreen/demos/index.ts =====
export * from "./DemoIcon"
export * from "./DemoTextField"
export * from "./DemoToggle"
export * from "./DemoButton"
export * from "./DemoListItem"
export * from "./DemoCard"
export * from "./DemoAutoImage"
export * from "./DemoText"
export * from "./DemoHeader"
export * from "./DemoEmptyState"

// @demo remove-file
===== END FILE: app/screens/DemoShowroomScreen/demos/index.ts =====


===== BEGIN FILE: app/screens/DemoShowroomScreen/demos/DemoTextField.tsx =====
/* eslint-disable react/jsx-key */
import { TextStyle, ViewStyle } from "react-native"

import { Icon } from "@/components/Icon"
import { TextField } from "@/components/TextField"
import type { ThemedStyle } from "@/theme/types"

import { DemoDivider } from "../DemoDivider"
import { Demo } from "../DemoShowroomScreen"
import { DemoUseCase } from "../DemoUseCase"

const $customInputStyle: ThemedStyle<TextStyle> = ({ colors }) => ({
  backgroundColor: colors.error,
  color: colors.palette.neutral100,
})

const $customInputWrapperStyle: ThemedStyle<ViewStyle> = ({ colors }) => ({
  backgroundColor: colors.error,
  borderColor: colors.palette.neutral800,
})

const $customContainerStyle: ThemedStyle<ViewStyle> = ({ colors }) => ({
  backgroundColor: colors.error,
})

const $customLabelAndHelperStyle: ThemedStyle<TextStyle> = ({ colors }) => ({
  color: colors.palette.neutral100,
})

const $customInputWithAbsoluteAccessoriesStyle: ThemedStyle<ViewStyle> = ({ spacing }) => ({
  marginHorizontal: spacing.xxl,
})

const $customLeftAccessoryStyle: ThemedStyle<ViewStyle> = ({ colors }) => ({
  backgroundColor: colors.error,
  position: "absolute",
  left: 0,
})

const $customRightAccessoryStyle: ThemedStyle<ViewStyle> = ({ colors }) => ({
  backgroundColor: colors.error,
  position: "absolute",
  right: 0,
})

export const DemoTextField: Demo = {
  name: "TextField",
  description: "demoTextField:description",
  data: ({ themed }) => [
    <DemoUseCase
      name="demoTextField:useCase.statuses.name"
      description="demoTextField:useCase.statuses.description"
    >
      <TextField
        value="Labore occaecat in id eu commodo aliquip occaecat veniam officia pariatur."
        labelTx="demoTextField:useCase.statuses.noStatus.label"
        labelTxOptions={{ prop: "label" }}
        helperTx="demoTextField:useCase.statuses.noStatus.helper"
        helperTxOptions={{ prop: "helper" }}
        placeholderTx="demoTextField:useCase.statuses.noStatus.placeholder"
        placeholderTxOptions={{ prop: "placeholder" }}
      />

      <DemoDivider size={24} />

      <TextField
        status="error"
        value="Est Lorem duis sunt sunt duis proident minim elit dolore incididunt pariatur eiusmod anim cillum."
        labelTx="demoTextField:useCase.statuses.error.label"
        labelTxOptions={{ prop: "label" }}
        helperTx="demoTextField:useCase.statuses.error.helper"
        helperTxOptions={{ prop: "helper" }}
        placeholderTx="demoTextField:useCase.statuses.error.placeholder"
        placeholderTxOptions={{ prop: "placeholder" }}
      />

      <DemoDivider size={24} />

      <TextField
        status="disabled"
        value="Eu ipsum mollit non minim voluptate nulla fugiat aliqua ullamco aute consectetur nulla nulla amet."
        labelTx="demoTextField:useCase.statuses.disabled.label"
        labelTxOptions={{ prop: "label" }}
        helperTx="demoTextField:useCase.statuses.disabled.helper"
        helperTxOptions={{ prop: "helper" }}
        placeholderTx="demoTextField:useCase.statuses.disabled.placeholder"
        placeholderTxOptions={{ prop: "placeholder" }}
      />
    </DemoUseCase>,

    <DemoUseCase
      name="demoTextField:useCase.passingContent.name"
      description="demoTextField:useCase.passingContent.description"
    >
      <TextField
        labelTx="demoTextField:useCase.passingContent.viaLabel.labelTx"
        labelTxOptions={{ prop: "label" }}
        helperTx="demoTextField:useCase.passingContent.viaLabel.helper"
        helperTxOptions={{ prop: "helper" }}
        placeholderTx="demoTextField:useCase.passingContent.viaLabel.placeholder"
        placeholderTxOptions={{ prop: "placeholder" }}
      />

      <DemoDivider size={24} />

      <TextField
        labelTx="demoShowroomScreen:demoViaSpecifiedTxProp"
        labelTxOptions={{ prop: "label" }}
        helperTx="demoShowroomScreen:demoViaSpecifiedTxProp"
        helperTxOptions={{ prop: "helper" }}
        placeholderTx="demoShowroomScreen:demoViaSpecifiedTxProp"
        placeholderTxOptions={{ prop: "placeholder" }}
      />

      <DemoDivider size={24} />

      <TextField
        value="Reprehenderit Lorem magna non consequat ullamco cupidatat."
        labelTx="demoTextField:useCase.passingContent.rightAccessory.label"
        labelTxOptions={{ prop: "label" }}
        helperTx="demoTextField:useCase.passingContent.rightAccessory.helper"
        helperTxOptions={{ prop: "helper" }}
        RightAccessory={(props) => <Icon icon="ladybug" containerStyle={props.style} size={21} />}
      />

      <DemoDivider size={24} />

      <TextField
        labelTx="demoTextField:useCase.passingContent.leftAccessory.label"
        labelTxOptions={{ prop: "label" }}
        helperTx="demoTextField:useCase.passingContent.leftAccessory.helper"
        helperTxOptions={{ prop: "helper" }}
        value="Eiusmod exercitation mollit elit magna occaecat eiusmod Lorem minim veniam."
        LeftAccessory={(props) => <Icon icon="ladybug" containerStyle={props.style} size={21} />}
      />

      <DemoDivider size={24} />

      <TextField
        labelTx="demoTextField:useCase.passingContent.supportsMultiline.label"
        labelTxOptions={{ prop: "label" }}
        helperTx="demoTextField:useCase.passingContent.supportsMultiline.helper"
        helperTxOptions={{ prop: "helper" }}
        value="Eiusmod exercitation mollit elit magna occaecat eiusmod Lorem minim veniam. Laborum Lorem velit velit minim irure ad in ut adipisicing consectetur."
        multiline
        RightAccessory={(props) => <Icon icon="ladybug" containerStyle={props.style} size={21} />}
      />
    </DemoUseCase>,

    <DemoUseCase
      name="demoTextField:useCase.styling.name"
      description="demoTextField:useCase.styling.description"
    >
      <TextField
        labelTx="demoTextField:useCase.styling.styleInput.label"
        labelTxOptions={{ prop: "label" }}
        helperTx="demoTextField:useCase.styling.styleInput.helper"
        helperTxOptions={{ prop: "helper" }}
        value="Laborum cupidatat aliquip sunt sunt voluptate sint sit proident sunt mollit exercitation ullamco ea elit."
        style={themed($customInputStyle)}
      />

      <DemoDivider size={24} />

      <TextField
        labelTx="demoTextField:useCase.styling.styleInputWrapper.label"
        labelTxOptions={{ prop: "label" }}
        helperTx="demoTextField:useCase.styling.styleInputWrapper.helper"
        helperTxOptions={{ prop: "helper" }}
        value="Aute velit esse dolore pariatur exercitation irure nulla do sunt in duis mollit duis et."
        inputWrapperStyle={themed($customInputWrapperStyle)}
        style={themed($customInputStyle)}
      />

      <DemoDivider size={24} />

      <TextField
        labelTx="demoTextField:useCase.styling.styleContainer.label"
        labelTxOptions={{ prop: "label" }}
        helperTx="demoTextField:useCase.styling.styleContainer.helper"
        helperTxOptions={{ prop: "helper" }}
        value="Aliquip proident commodo adipisicing non adipisicing Lorem excepteur ullamco voluptate laborum."
        style={themed($customInputStyle)}
        containerStyle={themed($customContainerStyle)}
        inputWrapperStyle={themed($customInputWrapperStyle)}
      />

      <DemoDivider size={24} />

      <TextField
        labelTx="demoTextField:useCase.styling.styleLabel.label"
        labelTxOptions={{ prop: "label" }}
        helperTx="demoTextField:useCase.styling.styleLabel.helper"
        helperTxOptions={{ prop: "helper" }}
        value="Ex culpa in consectetur dolor irure velit."
        style={themed($customInputStyle)}
        containerStyle={themed($customContainerStyle)}
        inputWrapperStyle={themed($customInputWrapperStyle)}
        HelperTextProps={{ style: themed($customLabelAndHelperStyle) }}
        LabelTextProps={{ style: themed($customLabelAndHelperStyle) }}
      />

      <DemoDivider size={24} />

      <TextField
        labelTx="demoTextField:useCase.styling.styleAccessories.label"
        labelTxOptions={{ prop: "label" }}
        helperTx="demoTextField:useCase.styling.styleAccessories.helper"
        helperTxOptions={{ prop: "helper" }}
        value="Aute nisi dolore fugiat anim mollit nulla ex minim ipsum ex elit."
        style={themed($customInputWithAbsoluteAccessoriesStyle)}
        LeftAccessory={() => (
          <Icon
            icon="ladybug"
            containerStyle={themed($customLeftAccessoryStyle)}
            color="white"
            size={41}
          />
        )}
        RightAccessory={() => (
          <Icon
            icon="ladybug"
            containerStyle={themed($customRightAccessoryStyle)}
            color="white"
            size={41}
          />
        )}
      />
    </DemoUseCase>,
  ],
}

// @demo remove-file
===== END FILE: app/screens/DemoShowroomScreen/demos/DemoTextField.tsx =====


===== BEGIN FILE: app/screens/DemoShowroomScreen/demos/DemoToggle.tsx =====
/* eslint-disable react/jsx-key, react-native/no-inline-styles */
import { useState } from "react"
import { TextStyle, View, ViewStyle } from "react-native"

import { Text } from "@/components/Text"
import { Checkbox, CheckboxToggleProps } from "@/components/Toggle/Checkbox"
import { Radio, RadioToggleProps } from "@/components/Toggle/Radio"
import { Switch, SwitchToggleProps } from "@/components/Toggle/Switch"
import { translate } from "@/i18n/translate"
import type { ThemedStyle } from "@/theme/types"
import { $styles } from "@/theme/styles"

import { DemoDivider } from "../DemoDivider"
import { Demo } from "../DemoShowroomScreen"
import { DemoUseCase } from "../DemoUseCase"

function ControlledCheckbox(props: CheckboxToggleProps) {
  const [value, setValue] = useState(props.value || false)
  return <Checkbox {...props} value={value} onPress={() => setValue(!value)} />
}

function ControlledRadio(props: RadioToggleProps) {
  const [value, setValue] = useState(props.value || false)
  return <Radio {...props} value={value} onPress={() => setValue(!value)} />
}

function ControlledSwitch(props: SwitchToggleProps) {
  const [value, setValue] = useState(props.value || false)
  return <Switch {...props} value={value} onPress={() => setValue(!value)} />
}

const $centeredOneThirdCol: ViewStyle = {
  width: "33.33333%",
  alignItems: "center",
  justifyContent: "center",
}
const $centeredText: ThemedStyle<TextStyle> = ({ spacing }) => ({
  textAlign: "center",
  width: "100%",
  marginTop: spacing.xs,
})

export const DemoToggle: Demo = {
  name: "Toggle",
  description: "demoToggle:description",
  data: ({ theme, themed }) => [
    <DemoUseCase
      name="demoToggle:useCase.variants.name"
      description="demoToggle:useCase.variants.description"
    >
      <ControlledCheckbox
        labelTx="demoToggle:useCase.variants.checkbox.label"
        helperTx="demoToggle:useCase.variants.checkbox.helper"
      />
      <DemoDivider size={24} />
      <ControlledRadio
        labelTx="demoToggle:useCase.variants.radio.label"
        helperTx="demoToggle:useCase.variants.radio.helper"
      />
      <DemoDivider size={24} />
      <ControlledSwitch
        labelTx="demoToggle:useCase.variants.switch.label"
        helperTx="demoToggle:useCase.variants.switch.helper"
      />
    </DemoUseCase>,

    <DemoUseCase
      name="demoToggle:useCase.statuses.name"
      description="demoToggle:useCase.statuses.description"
      layout="row"
      itemStyle={$styles.flexWrap}
    >
      <ControlledCheckbox containerStyle={$centeredOneThirdCol} />
      <ControlledRadio containerStyle={$centeredOneThirdCol} />
      <ControlledSwitch containerStyle={$centeredOneThirdCol} />
      <DemoDivider style={{ width: "100%" }} />
      <ControlledCheckbox value containerStyle={$centeredOneThirdCol} />
      <ControlledRadio value containerStyle={$centeredOneThirdCol} />
      <ControlledSwitch value containerStyle={$centeredOneThirdCol} />
      <Text preset="formHelper" style={themed($centeredText)}>
        {translate("demoToggle:useCase.statuses.noStatus")}
      </Text>

      <DemoDivider size={24} style={{ width: "100%" }} />

      <ControlledCheckbox status="error" containerStyle={$centeredOneThirdCol} />
      <ControlledRadio status="error" containerStyle={$centeredOneThirdCol} />
      <ControlledSwitch status="error" containerStyle={$centeredOneThirdCol} />
      <DemoDivider style={{ width: "100%" }} />
      <ControlledCheckbox value status="error" containerStyle={$centeredOneThirdCol} />
      <ControlledRadio value status="error" containerStyle={$centeredOneThirdCol} />
      <ControlledSwitch value status="error" containerStyle={$centeredOneThirdCol} />
      <Text preset="formHelper" style={themed($centeredText)}>
        {translate("demoToggle:useCase.statuses.errorStatus")}
      </Text>

      <DemoDivider size={24} style={{ width: "100%" }} />

      <ControlledCheckbox status="disabled" containerStyle={$centeredOneThirdCol} />
      <ControlledRadio status="disabled" containerStyle={$centeredOneThirdCol} />
      <ControlledSwitch status="disabled" containerStyle={$centeredOneThirdCol} />
      <DemoDivider style={{ width: "100%" }} />
      <ControlledCheckbox value status="disabled" containerStyle={$centeredOneThirdCol} />
      <ControlledRadio value status="disabled" containerStyle={$centeredOneThirdCol} />
      <ControlledSwitch value status="disabled" containerStyle={$centeredOneThirdCol} />
      <Text preset="formHelper" style={themed($centeredText)}>
        {translate("demoToggle:useCase.statuses.disabledStatus")}
      </Text>
    </DemoUseCase>,

    <DemoUseCase
      name="demoToggle:useCase.passingContent.name"
      description="demoToggle:useCase.passingContent.description"
    >
      <ControlledCheckbox
        value
        labelTx="demoToggle:useCase.passingContent.useCase.checkBox.label"
        helperTx="demoToggle:useCase.passingContent.useCase.checkBox.helper"
      />
      <DemoDivider size={24} />
      <ControlledRadio
        value
        labelTx="demoShowroomScreen:demoViaSpecifiedTxProp"
        labelTxOptions={{ prop: "label" }}
        helperTx="demoShowroomScreen:demoViaSpecifiedTxProp"
        helperTxOptions={{ prop: "helper" }}
      />
      <DemoDivider size={24} />
      <ControlledCheckbox
        value
        labelTx="demoToggle:useCase.passingContent.useCase.checkBoxMultiLine.helper"
        editable={false}
      />
      <DemoDivider size={24} />
      <ControlledRadio
        value
        labelTx="demoToggle:useCase.passingContent.useCase.radioChangeSides.helper"
        labelPosition="left"
      />
      <DemoDivider size={24} />
      <ControlledCheckbox
        value
        status="error"
        icon="ladybug"
        labelTx="demoToggle:useCase.passingContent.useCase.customCheckBox.label"
      />
      <DemoDivider size={24} />
      <ControlledSwitch
        value
        accessibilityMode="text"
        labelTx="demoToggle:useCase.passingContent.useCase.switch.label"
        status="error"
        helperTx="demoToggle:useCase.passingContent.useCase.switch.helper"
      />
      <DemoDivider size={24} />
      <ControlledSwitch
        value
        labelPosition="left"
        accessibilityMode="icon"
        labelTx="demoToggle:useCase.passingContent.useCase.switchAid.label"
      />
    </DemoUseCase>,

    <DemoUseCase
      name="demoToggle:useCase.styling.name"
      description="demoToggle:useCase.styling.description"
      layout="row"
      itemStyle={$styles.flexWrap}
    >
      <ControlledCheckbox
        containerStyle={$centeredOneThirdCol}
        inputOuterStyle={{
          width: 50,
          height: 50,
          backgroundColor: theme.colors.palette.accent300,
          borderColor: theme.colors.palette.accent500,
        }}
      />
      <ControlledRadio
        containerStyle={$centeredOneThirdCol}
        inputOuterStyle={{
          width: 50,
          height: 50,
          borderRadius: 25,
          backgroundColor: theme.colors.palette.accent300,
          borderColor: theme.colors.palette.accent500,
        }}
      />
      <ControlledSwitch
        containerStyle={$centeredOneThirdCol}
        inputOuterStyle={{
          width: 70,
          height: 50,
          borderRadius: 25,
          backgroundColor: theme.colors.palette.accent300,
          borderColor: theme.colors.palette.accent500,
        }}
      />
      <Text preset="formHelper" style={themed($centeredText)}>
        {translate("demoToggle:useCase.styling.outerWrapper")}
      </Text>

      <DemoDivider style={{ width: "100%" }} />

      <ControlledCheckbox
        value
        containerStyle={$centeredOneThirdCol}
        inputOuterStyle={{
          width: 50,
          height: 50,
          backgroundColor: theme.colors.palette.accent300,
          borderColor: theme.colors.palette.accent500,
        }}
        inputInnerStyle={{
          backgroundColor: theme.colors.palette.accent500,
        }}
      />
      <ControlledRadio
        value
        containerStyle={$centeredOneThirdCol}
        inputOuterStyle={{
          width: 50,
          height: 50,
          borderRadius: 25,
          backgroundColor: theme.colors.palette.accent300,
          borderColor: theme.colors.palette.accent500,
        }}
        inputInnerStyle={{
          backgroundColor: theme.colors.palette.accent500,
        }}
      />
      <ControlledSwitch
        value
        containerStyle={$centeredOneThirdCol}
        inputOuterStyle={{
          width: 70,
          height: 50,
          borderRadius: 25,
          backgroundColor: theme.colors.palette.accent300,
          borderColor: theme.colors.palette.accent500,
        }}
        inputInnerStyle={{
          backgroundColor: theme.colors.palette.accent500,
          paddingLeft: 10,
          paddingRight: 10,
        }}
      />
      <Text preset="formHelper" style={themed($centeredText)}>
        {translate("demoToggle:useCase.styling.innerWrapper")}
      </Text>

      <DemoDivider style={{ width: "100%" }} />

      <ControlledCheckbox
        value
        icon="ladybug"
        containerStyle={$centeredOneThirdCol}
        inputOuterStyle={{
          width: 50,
          height: 50,
          backgroundColor: theme.colors.palette.accent300,
          borderColor: theme.colors.palette.accent500,
        }}
        inputInnerStyle={{
          backgroundColor: theme.colors.palette.accent500,
        }}
        inputDetailStyle={{
          tintColor: theme.colors.tint,
          height: 35,
          width: 35,
        }}
      />
      <ControlledRadio
        value
        containerStyle={$centeredOneThirdCol}
        inputOuterStyle={{
          width: 50,
          height: 50,
          borderRadius: 25,
          backgroundColor: theme.colors.palette.accent300,
          borderColor: theme.colors.palette.accent500,
        }}
        inputInnerStyle={{
          backgroundColor: theme.colors.palette.accent500,
        }}
        inputDetailStyle={{
          backgroundColor: theme.colors.tint,
          height: 36,
          width: 36,
          borderRadius: 18,
        }}
      />

      <ControlledSwitch
        value
        containerStyle={$centeredOneThirdCol}
        inputOuterStyle={{
          width: 70,
          height: 50,
          borderRadius: 25,
          backgroundColor: theme.colors.palette.accent300,
          borderColor: theme.colors.palette.accent500,
        }}
        inputInnerStyle={{
          backgroundColor: theme.colors.tint,
          paddingLeft: 10,
          paddingRight: 10,
        }}
        inputDetailStyle={{
          backgroundColor: theme.colors.palette.accent300,
          height: 36,
          width: 18,
          borderRadius: 36,
        }}
        accessibilityMode="icon"
      />

      <Text preset="formHelper" style={themed($centeredText)}>
        {translate("demoToggle:useCase.styling.inputDetail")}
      </Text>

      <DemoDivider size={32} style={{ width: "100%" }} />

      <View style={{ width: "100%" }}>
        <ControlledRadio
          value
          labelTx="demoToggle:useCase.styling.labelTx"
          LabelTextProps={{ size: "xs", weight: "bold" }}
          status="error"
          labelStyle={{
            backgroundColor: theme.colors.error,
            color: theme.colors.palette.neutral100,
            paddingHorizontal: 5,
          }}
        />
      </View>

      <DemoDivider size={24} style={{ width: "100%" }} />

      <View style={{ width: "100%" }}>
        <ControlledRadio
          value
          labelPosition="left"
          containerStyle={{ padding: 10, backgroundColor: theme.colors.error }}
          labelTx="demoToggle:useCase.styling.styleContainer"
          status="error"
          labelStyle={{ color: theme.colors.palette.neutral100 }}
        />
      </View>
    </DemoUseCase>,
  ],
}

// @demo remove-file
===== END FILE: app/screens/DemoShowroomScreen/demos/DemoToggle.tsx =====


===== BEGIN FILE: app/screens/DemoShowroomScreen/demos/DemoButton.tsx =====
/* eslint-disable react/jsx-key */
import { ImageStyle, TextStyle, View, ViewStyle } from "react-native"

import { Button } from "@/components/Button"
import { Icon } from "@/components/Icon"
import { Text } from "@/components/Text"
import { translate } from "@/i18n/translate"
import type { ThemedStyle } from "@/theme/types"

import { DemoDivider } from "../DemoDivider"
import { Demo } from "../DemoShowroomScreen"
import { DemoUseCase } from "../DemoUseCase"

const $iconStyle: ImageStyle = { width: 30, height: 30 }
const $customButtonStyle: ThemedStyle<ViewStyle> = ({ colors }) => ({
  backgroundColor: colors.error,
  height: 100,
})
const $customButtonPressedStyle: ThemedStyle<ViewStyle> = ({ colors }) => ({
  backgroundColor: colors.error,
})
const $customButtonTextStyle: ThemedStyle<TextStyle> = ({ colors, typography }) => ({
  color: colors.error,
  fontFamily: typography.primary.bold,
  textDecorationLine: "underline",
  textDecorationColor: colors.error,
})
const $customButtonPressedTextStyle: ThemedStyle<TextStyle> = ({ colors }) => ({
  color: colors.palette.neutral100,
})
const $customButtonRightAccessoryStyle: ThemedStyle<ViewStyle> = ({ colors }) => ({
  width: "53%",
  height: "200%",
  backgroundColor: colors.error,
  position: "absolute",
  top: 0,
  right: 0,
})
const $customButtonPressedRightAccessoryStyle: ThemedStyle<ImageStyle> = ({ colors }) => ({
  tintColor: colors.palette.neutral100,
})

const $disabledOpacity: ViewStyle = { opacity: 0.5 }
const $disabledButtonTextStyle: ThemedStyle<TextStyle> = ({ colors }) => ({
  color: colors.palette.neutral100,
  textDecorationColor: colors.palette.neutral100,
})

export const DemoButton: Demo = {
  name: "Button",
  description: "demoButton:description",
  data: ({ themed }) => [
    <DemoUseCase
      name="demoButton:useCase.presets.name"
      description="demoButton:useCase.presets.description"
    >
      <Button>Default - Laboris In Labore</Button>
      <DemoDivider />

      <Button preset="filled">Filled - Laboris Ex</Button>
      <DemoDivider />

      <Button preset="reversed">Reversed - Ad Ipsum</Button>
    </DemoUseCase>,

    <DemoUseCase
      name="demoButton:useCase.passingContent.name"
      description="demoButton:useCase.passingContent.description"
    >
      <Button text={translate("demoButton:useCase.passingContent.viaTextProps")} />
      <DemoDivider />

      <Button tx="demoShowroomScreen:demoViaTxProp" />
      <DemoDivider />

      <Button>{translate("demoButton:useCase.passingContent.children")}</Button>
      <DemoDivider />

      <Button
        preset="filled"
        RightAccessory={(props) => (
          <Icon containerStyle={props.style} style={$iconStyle} icon="ladybug" />
        )}
      >
        {translate("demoButton:useCase.passingContent.rightAccessory")}
      </Button>
      <DemoDivider />

      <Button
        preset="filled"
        LeftAccessory={(props) => (
          <Icon containerStyle={props.style} style={$iconStyle} icon="ladybug" />
        )}
      >
        {translate("demoButton:useCase.passingContent.leftAccessory")}
      </Button>
      <DemoDivider />

      <Button>
        <Text>
          <Text preset="bold">{translate("demoButton:useCase.passingContent.nestedChildren")}</Text>
          {` `}
          <Text preset="default">
            {translate("demoButton:useCase.passingContent.nestedChildren2")}
          </Text>
          {` `}
          <Text preset="bold">
            {translate("demoButton:useCase.passingContent.nestedChildren3")}
          </Text>
        </Text>
      </Button>
      <DemoDivider />

      <Button
        preset="reversed"
        RightAccessory={(props) => (
          <Icon containerStyle={props.style} style={$iconStyle} icon="ladybug" />
        )}
        LeftAccessory={(props) => (
          <Icon containerStyle={props.style} style={$iconStyle} icon="ladybug" />
        )}
      >
        {translate("demoButton:useCase.passingContent.multiLine")}
      </Button>
    </DemoUseCase>,

    <DemoUseCase
      name="demoButton:useCase.styling.name"
      description="demoButton:useCase.styling.description"
    >
      <Button style={themed($customButtonStyle)}>
        {translate("demoButton:useCase.styling.styleContainer")}
      </Button>
      <DemoDivider />

      <Button preset="filled" textStyle={themed($customButtonTextStyle)}>
        {translate("demoButton:useCase.styling.styleText")}
      </Button>
      <DemoDivider />

      <Button
        preset="reversed"
        RightAccessory={() => <View style={themed($customButtonRightAccessoryStyle)} />}
      >
        {translate("demoButton:useCase.styling.styleAccessories")}
      </Button>
      <DemoDivider />

      <Button
        pressedStyle={themed($customButtonPressedStyle)}
        pressedTextStyle={themed($customButtonPressedTextStyle)}
        RightAccessory={(props) => (
          <Icon
            containerStyle={props.style}
            style={[
              $iconStyle,
              props.pressableState.pressed && themed($customButtonPressedRightAccessoryStyle),
            ]}
            icon="ladybug"
          />
        )}
      >
        {translate("demoButton:useCase.styling.pressedState")}
      </Button>
    </DemoUseCase>,

    <DemoUseCase
      name="demoButton:useCase.disabling.name"
      description="demoButton:useCase.disabling.description"
    >
      <Button
        disabled
        disabledStyle={$disabledOpacity}
        pressedStyle={themed($customButtonPressedStyle)}
        pressedTextStyle={themed($customButtonPressedTextStyle)}
      >
        {translate("demoButton:useCase.disabling.standard")}
      </Button>
      <DemoDivider />

      <Button
        disabled
        preset="filled"
        disabledStyle={$disabledOpacity}
        pressedStyle={themed($customButtonPressedStyle)}
        pressedTextStyle={themed($customButtonPressedTextStyle)}
      >
        {translate("demoButton:useCase.disabling.filled")}
      </Button>
      <DemoDivider />

      <Button
        disabled
        preset="reversed"
        disabledStyle={$disabledOpacity}
        pressedStyle={themed($customButtonPressedStyle)}
        pressedTextStyle={themed($customButtonPressedTextStyle)}
      >
        {translate("demoButton:useCase.disabling.reversed")}
      </Button>
      <DemoDivider />

      <Button
        disabled
        pressedStyle={themed($customButtonPressedStyle)}
        pressedTextStyle={themed($customButtonPressedTextStyle)}
        RightAccessory={(props) => (
          <View
            style={
              props.disabled
                ? [$customButtonRightAccessoryStyle, $disabledOpacity]
                : themed($customButtonPressedRightAccessoryStyle)
            }
          />
        )}
      >
        {translate("demoButton:useCase.disabling.accessory")}
      </Button>
      <DemoDivider />

      <Button
        disabled
        preset="filled"
        disabledTextStyle={themed([$customButtonTextStyle, $disabledButtonTextStyle])}
        pressedStyle={themed($customButtonPressedStyle)}
        pressedTextStyle={themed($customButtonPressedTextStyle)}
      >
        {translate("demoButton:useCase.disabling.textStyle")}
      </Button>
    </DemoUseCase>,
  ],
}

// @demo remove-file
===== END FILE: app/screens/DemoShowroomScreen/demos/DemoButton.tsx =====


===== BEGIN FILE: app/screens/ErrorScreen/ErrorDetails.tsx =====
import { ErrorInfo } from "react"
import { ScrollView, TextStyle, View, ViewStyle } from "react-native"

import { Button } from "@/components/Button"
import { Icon } from "@/components/Icon"
import { Screen } from "@/components/Screen"
import { Text } from "@/components/Text"
import type { ThemedStyle } from "@/theme/types"
import { useAppTheme } from "@/theme/context"

export interface ErrorDetailsProps {
  error: Error
  errorInfo: ErrorInfo | null
  onReset(): void
}

/**
 * Renders the error details screen.
 * @param {ErrorDetailsProps} props - The props for the `ErrorDetails` component.
 * @returns {JSX.Element} The rendered `ErrorDetails` component.
 */
export function ErrorDetails(props: ErrorDetailsProps) {
  const { themed } = useAppTheme()
  return (
    <Screen
      preset="fixed"
      safeAreaEdges={["top", "bottom"]}
      contentContainerStyle={themed($contentContainer)}
    >
      <View style={$topSection}>
        <Icon icon="ladybug" size={64} />
        <Text style={themed($heading)} preset="subheading" tx="errorScreen:title" />
        <Text tx="errorScreen:friendlySubtitle" />
      </View>

      <ScrollView
        style={themed($errorSection)}
        contentContainerStyle={themed($errorSectionContentContainer)}
      >
        <Text style={themed($errorContent)} weight="bold" text={`${props.error}`.trim()} />
        <Text
          selectable
          style={themed($errorBacktrace)}
          text={`${props.errorInfo?.componentStack ?? ""}`.trim()}
        />
      </ScrollView>

      <Button
        preset="reversed"
        style={themed($resetButton)}
        onPress={props.onReset}
        tx="errorScreen:reset"
      />
    </Screen>
  )
}

const $contentContainer: ThemedStyle<ViewStyle> = ({ spacing }) => ({
  alignItems: "center",
  paddingHorizontal: spacing.lg,
  paddingTop: spacing.xl,
  flex: 1,
})

const $topSection: ViewStyle = {
  flex: 1,
  alignItems: "center",
}

const $heading: ThemedStyle<TextStyle> = ({ colors, spacing }) => ({
  color: colors.error,
  marginBottom: spacing.md,
})

const $errorSection: ThemedStyle<ViewStyle> = ({ colors, spacing }) => ({
  flex: 2,
  backgroundColor: colors.separator,
  marginVertical: spacing.md,
  borderRadius: 6,
})

const $errorSectionContentContainer: ThemedStyle<ViewStyle> = ({ spacing }) => ({
  padding: spacing.md,
})

const $errorContent: ThemedStyle<TextStyle> = ({ colors }) => ({
  color: colors.error,
})

const $errorBacktrace: ThemedStyle<TextStyle> = ({ colors, spacing }) => ({
  marginTop: spacing.md,
  color: colors.textDim,
})

const $resetButton: ThemedStyle<ViewStyle> = ({ colors, spacing }) => ({
  backgroundColor: colors.error,
  paddingHorizontal: spacing.xxl,
})
===== END FILE: app/screens/ErrorScreen/ErrorDetails.tsx =====


===== BEGIN FILE: app/screens/ErrorScreen/ErrorBoundary.tsx =====
import { Component, ErrorInfo, ReactNode } from "react"

import { ErrorDetails } from "./ErrorDetails"

interface Props {
  children: ReactNode
  catchErrors: "always" | "dev" | "prod" | "never"
}

interface State {
  error: Error | null
  errorInfo: ErrorInfo | null
}

/**
 * This component handles whenever the user encounters a JS error in the
 * app. It follows the "error boundary" pattern in React. We're using a
 * class component because according to the documentation, only class
 * components can be error boundaries.
 * @see [Documentation and Examples]{@link https://docs.infinite.red/ignite-cli/concept/Error-Boundary/}
 * @see [React Error Boundaries]{@link https://react.dev/reference/react/Component#catching-rendering-errors-with-an-error-boundary}
 * @param {Props} props - The props for the `ErrorBoundary` component.
 * @returns {JSX.Element} The rendered `ErrorBoundary` component.
 */
export class ErrorBoundary extends Component<Props, State> {
  state = { error: null, errorInfo: null }

  // If an error in a child is encountered, this will run
  componentDidCatch(error: Error, errorInfo: ErrorInfo) {
    // Only set errors if enabled
    if (!this.isEnabled()) {
      return
    }
    // Catch errors in any components below and re-render with error message
    this.setState({
      error,
      errorInfo,
    })

    // You can also log error messages to an error reporting service here
    // This is a great place to put BugSnag, Sentry, crashlytics, etc:
    // reportCrash(error)
  }

  // Reset the error back to null
  resetError = () => {
    this.setState({ error: null, errorInfo: null })
  }

  // To avoid unnecessary re-renders
  shouldComponentUpdate(nextProps: Readonly<Props>, nextState: Readonly<State>): boolean {
    return nextState.error !== this.state.error
  }

  // Only enable if we're catching errors in the right environment
  isEnabled(): boolean {
    return (
      this.props.catchErrors === "always" ||
      (this.props.catchErrors === "dev" && __DEV__) ||
      (this.props.catchErrors === "prod" && !__DEV__)
    )
  }

  // Render an error UI if there's an error; otherwise, render children
  render() {
    return this.isEnabled() && this.state.error ? (
      <ErrorDetails
        onReset={this.resetError}
        error={this.state.error}
        errorInfo={this.state.errorInfo}
      />
    ) : (
      this.props.children
    )
  }
}
===== END FILE: app/screens/ErrorScreen/ErrorBoundary.tsx =====


===== BEGIN FILE: app/components/TaskCard.tsx =====
import React from "react"
import { View, Pressable } from "react-native"
import { Card } from "@/components/Card"
import { Text } from "@/components/Text"
import { Button } from "@/components/Button"
import { useAppTheme } from "@/theme/context"
import { Audio } from "expo-av"
import { RatingBadge } from "./RatingBadge"

type Props = {
  id: string
  title?: string
  kmAway?: number
  onAccept?: () => void
  status?: "PENDING" | "ASSIGNED" | "COMPLETED" | "OPEN" | "CANCELLED" | "CANCELED"
  voiceUrl?: string | null
  onPress?: () => void
  createdByName?: string
  createdAt?: string
  helperAvgRating?: number | null
}

function getInitials(name?: string) {
  if (!name) return "👤"
  const parts = name.trim().split(/\s+/)
  return ((parts[0]?.[0] ?? "") + (parts[1]?.[0] ?? "")).toUpperCase()
}

function minsAgo(iso?: string) {
  if (!iso) return ""
  const date = new Date(iso)
  const diffMs = Date.now() - date.getTime()
  const mins = Math.max(0, Math.round(diffMs / 60000))

  if (mins < 1) return "just now"
  if (mins === 1) return "1 min ago"
  if (mins < 60) return `${mins} mins ago`
  const hrs = Math.round(mins / 60)
  if (hrs === 1) return "1 hr ago"
  if (hrs < 24) return `${hrs} hrs ago`

  // For older than a day, show readable date
  return date.toLocaleString(undefined, {
    day: "2-digit",
    month: "short",
    year: "numeric",
    hour: "2-digit",
    minute: "2-digit",
  })
}

export function TaskCard({
  title = "Voice task",
  kmAway,
  onAccept,
  status = "PENDING",
  voiceUrl,
  onPress,
  createdByName,
  createdAt,
  helperAvgRating = 2.5,
}: Props) {
  const { theme } = useAppTheme()
  const { spacing, colors } = theme

  // Normalize backend statuses to UI statuses
  // Backend may send OPEN; map it to PENDING visually. Handle CANCELLED/CANCELED gracefully.
  const normalizedStatus: "PENDING" | "ASSIGNED" | "COMPLETED" =
    status === "OPEN"
      ? "PENDING"
      : status === "CANCELLED" || status === "CANCELED"
        ? "COMPLETED" // or choose a different bucket if you have a Cancelled style
        : (status as any)

  const primary = colors.palette.primary500
  const neutral700 = colors.palette.neutral700

  const statusMap = {
    PENDING: { label: "Pending", bg: colors.palette.primary200, fg: neutral700 },
    ASSIGNED: { label: "Assigned", bg: colors.palette.warningSoft400, fg: neutral700 },
    COMPLETED: { label: "Completed", bg: colors.palette.successSoft400, fg: neutral700 },
  } as const
  const S = statusMap[normalizedStatus] ?? statusMap.PENDING

  const [sound, setSound] = React.useState<Audio.Sound | null>(null)
  const [playing, setPlaying] = React.useState(false)

  const play = async () => {
    if (!voiceUrl) return
    const { sound } = await Audio.Sound.createAsync({ uri: voiceUrl })
    setSound(sound)
    setPlaying(true)
    await sound.playAsync()
    sound.setOnPlaybackStatusUpdate((st: any) => {
      if (!st.isPlaying) {
        setPlaying(false)
        sound.unloadAsync()
        setSound(null)
      }
    })
  }

  // Footer: type as ReactElement | undefined to satisfy Card’s prop
  const FooterComponent =
    status === "PENDING" && onAccept ? (
      <View style={{ flexDirection: "row", justifyContent: "flex-end" }}>
        <Button
          text="Accept"
          onPress={onAccept}
          style={{
            paddingHorizontal: spacing.lg,
            paddingVertical: spacing.xs,
            borderRadius: spacing.sm,
            minWidth: 100,
          }}
        />
      </View>
    ) : undefined // <-- important

  const HeaderRow = (
    <View style={{ flexDirection: "row", alignItems: "center", gap: 8 }}>
      {/* Avatar with initials */}
      <View
        style={{
          width: 28,
          height: 28,
          borderRadius: 14,
          backgroundColor: "#E5E7EB",
          alignItems: "center",
          justifyContent: "center",
        }}
        accessibilityLabel={createdByName ? `${createdByName} avatar` : "User avatar"}
      >
        <Text text={getInitials(createdByName)} size="xs" weight="bold" />
      </View>

      <View style={{ flex: 1 }}>
        {/* Poster name */}
        <Text text={createdByName ?? "Someone nearby"} weight="medium" />
        {/* When posted */}
        <Text text={minsAgo(createdAt)} size="xs" />
      </View>
      {voiceUrl ? (
        <Pressable
          onPress={play}
          style={{
            width: 40,
            height: 40,
            borderRadius: 20,
            backgroundColor: primary,
            justifyContent: "center",
            alignItems: "center",
            marginRight: spacing.md,
          }}
          accessibilityRole="button"
          accessibilityLabel={playing ? "Playing" : "Play voice"}
        >
          <Text text={playing ? "…" : "▶︎"} style={{ color: "white", fontWeight: "bold" }} />
        </Pressable>
      ) : undefined}
      {status === "PENDING" && onAccept ? (
        <View style={{ flexDirection: "row", justifyContent: "flex-end" }}>
          <Button
            text="Accept"
            onPress={onAccept}
            style={{
              paddingHorizontal: spacing.lg,
              paddingVertical: spacing.xs,
              borderRadius: spacing.sm,
              minWidth: 100,
            }}
          />
        </View>
      ) : undefined}
    </View>
  )
  // Left component: small, pressable play control
  // const LeftComponent = voiceUrl ? (
  //   <Pressable
  //     onPress={play}
  //     style={{
  //       width: 30,
  //       height: 30,
  //       borderRadius: 20,
  //       backgroundColor: primary,
  //       justifyContent: "center",
  //       alignItems: "center",
  //       marginRight: spacing.md,
  //     }}
  //     accessibilityRole="button"
  //     accessibilityLabel={playing ? "Playing" : "Play voice"}
  //   >
  //     <Text text={playing ? "…" : "▶︎"} style={{ color: "white", fontWeight: "bold" }} />
  //   </Pressable>
  // ) : undefined // <-- undefined, not null

  const ContentComponent = (
    <View style={{ gap: spacing.xs }}>
      {HeaderRow}

      {/* Title */}
      <Text text={title} weight="bold" style={{ color: neutral700 }} />

      {/* Distance + Status side-by-side */}
      <View
        style={{
          flexDirection: "row",
          alignItems: "center",
          justifyContent: "space-between",
          gap: spacing.sm,
        }}
      >
        {!!kmAway && (
          <Text text={`${kmAway.toFixed(1)} km away`} size="xs" style={{ color: neutral700 }} />
        )}

        <View
          style={{
            paddingHorizontal: spacing.sm,
            paddingVertical: spacing.xxs,
            borderRadius: 999,
            backgroundColor: S.bg,
          }}
        >
          <Text text={S.label} size="xs" weight="medium" style={{ color: S.fg }} />
        </View>
        <RatingBadge value={helperAvgRating} />
      </View>
    </View>
  )

  return (
    <Card
      style={{ marginVertical: spacing.xs, elevation: 2 }}
      verticalAlignment="force-footer-bottom"
      // LeftComponent={LeftComponent}
      ContentComponent={ContentComponent}
      onPress={onPress}
      activeOpacity={onPress ? 0.85 : undefined}
    />
  )
}
===== END FILE: app/components/TaskCard.tsx =====


===== BEGIN FILE: app/components/RadioChip.tsx =====
import React, { memo } from "react"
import { Pressable, View, StyleSheet, Platform } from "react-native"
import { Text } from "@/components/Text"

export type RadioChipValue = string | number

type RadioChipProps = {
  label: string
  value: RadioChipValue
  selected?: boolean
  disabled?: boolean
  onChange?: (value: RadioChipValue) => void
  size?: "md" | "lg"
}

export const RadioChip = memo(function RadioChip({
  label,
  value,
  selected = false,
  disabled = false,
  onChange,
  size = "md",
}: RadioChipProps) {
  const S = styles(size, selected, disabled)

  return (
    <Pressable
      onPress={() => !disabled && onChange?.(value)}
      style={({ pressed }) => [S.base, pressed && S.pressed]}
      role="radio"
      accessibilityRole="radio"
      accessibilityState={{ selected, disabled }}
      accessibilityLabel={label}
      hitSlop={10}
      android_ripple={disabled ? undefined : { borderless: true }}
    >
      <View style={S.dot} />
      <Text
        text={label}
        preset="default"
        style={S.label}
        // If your Text supports `color` or `preset` variants, you can swap S.label for those
      />
    </Pressable>
  )
})

function styles(size: "md" | "lg", selected: boolean, disabled: boolean) {
  const height = size === "lg" ? 44 : 36
  const padH = size === "lg" ? 14 : 12
  const dot = size === "lg" ? 12 : 10

  // neutral + selected palette (tweak to your theme if you expose tokens)
  const bg = selected ? "rgba(59,130,246,0.12)" : "#FFFFFF" // selected: soft primary tint
  const bd = selected ? "#BF360C" : "#E5E7EB" // border: primary vs. gray-200
  const fg = disabled ? "#9CA3AF" : selected ? "#1F2937" : "#374151" // text: dim if disabled
  const dotBg = selected ? "#FF6B2C" : "transparent"

  return StyleSheet.create({
    base: {
      height,
      paddingHorizontal: padH,
      borderRadius: 999,
      borderWidth: 1,
      borderColor: bd,
      backgroundColor: bg,
      flexDirection: "row",
      alignItems: "center",
      gap: 8,
      opacity: disabled ? 0.6 : 1,
      ...(Platform.OS === "ios"
        ? {
            shadowColor: "#000",
            shadowOpacity: selected ? 0.08 : 0.04,
            shadowRadius: 6,
            shadowOffset: { width: 0, height: 3 },
          }
        : { elevation: selected ? 1 : 0 }),
    },
    pressed: {
      transform: [{ scale: 0.98 }],
    },
    dot: {
      width: dot,
      height: dot,
      borderRadius: 999,
      borderWidth: selected ? 0 : 1,
      borderColor: selected ? "transparent" : "#FF6B2C",
      backgroundColor: dotBg,
    },
    label: {
      color: fg,
      fontWeight: selected ? "600" : "500",
    },
  })
}
===== END FILE: app/components/RadioChip.tsx =====


===== BEGIN FILE: app/components/Card.tsx =====
import { ComponentType, Fragment, ReactElement } from "react"
import {
  StyleProp,
  TextStyle,
  TouchableOpacity,
  TouchableOpacityProps,
  View,
  ViewProps,
  ViewStyle,
} from "react-native"

import type { ThemedStyle, ThemedStyleArray } from "@/theme/types"
import { useAppTheme } from "@/theme/context"
import { $styles } from "@/theme/styles"

import { Text, TextProps } from "./Text"

type Presets = "default" | "reversed"

interface CardProps extends TouchableOpacityProps {
  /**
   * One of the different types of text presets.
   */
  preset?: Presets
  /**
   * How the content should be aligned vertically. This is especially (but not exclusively) useful
   * when the card is a fixed height but the content is dynamic.
   *
   * `top` (default) - aligns all content to the top.
   * `center` - aligns all content to the center.
   * `space-between` - spreads out the content evenly.
   * `force-footer-bottom` - aligns all content to the top, but forces the footer to the bottom.
   */
  verticalAlignment?: "top" | "center" | "space-between" | "force-footer-bottom"
  /**
   * Custom component added to the left of the card body.
   */
  LeftComponent?: ReactElement
  /**
   * Custom component added to the right of the card body.
   */
  RightComponent?: ReactElement
  /**
   * The heading text to display if not using `headingTx`.
   */
  heading?: TextProps["text"]
  /**
   * Heading text which is looked up via i18n.
   */
  headingTx?: TextProps["tx"]
  /**
   * Optional heading options to pass to i18n. Useful for interpolation
   * as well as explicitly setting locale or translation fallbacks.
   */
  headingTxOptions?: TextProps["txOptions"]
  /**
   * Style overrides for heading text.
   */
  headingStyle?: StyleProp<TextStyle>
  /**
   * Pass any additional props directly to the heading Text component.
   */
  HeadingTextProps?: TextProps
  /**
   * Custom heading component.
   * Overrides all other `heading*` props.
   */
  HeadingComponent?: ReactElement
  /**
   * The content text to display if not using `contentTx`.
   */
  content?: TextProps["text"]
  /**
   * Content text which is looked up via i18n.
   */
  contentTx?: TextProps["tx"]
  /**
   * Optional content options to pass to i18n. Useful for interpolation
   * as well as explicitly setting locale or translation fallbacks.
   */
  contentTxOptions?: TextProps["txOptions"]
  /**
   * Style overrides for content text.
   */
  contentStyle?: StyleProp<TextStyle>
  /**
   * Pass any additional props directly to the content Text component.
   */
  ContentTextProps?: TextProps
  /**
   * Custom content component.
   * Overrides all other `content*` props.
   */
  ContentComponent?: ReactElement
  /**
   * The footer text to display if not using `footerTx`.
   */
  footer?: TextProps["text"]
  /**
   * Footer text which is looked up via i18n.
   */
  footerTx?: TextProps["tx"]
  /**
   * Optional footer options to pass to i18n. Useful for interpolation
   * as well as explicitly setting locale or translation fallbacks.
   */
  footerTxOptions?: TextProps["txOptions"]
  /**
   * Style overrides for footer text.
   */
  footerStyle?: StyleProp<TextStyle>
  /**
   * Pass any additional props directly to the footer Text component.
   */
  FooterTextProps?: TextProps
  /**
   * Custom footer component.
   * Overrides all other `footer*` props.
   */
  FooterComponent?: ReactElement
}

/**
 * Cards are useful for displaying related information in a contained way.
 * If a ListItem displays content horizontally, a Card can be used to display content vertically.
 * @see [Documentation and Examples]{@link https://docs.infinite.red/ignite-cli/boilerplate/app/components/Card/}
 * @param {CardProps} props - The props for the `Card` component.
 * @returns {JSX.Element} The rendered `Card` component.
 */
export function Card(props: CardProps) {
  const {
    content,
    contentTx,
    contentTxOptions,
    footer,
    footerTx,
    footerTxOptions,
    heading,
    headingTx,
    headingTxOptions,
    ContentComponent,
    HeadingComponent,
    FooterComponent,
    LeftComponent,
    RightComponent,
    verticalAlignment = "top",
    style: $containerStyleOverride,
    contentStyle: $contentStyleOverride,
    headingStyle: $headingStyleOverride,
    footerStyle: $footerStyleOverride,
    ContentTextProps,
    HeadingTextProps,
    FooterTextProps,
    ...WrapperProps
  } = props

  const {
    themed,
    theme: { spacing },
  } = useAppTheme()

  const preset: Presets = props.preset ?? "default"
  const isPressable = !!WrapperProps.onPress
  const isHeadingPresent = !!(HeadingComponent || heading || headingTx)
  const isContentPresent = !!(ContentComponent || content || contentTx)
  const isFooterPresent = !!(FooterComponent || footer || footerTx)

  const Wrapper = (isPressable ? TouchableOpacity : View) as ComponentType<
    TouchableOpacityProps | ViewProps
  >
  const HeaderContentWrapper = verticalAlignment === "force-footer-bottom" ? View : Fragment

  const $containerStyle: StyleProp<ViewStyle> = [
    themed($containerPresets[preset]),
    $containerStyleOverride,
  ]
  const $headingStyle = [
    themed($headingPresets[preset]),
    (isFooterPresent || isContentPresent) && { marginBottom: spacing.xxxs },
    $headingStyleOverride,
    HeadingTextProps?.style,
  ]
  const $contentStyle = [
    themed($contentPresets[preset]),
    isHeadingPresent && { marginTop: spacing.xxxs },
    isFooterPresent && { marginBottom: spacing.xxxs },
    $contentStyleOverride,
    ContentTextProps?.style,
  ]
  const $footerStyle = [
    themed($footerPresets[preset]),
    (isHeadingPresent || isContentPresent) && { marginTop: spacing.xxxs },
    $footerStyleOverride,
    FooterTextProps?.style,
  ]
  const $alignmentWrapperStyle = [
    $alignmentWrapper,
    { justifyContent: $alignmentWrapperFlexOptions[verticalAlignment] },
    LeftComponent && { marginStart: spacing.md },
    RightComponent && { marginEnd: spacing.md },
  ]

  return (
    <Wrapper
      style={$containerStyle}
      activeOpacity={0.8}
      accessibilityRole={isPressable ? "button" : undefined}
      {...WrapperProps}
    >
      {LeftComponent}

      <View style={$alignmentWrapperStyle}>
        <HeaderContentWrapper>
          {HeadingComponent ||
            (isHeadingPresent && (
              <Text
                weight="bold"
                text={heading}
                tx={headingTx}
                txOptions={headingTxOptions}
                {...HeadingTextProps}
                style={$headingStyle}
              />
            ))}

          {ContentComponent ||
            (isContentPresent && (
              <Text
                weight="normal"
                text={content}
                tx={contentTx}
                txOptions={contentTxOptions}
                {...ContentTextProps}
                style={$contentStyle}
              />
            ))}
        </HeaderContentWrapper>

        {FooterComponent ||
          (isFooterPresent && (
            <Text
              weight="normal"
              size="xs"
              text={footer}
              tx={footerTx}
              txOptions={footerTxOptions}
              {...FooterTextProps}
              style={$footerStyle}
            />
          ))}
      </View>

      {RightComponent}
    </Wrapper>
  )
}

const $containerBase: ThemedStyle<ViewStyle> = (theme) => ({
  borderRadius: theme.spacing.md,
  padding: theme.spacing.xs,
  borderWidth: 1,
  shadowColor: theme.colors.palette.neutral800,
  shadowOffset: { width: 0, height: 12 },
  shadowOpacity: 0.08,
  shadowRadius: 12.81,
  elevation: 16,
  minHeight: 96,
})

const $alignmentWrapper: ViewStyle = {
  flex: 1,
  alignSelf: "stretch",
}

const $alignmentWrapperFlexOptions = {
  "top": "flex-start",
  "center": "center",
  "space-between": "space-between",
  "force-footer-bottom": "space-between",
} as const

const $containerPresets: Record<Presets, ThemedStyleArray<ViewStyle>> = {
  default: [
    $styles.row,
    $containerBase,
    (theme) => ({
      backgroundColor: theme.colors.palette.neutral100,
      borderColor: theme.colors.palette.neutral300,
    }),
  ],
  reversed: [
    $styles.row,
    $containerBase,
    (theme) => ({
      backgroundColor: theme.colors.palette.neutral800,
      borderColor: theme.colors.palette.neutral500,
    }),
  ],
}

const $headingPresets: Record<Presets, ThemedStyleArray<TextStyle>> = {
  default: [],
  reversed: [(theme) => ({ color: theme.colors.palette.neutral100 })],
}

const $contentPresets: Record<Presets, ThemedStyleArray<TextStyle>> = {
  default: [],
  reversed: [(theme) => ({ color: theme.colors.palette.neutral100 })],
}

const $footerPresets: Record<Presets, ThemedStyleArray<TextStyle>> = {
  default: [],
  reversed: [(theme) => ({ color: theme.colors.palette.neutral100 })],
}
===== END FILE: app/components/Card.tsx =====


===== BEGIN FILE: app/components/AutoImage.tsx =====
import { useLayoutEffect, useState } from "react"
import { Image, ImageProps, ImageURISource, Platform, PixelRatio } from "react-native"

export interface AutoImageProps extends ImageProps {
  /**
   * How wide should the image be?
   */
  maxWidth?: number
  /**
   * How tall should the image be?
   */
  maxHeight?: number
  headers?: {
    [key: string]: string
  }
}

/**
 * A hook that will return the scaled dimensions of an image based on the
 * provided dimensions' aspect ratio. If no desired dimensions are provided,
 * it will return the original dimensions of the remote image.
 *
 * How is this different from `resizeMode: 'contain'`? Firstly, you can
 * specify only one side's size (not both). Secondly, the image will scale to fit
 * the desired dimensions instead of just being contained within its image-container.
 * @param {number} remoteUri - The URI of the remote image.
 * @param {number} dimensions - The desired dimensions of the image. If not provided, the original dimensions will be returned.
 * @returns {[number, number]} - The scaled dimensions of the image.
 */
export function useAutoImage(
  remoteUri: string,
  headers?: {
    [key: string]: string
  },
  dimensions?: [maxWidth?: number, maxHeight?: number],
): [width: number, height: number] {
  const [[remoteWidth, remoteHeight], setRemoteImageDimensions] = useState([0, 0])
  const remoteAspectRatio = remoteWidth / remoteHeight
  const [maxWidth, maxHeight] = dimensions ?? []

  useLayoutEffect(() => {
    if (!remoteUri) return

    if (!headers) {
      Image.getSize(remoteUri, (w, h) => setRemoteImageDimensions([w, h]))
    } else {
      Image.getSizeWithHeaders(remoteUri, headers, (w, h) => setRemoteImageDimensions([w, h]))
    }
  }, [remoteUri, headers])

  if (Number.isNaN(remoteAspectRatio)) return [0, 0]

  if (maxWidth && maxHeight) {
    const aspectRatio = Math.min(maxWidth / remoteWidth, maxHeight / remoteHeight)
    return [
      PixelRatio.roundToNearestPixel(remoteWidth * aspectRatio),
      PixelRatio.roundToNearestPixel(remoteHeight * aspectRatio),
    ]
  } else if (maxWidth) {
    return [maxWidth, PixelRatio.roundToNearestPixel(maxWidth / remoteAspectRatio)]
  } else if (maxHeight) {
    return [PixelRatio.roundToNearestPixel(maxHeight * remoteAspectRatio), maxHeight]
  } else {
    return [remoteWidth, remoteHeight]
  }
}

/**
 * An Image component that automatically sizes a remote or data-uri image.
 * @see [Documentation and Examples]{@link https://docs.infinite.red/ignite-cli/boilerplate/app/components/AutoImage/}
 * @param {AutoImageProps} props - The props for the `AutoImage` component.
 * @returns {JSX.Element} The rendered `AutoImage` component.
 */
export function AutoImage(props: AutoImageProps) {
  const { maxWidth, maxHeight, ...ImageProps } = props
  const source = props.source as ImageURISource
  const headers = source?.headers

  const [width, height] = useAutoImage(
    Platform.select({
      web: (source?.uri as string) ?? (source as string),
      default: source?.uri as string,
    }),
    headers,
    [maxWidth, maxHeight],
  )

  return <Image {...ImageProps} style={[{ width, height }, props.style]} />
}
===== END FILE: app/components/AutoImage.tsx =====


===== BEGIN FILE: app/components/Icon.tsx =====
import {
  Image,
  ImageStyle,
  StyleProp,
  TouchableOpacity,
  TouchableOpacityProps,
  View,
  ViewProps,
  ViewStyle,
} from "react-native"

import { useAppTheme } from "@/theme/context"

export type IconTypes = keyof typeof iconRegistry

type BaseIconProps = {
  /**
   * The name of the icon
   */
  icon: IconTypes

  /**
   * An optional tint color for the icon
   */
  color?: string

  /**
   * An optional size for the icon. If not provided, the icon will be sized to the icon's resolution.
   */
  size?: number

  /**
   * Style overrides for the icon image
   */
  style?: StyleProp<ImageStyle>

  /**
   * Style overrides for the icon container
   */
  containerStyle?: StyleProp<ViewStyle>
}

type PressableIconProps = Omit<TouchableOpacityProps, "style"> & BaseIconProps
type IconProps = Omit<ViewProps, "style"> & BaseIconProps

/**
 * A component to render a registered icon.
 * It is wrapped in a <TouchableOpacity />
 * @see [Documentation and Examples]{@link https://docs.infinite.red/ignite-cli/boilerplate/app/components/Icon/}
 * @param {PressableIconProps} props - The props for the `PressableIcon` component.
 * @returns {JSX.Element} The rendered `PressableIcon` component.
 */
export function PressableIcon(props: PressableIconProps) {
  const {
    icon,
    color,
    size,
    style: $imageStyleOverride,
    containerStyle: $containerStyleOverride,
    ...pressableProps
  } = props

  const { theme } = useAppTheme()

  const $imageStyle: StyleProp<ImageStyle> = [
    $imageStyleBase,
    { tintColor: color ?? theme.colors.text },
    size !== undefined && { width: size, height: size },
    $imageStyleOverride,
  ]

  return (
    <TouchableOpacity {...pressableProps} style={$containerStyleOverride}>
      <Image style={$imageStyle} source={iconRegistry[icon]} />
    </TouchableOpacity>
  )
}

/**
 * A component to render a registered icon.
 * It is wrapped in a <View />, use `PressableIcon` if you want to react to input
 * @see [Documentation and Examples]{@link https://docs.infinite.red/ignite-cli/boilerplate/app/components/Icon/}
 * @param {IconProps} props - The props for the `Icon` component.
 * @returns {JSX.Element} The rendered `Icon` component.
 */
export function Icon(props: IconProps) {
  const {
    icon,
    color,
    size,
    style: $imageStyleOverride,
    containerStyle: $containerStyleOverride,
    ...viewProps
  } = props

  const { theme } = useAppTheme()

  const $imageStyle: StyleProp<ImageStyle> = [
    $imageStyleBase,
    { tintColor: color ?? theme.colors.text },
    size !== undefined && { width: size, height: size },
    $imageStyleOverride,
  ]

  return (
    <View {...viewProps} style={$containerStyleOverride}>
      <Image style={$imageStyle} source={iconRegistry[icon]} />
    </View>
  )
}

export const iconRegistry = {
  back: require("@assets/icons/back.png"),
  bell: require("@assets/icons/bell.png"),
  caretLeft: require("@assets/icons/caretLeft.png"),
  caretRight: require("@assets/icons/caretRight.png"),
  check: require("@assets/icons/check.png"),
  clap: require("@assets/icons/demo/clap.png"), // @demo remove-current-line
  community: require("@assets/icons/demo/community.png"), // @demo remove-current-line
  components: require("@assets/icons/demo/components.png"), // @demo remove-current-line
  debug: require("@assets/icons/demo/debug.png"), // @demo remove-current-line
  github: require("@assets/icons/demo/github.png"), // @demo remove-current-line
  heart: require("@assets/icons/demo/heart.png"), // @demo remove-current-line
  hidden: require("@assets/icons/hidden.png"),
  ladybug: require("@assets/icons/ladybug.png"),
  lock: require("@assets/icons/lock.png"),
  menu: require("@assets/icons/menu.png"),
  more: require("@assets/icons/more.png"),
  pin: require("@assets/icons/demo/pin.png"), // @demo remove-current-line
  podcast: require("@assets/icons/demo/podcast.png"), // @demo remove-current-line
  settings: require("@assets/icons/settings.png"),
  slack: require("@assets/icons/demo/slack.png"), // @demo remove-current-line
  view: require("@assets/icons/view.png"),
  x: require("@assets/icons/x.png"),
}

const $imageStyleBase: ImageStyle = {
  resizeMode: "contain",
}
===== END FILE: app/components/Icon.tsx =====


===== BEGIN FILE: app/components/RatingBadge.tsx =====
import React from "react"
import { View, StyleSheet } from "react-native"
import { Text } from "@/components/Text"

export function RatingBadge({ value }: { value?: number | null }) {
  if (value == null) return null
  return (
    <View style={styles.badge}>
      <Text style={styles.text}>{value.toFixed(1)} ⭐️</Text>
    </View>
  )
}

const styles = StyleSheet.create({
  badge: {
    backgroundColor: "rgba(0,0,0,0.7)",
    paddingHorizontal: 8,
    paddingVertical: 4,
    borderRadius: 15,
  },
  text: { color: "#fff", fontWeight: "600", fontSize: 12 },
})
===== END FILE: app/components/RatingBadge.tsx =====


===== BEGIN FILE: app/components/TextField.tsx =====
import { ComponentType, forwardRef, Ref, useImperativeHandle, useRef } from "react"
import {
  ImageStyle,
  StyleProp,
  // eslint-disable-next-line no-restricted-imports
  TextInput,
  TextInputProps,
  TextStyle,
  TouchableOpacity,
  View,
  ViewStyle,
} from "react-native"

import { isRTL } from "@/i18n"
import { translate } from "@/i18n/translate"
import type { ThemedStyle, ThemedStyleArray } from "@/theme/types"
import { useAppTheme } from "@/theme/context"
import { $styles } from "@/theme/styles"

import { Text, TextProps } from "./Text"

export interface TextFieldAccessoryProps {
  style: StyleProp<ViewStyle | TextStyle | ImageStyle>
  status: TextFieldProps["status"]
  multiline: boolean
  editable: boolean
}

export interface TextFieldProps extends Omit<TextInputProps, "ref"> {
  /**
   * A style modifier for different input states.
   */
  status?: "error" | "disabled"
  /**
   * The label text to display if not using `labelTx`.
   */
  label?: TextProps["text"]
  /**
   * Label text which is looked up via i18n.
   */
  labelTx?: TextProps["tx"]
  /**
   * Optional label options to pass to i18n. Useful for interpolation
   * as well as explicitly setting locale or translation fallbacks.
   */
  labelTxOptions?: TextProps["txOptions"]
  /**
   * Pass any additional props directly to the label Text component.
   */
  LabelTextProps?: TextProps
  /**
   * The helper text to display if not using `helperTx`.
   */
  helper?: TextProps["text"]
  /**
   * Helper text which is looked up via i18n.
   */
  helperTx?: TextProps["tx"]
  /**
   * Optional helper options to pass to i18n. Useful for interpolation
   * as well as explicitly setting locale or translation fallbacks.
   */
  helperTxOptions?: TextProps["txOptions"]
  /**
   * Pass any additional props directly to the helper Text component.
   */
  HelperTextProps?: TextProps
  /**
   * The placeholder text to display if not using `placeholderTx`.
   */
  placeholder?: TextProps["text"]
  /**
   * Placeholder text which is looked up via i18n.
   */
  placeholderTx?: TextProps["tx"]
  /**
   * Optional placeholder options to pass to i18n. Useful for interpolation
   * as well as explicitly setting locale or translation fallbacks.
   */
  placeholderTxOptions?: TextProps["txOptions"]
  /**
   * Optional input style override.
   */
  style?: StyleProp<TextStyle>
  /**
   * Style overrides for the container
   */
  containerStyle?: StyleProp<ViewStyle>
  /**
   * Style overrides for the input wrapper
   */
  inputWrapperStyle?: StyleProp<ViewStyle>
  /**
   * An optional component to render on the right side of the input.
   * Example: `RightAccessory={(props) => <Icon icon="ladybug" containerStyle={props.style} color={props.editable ? colors.textDim : colors.text} />}`
   * Note: It is a good idea to memoize this.
   */
  RightAccessory?: ComponentType<TextFieldAccessoryProps>
  /**
   * An optional component to render on the left side of the input.
   * Example: `LeftAccessory={(props) => <Icon icon="ladybug" containerStyle={props.style} color={props.editable ? colors.textDim : colors.text} />}`
   * Note: It is a good idea to memoize this.
   */
  LeftAccessory?: ComponentType<TextFieldAccessoryProps>
}

/**
 * A component that allows for the entering and editing of text.
 * @see [Documentation and Examples]{@link https://docs.infinite.red/ignite-cli/boilerplate/app/components/TextField/}
 * @param {TextFieldProps} props - The props for the `TextField` component.
 * @returns {JSX.Element} The rendered `TextField` component.
 */
export const TextField = forwardRef(function TextField(props: TextFieldProps, ref: Ref<TextInput>) {
  const {
    labelTx,
    label,
    labelTxOptions,
    placeholderTx,
    placeholder,
    placeholderTxOptions,
    helper,
    helperTx,
    helperTxOptions,
    status,
    RightAccessory,
    LeftAccessory,
    HelperTextProps,
    LabelTextProps,
    style: $inputStyleOverride,
    containerStyle: $containerStyleOverride,
    inputWrapperStyle: $inputWrapperStyleOverride,
    ...TextInputProps
  } = props
  const input = useRef<TextInput>(null)

  const {
    themed,
    theme: { colors },
  } = useAppTheme()

  const disabled = TextInputProps.editable === false || status === "disabled"

  const placeholderContent = placeholderTx
    ? translate(placeholderTx, placeholderTxOptions)
    : placeholder

  const $containerStyles = [$containerStyleOverride]

  const $labelStyles = [$labelStyle, LabelTextProps?.style]

  const $inputWrapperStyles = [
    $styles.row,
    $inputWrapperStyle,
    status === "error" && { borderColor: colors.error },
    TextInputProps.multiline && { minHeight: 112 },
    LeftAccessory && { paddingStart: 0 },
    RightAccessory && { paddingEnd: 0 },
    $inputWrapperStyleOverride,
  ]

  const $inputStyles: ThemedStyleArray<TextStyle> = [
    $inputStyle,
    disabled && { color: colors.textDim },
    isRTL && { textAlign: "right" as TextStyle["textAlign"] },
    TextInputProps.multiline && { height: "auto" },
    $inputStyleOverride,
  ]

  const $helperStyles = [
    $helperStyle,
    status === "error" && { color: colors.error },
    HelperTextProps?.style,
  ]

  /**
   *
   */
  function focusInput() {
    if (disabled) return

    input.current?.focus()
  }

  useImperativeHandle(ref, () => input.current as TextInput)

  return (
    <TouchableOpacity
      activeOpacity={1}
      style={$containerStyles}
      onPress={focusInput}
      accessibilityState={{ disabled }}
    >
      {!!(label || labelTx) && (
        <Text
          preset="formLabel"
          text={label}
          tx={labelTx}
          txOptions={labelTxOptions}
          {...LabelTextProps}
          style={themed($labelStyles)}
        />
      )}

      <View style={themed($inputWrapperStyles)}>
        {!!LeftAccessory && (
          <LeftAccessory
            style={themed($leftAccessoryStyle)}
            status={status}
            editable={!disabled}
            multiline={TextInputProps.multiline ?? false}
          />
        )}

        <TextInput
          ref={input}
          underlineColorAndroid={colors.transparent}
          textAlignVertical="top"
          placeholder={placeholderContent}
          placeholderTextColor={colors.textDim}
          {...TextInputProps}
          editable={!disabled}
          style={themed($inputStyles)}
        />

        {!!RightAccessory && (
          <RightAccessory
            style={themed($rightAccessoryStyle)}
            status={status}
            editable={!disabled}
            multiline={TextInputProps.multiline ?? false}
          />
        )}
      </View>

      {!!(helper || helperTx) && (
        <Text
          preset="formHelper"
          text={helper}
          tx={helperTx}
          txOptions={helperTxOptions}
          {...HelperTextProps}
          style={themed($helperStyles)}
        />
      )}
    </TouchableOpacity>
  )
})

const $labelStyle: ThemedStyle<TextStyle> = ({ spacing }) => ({
  marginBottom: spacing.xs,
})

const $inputWrapperStyle: ThemedStyle<ViewStyle> = ({ colors }) => ({
  alignItems: "flex-start",
  borderWidth: 1,
  borderRadius: 4,
  backgroundColor: colors.palette.neutral200,
  borderColor: colors.palette.neutral400,
  overflow: "hidden",
})

const $inputStyle: ThemedStyle<TextStyle> = ({ colors, typography, spacing }) => ({
  flex: 1,
  alignSelf: "stretch",
  fontFamily: typography.primary.normal,
  color: colors.text,
  fontSize: 16,
  height: 24,
  // https://github.com/facebook/react-native/issues/21720#issuecomment-532642093
  paddingVertical: 0,
  paddingHorizontal: 0,
  marginVertical: spacing.xs,
  marginHorizontal: spacing.sm,
})

const $helperStyle: ThemedStyle<TextStyle> = ({ spacing }) => ({
  marginTop: spacing.xs,
})

const $rightAccessoryStyle: ThemedStyle<ViewStyle> = ({ spacing }) => ({
  marginEnd: spacing.xs,
  height: 40,
  justifyContent: "center",
  alignItems: "center",
})

const $leftAccessoryStyle: ThemedStyle<ViewStyle> = ({ spacing }) => ({
  marginStart: spacing.xs,
  height: 40,
  justifyContent: "center",
  alignItems: "center",
})
===== END FILE: app/components/TextField.tsx =====


===== BEGIN FILE: app/components/Screen.tsx =====
import { ReactNode, useRef, useState } from "react"
import {
  KeyboardAvoidingView,
  KeyboardAvoidingViewProps,
  LayoutChangeEvent,
  Platform,
  ScrollView,
  ScrollViewProps,
  StyleProp,
  View,
  ViewStyle,
} from "react-native"
import { useScrollToTop } from "@react-navigation/native"
import { SystemBars, SystemBarsProps, SystemBarStyle } from "react-native-edge-to-edge"
import { KeyboardAwareScrollView } from "react-native-keyboard-controller"

import { useAppTheme } from "@/theme/context"
import { $styles } from "@/theme/styles"
import { ExtendedEdge, useSafeAreaInsetsStyle } from "@/utils/useSafeAreaInsetsStyle"

export const DEFAULT_BOTTOM_OFFSET = 50

interface BaseScreenProps {
  /**
   * Children components.
   */
  children?: ReactNode
  /**
   * Style for the outer content container useful for padding & margin.
   */
  style?: StyleProp<ViewStyle>
  /**
   * Style for the inner content container useful for padding & margin.
   */
  contentContainerStyle?: StyleProp<ViewStyle>
  /**
   * Override the default edges for the safe area.
   */
  safeAreaEdges?: ExtendedEdge[]
  /**
   * Background color
   */
  backgroundColor?: string
  /**
   * System bar setting. Defaults to dark.
   */
  systemBarStyle?: SystemBarStyle
  /**
   * By how much should we offset the keyboard? Defaults to 0.
   */
  keyboardOffset?: number
  /**
   * By how much we scroll up when the keyboard is shown. Defaults to 50.
   */
  keyboardBottomOffset?: number
  /**
   * Pass any additional props directly to the SystemBars component.
   */
  SystemBarsProps?: SystemBarsProps
  /**
   * Pass any additional props directly to the KeyboardAvoidingView component.
   */
  KeyboardAvoidingViewProps?: KeyboardAvoidingViewProps
}

interface FixedScreenProps extends BaseScreenProps {
  preset?: "fixed"
}
interface ScrollScreenProps extends BaseScreenProps {
  preset?: "scroll"
  /**
   * Should keyboard persist on screen tap. Defaults to handled.
   * Only applies to scroll preset.
   */
  keyboardShouldPersistTaps?: "handled" | "always" | "never"
  /**
   * Pass any additional props directly to the ScrollView component.
   */
  ScrollViewProps?: ScrollViewProps
}

interface AutoScreenProps extends Omit<ScrollScreenProps, "preset"> {
  preset?: "auto"
  /**
   * Threshold to trigger the automatic disabling/enabling of scroll ability.
   * Defaults to `{ percent: 0.92 }`.
   */
  scrollEnabledToggleThreshold?: { percent?: number; point?: number }
}

export type ScreenProps = ScrollScreenProps | FixedScreenProps | AutoScreenProps

const isIos = Platform.OS === "ios"

type ScreenPreset = "fixed" | "scroll" | "auto"

/**
 * @param {ScreenPreset?} preset - The preset to check.
 * @returns {boolean} - Whether the preset is non-scrolling.
 */
function isNonScrolling(preset?: ScreenPreset) {
  return !preset || preset === "fixed"
}

/**
 * Custom hook that handles the automatic enabling/disabling of scroll ability based on the content size and screen size.
 * @param {UseAutoPresetProps} props - The props for the `useAutoPreset` hook.
 * @returns {{boolean, Function, Function}} - The scroll state, and the `onContentSizeChange` and `onLayout` functions.
 */
function useAutoPreset(props: AutoScreenProps): {
  scrollEnabled: boolean
  onContentSizeChange: (w: number, h: number) => void
  onLayout: (e: LayoutChangeEvent) => void
} {
  const { preset, scrollEnabledToggleThreshold } = props
  const { percent = 0.92, point = 0 } = scrollEnabledToggleThreshold || {}

  const scrollViewHeight = useRef<null | number>(null)
  const scrollViewContentHeight = useRef<null | number>(null)
  const [scrollEnabled, setScrollEnabled] = useState(true)

  function updateScrollState() {
    if (scrollViewHeight.current === null || scrollViewContentHeight.current === null) return

    // check whether content fits the screen then toggle scroll state according to it
    const contentFitsScreen = (function () {
      if (point) {
        return scrollViewContentHeight.current < scrollViewHeight.current - point
      } else {
        return scrollViewContentHeight.current < scrollViewHeight.current * percent
      }
    })()

    // content is less than the size of the screen, so we can disable scrolling
    if (scrollEnabled && contentFitsScreen) setScrollEnabled(false)

    // content is greater than the size of the screen, so let's enable scrolling
    if (!scrollEnabled && !contentFitsScreen) setScrollEnabled(true)
  }

  /**
   * @param {number} w - The width of the content.
   * @param {number} h - The height of the content.
   */
  function onContentSizeChange(w: number, h: number) {
    // update scroll-view content height
    scrollViewContentHeight.current = h
    updateScrollState()
  }

  /**
   * @param {LayoutChangeEvent} e = The layout change event.
   */
  function onLayout(e: LayoutChangeEvent) {
    const { height } = e.nativeEvent.layout
    // update scroll-view  height
    scrollViewHeight.current = height
    updateScrollState()
  }

  // update scroll state on every render
  if (preset === "auto") updateScrollState()

  return {
    scrollEnabled: preset === "auto" ? scrollEnabled : true,
    onContentSizeChange,
    onLayout,
  }
}

/**
 * @param {ScreenProps} props - The props for the `ScreenWithoutScrolling` component.
 * @returns {JSX.Element} - The rendered `ScreenWithoutScrolling` component.
 */
function ScreenWithoutScrolling(props: ScreenProps) {
  const { style, contentContainerStyle, children, preset } = props
  return (
    <View style={[$outerStyle, style]}>
      <View style={[$innerStyle, preset === "fixed" && $justifyFlexEnd, contentContainerStyle]}>
        {children}
      </View>
    </View>
  )
}

/**
 * @param {ScreenProps} props - The props for the `ScreenWithScrolling` component.
 * @returns {JSX.Element} - The rendered `ScreenWithScrolling` component.
 */
function ScreenWithScrolling(props: ScreenProps) {
  const {
    children,
    keyboardShouldPersistTaps = "handled",
    keyboardBottomOffset = DEFAULT_BOTTOM_OFFSET,
    contentContainerStyle,
    ScrollViewProps,
    style,
  } = props as ScrollScreenProps

  const ref = useRef<ScrollView>(null)

  const { scrollEnabled, onContentSizeChange, onLayout } = useAutoPreset(props as AutoScreenProps)

  // Add native behavior of pressing the active tab to scroll to the top of the content
  // More info at: https://reactnavigation.org/docs/use-scroll-to-top/
  useScrollToTop(ref)

  return (
    <KeyboardAwareScrollView
      bottomOffset={keyboardBottomOffset}
      {...{ keyboardShouldPersistTaps, scrollEnabled, ref }}
      {...ScrollViewProps}
      onLayout={(e) => {
        onLayout(e)
        ScrollViewProps?.onLayout?.(e)
      }}
      onContentSizeChange={(w: number, h: number) => {
        onContentSizeChange(w, h)
        ScrollViewProps?.onContentSizeChange?.(w, h)
      }}
      style={[$outerStyle, ScrollViewProps?.style, style]}
      contentContainerStyle={[
        $innerStyle,
        ScrollViewProps?.contentContainerStyle,
        contentContainerStyle,
      ]}
    >
      {children}
    </KeyboardAwareScrollView>
  )
}

/**
 * Represents a screen component that provides a consistent layout and behavior for different screen presets.
 * The `Screen` component can be used with different presets such as "fixed", "scroll", or "auto".
 * It handles safe area insets, status bar settings, keyboard avoiding behavior, and scrollability based on the preset.
 * @see [Documentation and Examples]{@link https://docs.infinite.red/ignite-cli/boilerplate/app/components/Screen/}
 * @param {ScreenProps} props - The props for the `Screen` component.
 * @returns {JSX.Element} The rendered `Screen` component.
 */
export function Screen(props: ScreenProps) {
  const {
    theme: { colors },
    themeContext,
  } = useAppTheme()
  const {
    backgroundColor,
    KeyboardAvoidingViewProps,
    keyboardOffset = 0,
    safeAreaEdges,
    SystemBarsProps,
    systemBarStyle,
  } = props

  const $containerInsets = useSafeAreaInsetsStyle(safeAreaEdges)

  return (
    <View
      style={[
        $containerStyle,
        { backgroundColor: backgroundColor || colors.background },
        $containerInsets,
      ]}
    >
      <SystemBars
        style={systemBarStyle || (themeContext === "dark" ? "light" : "dark")}
        {...SystemBarsProps}
      />

      <KeyboardAvoidingView
        behavior={isIos ? "padding" : "height"}
        keyboardVerticalOffset={keyboardOffset}
        {...KeyboardAvoidingViewProps}
        style={[$styles.flex1, KeyboardAvoidingViewProps?.style]}
      >
        {isNonScrolling(props.preset) ? (
          <ScreenWithoutScrolling {...props} />
        ) : (
          <ScreenWithScrolling {...props} />
        )}
      </KeyboardAvoidingView>
    </View>
  )
}

const $containerStyle: ViewStyle = {
  flex: 1,
  height: "100%",
  width: "100%",
}

const $outerStyle: ViewStyle = {
  flex: 1,
  height: "100%",
  width: "100%",
}

const $justifyFlexEnd: ViewStyle = {
  justifyContent: "flex-end",
}

const $innerStyle: ViewStyle = {
  justifyContent: "flex-start",
  alignItems: "stretch",
}
===== END FILE: app/components/Screen.tsx =====


===== BEGIN FILE: app/components/Header.tsx =====
import { ReactElement } from "react"
import {
  StyleProp,
  TextStyle,
  TouchableOpacity,
  TouchableOpacityProps,
  View,
  ViewStyle,
} from "react-native"

import { isRTL } from "@/i18n"
import { translate } from "@/i18n/translate"
import type { ThemedStyle } from "@/theme/types"
import { useAppTheme } from "@/theme/context"
import { $styles } from "@/theme/styles"
import { ExtendedEdge, useSafeAreaInsetsStyle } from "@/utils/useSafeAreaInsetsStyle"

import { IconTypes, PressableIcon } from "./Icon"
import { Text, TextProps } from "./Text"

export interface HeaderProps {
  /**
   * The layout of the title relative to the action components.
   * - `center` will force the title to always be centered relative to the header. If the title or the action buttons are too long, the title will be cut off.
   * - `flex` will attempt to center the title relative to the action buttons. If the action buttons are different widths, the title will be off-center relative to the header.
   */
  titleMode?: "center" | "flex"
  /**
   * Optional title style override.
   */
  titleStyle?: StyleProp<TextStyle>
  /**
   * Optional outer title container style override.
   */
  titleContainerStyle?: StyleProp<ViewStyle>
  /**
   * Optional inner header wrapper style override.
   */
  style?: StyleProp<ViewStyle>
  /**
   * Optional outer header container style override.
   */
  containerStyle?: StyleProp<ViewStyle>
  /**
   * Background color
   */
  backgroundColor?: string
  /**
   * Title text to display if not using `tx` or nested components.
   */
  title?: TextProps["text"]
  /**
   * Title text which is looked up via i18n.
   */
  titleTx?: TextProps["tx"]
  /**
   * Optional options to pass to i18n. Useful for interpolation
   * as well as explicitly setting locale or translation fallbacks.
   */
  titleTxOptions?: TextProps["txOptions"]
  /**
   * Icon that should appear on the left.
   * Can be used with `onLeftPress`.
   */
  leftIcon?: IconTypes
  /**
   * An optional tint color for the left icon
   */
  leftIconColor?: string
  /**
   * Left action text to display if not using `leftTx`.
   * Can be used with `onLeftPress`. Overrides `leftIcon`.
   */
  leftText?: TextProps["text"]
  /**
   * Left action text text which is looked up via i18n.
   * Can be used with `onLeftPress`. Overrides `leftIcon`.
   */
  leftTx?: TextProps["tx"]
  /**
   * Left action custom ReactElement if the built in action props don't suffice.
   * Overrides `leftIcon`, `leftTx` and `leftText`.
   */
  LeftActionComponent?: ReactElement
  /**
   * Optional options to pass to i18n. Useful for interpolation
   * as well as explicitly setting locale or translation fallbacks.
   */
  leftTxOptions?: TextProps["txOptions"]
  /**
   * What happens when you press the left icon or text action.
   */
  onLeftPress?: TouchableOpacityProps["onPress"]
  /**
   * Icon that should appear on the right.
   * Can be used with `onRightPress`.
   */
  rightIcon?: IconTypes
  /**
   * An optional tint color for the right icon
   */
  rightIconColor?: string
  /**
   * Right action text to display if not using `rightTx`.
   * Can be used with `onRightPress`. Overrides `rightIcon`.
   */
  rightText?: TextProps["text"]
  /**
   * Right action text text which is looked up via i18n.
   * Can be used with `onRightPress`. Overrides `rightIcon`.
   */
  rightTx?: TextProps["tx"]
  /**
   * Right action custom ReactElement if the built in action props don't suffice.
   * Overrides `rightIcon`, `rightTx` and `rightText`.
   */
  RightActionComponent?: ReactElement
  /**
   * Optional options to pass to i18n. Useful for interpolation
   * as well as explicitly setting locale or translation fallbacks.
   */
  rightTxOptions?: TextProps["txOptions"]
  /**
   * What happens when you press the right icon or text action.
   */
  onRightPress?: TouchableOpacityProps["onPress"]
  /**
   * Override the default edges for the safe area.
   */
  safeAreaEdges?: ExtendedEdge[]
}

interface HeaderActionProps {
  backgroundColor?: string
  icon?: IconTypes
  iconColor?: string
  text?: TextProps["text"]
  tx?: TextProps["tx"]
  txOptions?: TextProps["txOptions"]
  onPress?: TouchableOpacityProps["onPress"]
  ActionComponent?: ReactElement
}

/**
 * Header that appears on many screens. Will hold navigation buttons and screen title.
 * The Header is meant to be used with the `screenOptions.header` option on navigators, routes, or screen components via `navigation.setOptions({ header })`.
 * @see [Documentation and Examples]{@link https://docs.infinite.red/ignite-cli/boilerplate/app/components/Header/}
 * @param {HeaderProps} props - The props for the `Header` component.
 * @returns {JSX.Element} The rendered `Header` component.
 */
export function Header(props: HeaderProps) {
  const {
    theme: { colors },
    themed,
  } = useAppTheme()
  const {
    backgroundColor = colors.background,
    LeftActionComponent,
    leftIcon,
    leftIconColor,
    leftText,
    leftTx,
    leftTxOptions,
    onLeftPress,
    onRightPress,
    RightActionComponent,
    rightIcon,
    rightIconColor,
    rightText,
    rightTx,
    rightTxOptions,
    safeAreaEdges = ["top"],
    title,
    titleMode = "center",
    titleTx,
    titleTxOptions,
    titleContainerStyle: $titleContainerStyleOverride,
    style: $styleOverride,
    titleStyle: $titleStyleOverride,
    containerStyle: $containerStyleOverride,
  } = props

  const $containerInsets = useSafeAreaInsetsStyle(safeAreaEdges)

  const titleContent = titleTx ? translate(titleTx, titleTxOptions) : title

  return (
    <View style={[$container, $containerInsets, { backgroundColor }, $containerStyleOverride]}>
      <View style={[$styles.row, $wrapper, $styleOverride]}>
        <HeaderAction
          tx={leftTx}
          text={leftText}
          icon={leftIcon}
          iconColor={leftIconColor}
          onPress={onLeftPress}
          txOptions={leftTxOptions}
          backgroundColor={backgroundColor}
          ActionComponent={LeftActionComponent}
        />

        {!!titleContent && (
          <View
            style={[
              $titleWrapperPointerEvents,
              titleMode === "center" && themed($titleWrapperCenter),
              titleMode === "flex" && $titleWrapperFlex,
              $titleContainerStyleOverride,
            ]}
          >
            <Text
              weight="medium"
              size="md"
              text={titleContent}
              style={[$title, $titleStyleOverride]}
            />
          </View>
        )}

        <HeaderAction
          tx={rightTx}
          text={rightText}
          icon={rightIcon}
          iconColor={rightIconColor}
          onPress={onRightPress}
          txOptions={rightTxOptions}
          backgroundColor={backgroundColor}
          ActionComponent={RightActionComponent}
        />
      </View>
    </View>
  )
}

/**
 * @param {HeaderActionProps} props - The props for the `HeaderAction` component.
 * @returns {JSX.Element} The rendered `HeaderAction` component.
 */
function HeaderAction(props: HeaderActionProps) {
  const { backgroundColor, icon, text, tx, txOptions, onPress, ActionComponent, iconColor } = props
  const { themed } = useAppTheme()

  const content = tx ? translate(tx, txOptions) : text

  if (ActionComponent) return ActionComponent

  if (content) {
    return (
      <TouchableOpacity
        style={themed([$actionTextContainer, { backgroundColor }])}
        onPress={onPress}
        disabled={!onPress}
        activeOpacity={0.8}
      >
        <Text weight="medium" size="md" text={content} style={themed($actionText)} />
      </TouchableOpacity>
    )
  }

  if (icon) {
    return (
      <PressableIcon
        size={24}
        icon={icon}
        color={iconColor}
        onPress={onPress}
        containerStyle={themed([$actionIconContainer, { backgroundColor }])}
        style={isRTL ? { transform: [{ rotate: "180deg" }] } : {}}
      />
    )
  }

  return <View style={[$actionFillerContainer, { backgroundColor }]} />
}

const $wrapper: ViewStyle = {
  height: 56,
  alignItems: "center",
  justifyContent: "space-between",
}

const $container: ViewStyle = {
  width: "100%",
}

const $title: TextStyle = {
  textAlign: "center",
}

const $actionTextContainer: ThemedStyle<ViewStyle> = ({ spacing }) => ({
  flexGrow: 0,
  alignItems: "center",
  justifyContent: "center",
  height: "100%",
  paddingHorizontal: spacing.md,
  zIndex: 2,
})

const $actionText: ThemedStyle<TextStyle> = ({ colors }) => ({
  color: colors.tint,
})

const $actionIconContainer: ThemedStyle<ViewStyle> = ({ spacing }) => ({
  flexGrow: 0,
  alignItems: "center",
  justifyContent: "center",
  height: "100%",
  paddingHorizontal: spacing.md,
  zIndex: 2,
})

const $actionFillerContainer: ViewStyle = {
  width: 16,
}

const $titleWrapperPointerEvents: ViewStyle = {
  pointerEvents: "none",
}

const $titleWrapperCenter: ThemedStyle<ViewStyle> = ({ spacing }) => ({
  alignItems: "center",
  justifyContent: "center",
  height: "100%",
  width: "100%",
  position: "absolute",
  paddingHorizontal: spacing.xxl,
  zIndex: 1,
})

const $titleWrapperFlex: ViewStyle = {
  justifyContent: "center",
  flexGrow: 1,
}
===== END FILE: app/components/Header.tsx =====


===== BEGIN FILE: app/components/ListItem.tsx =====
import { forwardRef, ReactElement, ComponentType } from "react"
import {
  StyleProp,
  TextStyle,
  TouchableOpacity,
  TouchableOpacityProps,
  View,
  ViewStyle,
} from "react-native"

import type { ThemedStyle } from "@/theme/types"
import { useAppTheme } from "@/theme/context"
import { $styles } from "@/theme/styles"

import { Icon, IconTypes } from "./Icon"
import { Text, TextProps } from "./Text"

export interface ListItemProps extends TouchableOpacityProps {
  /**
   * How tall the list item should be.
   * Default: 56
   */
  height?: number
  /**
   * Whether to show the top separator.
   * Default: false
   */
  topSeparator?: boolean
  /**
   * Whether to show the bottom separator.
   * Default: false
   */
  bottomSeparator?: boolean
  /**
   * Text to display if not using `tx` or nested components.
   */
  text?: TextProps["text"]
  /**
   * Text which is looked up via i18n.
   */
  tx?: TextProps["tx"]
  /**
   * Children components.
   */
  children?: TextProps["children"]
  /**
   * Optional options to pass to i18n. Useful for interpolation
   * as well as explicitly setting locale or translation fallbacks.
   */
  txOptions?: TextProps["txOptions"]
  /**
   * Optional text style override.
   */
  textStyle?: StyleProp<TextStyle>
  /**
   * Pass any additional props directly to the Text component.
   */
  TextProps?: TextProps
  /**
   * Optional View container style override.
   */
  containerStyle?: StyleProp<ViewStyle>
  /**
   * Optional TouchableOpacity style override.
   */
  style?: StyleProp<ViewStyle>
  /**
   * Icon that should appear on the left.
   */
  leftIcon?: IconTypes
  /**
   * An optional tint color for the left icon
   */
  leftIconColor?: string
  /**
   * Icon that should appear on the right.
   */
  rightIcon?: IconTypes
  /**
   * An optional tint color for the right icon
   */
  rightIconColor?: string
  /**
   * Right action custom ReactElement.
   * Overrides `rightIcon`.
   */
  RightComponent?: ReactElement
  /**
   * Left action custom ReactElement.
   * Overrides `leftIcon`.
   */
  LeftComponent?: ReactElement
}

interface ListItemActionProps {
  icon?: IconTypes
  iconColor?: string
  Component?: ReactElement
  size: number
  side: "left" | "right"
}

/**
 * A styled row component that can be used in FlatList, SectionList, or by itself.
 * @see [Documentation and Examples]{@link https://docs.infinite.red/ignite-cli/boilerplate/app/components/ListItem/}
 * @param {ListItemProps} props - The props for the `ListItem` component.
 * @returns {JSX.Element} The rendered `ListItem` component.
 */
export const ListItem = forwardRef<View, ListItemProps>(function ListItem(
  props: ListItemProps,
  ref,
) {
  const {
    bottomSeparator,
    children,
    height = 56,
    LeftComponent,
    leftIcon,
    leftIconColor,
    RightComponent,
    rightIcon,
    rightIconColor,
    style,
    text,
    TextProps,
    topSeparator,
    tx,
    txOptions,
    textStyle: $textStyleOverride,
    containerStyle: $containerStyleOverride,
    ...TouchableOpacityProps
  } = props
  const { themed } = useAppTheme()

  const isTouchable =
    TouchableOpacityProps.onPress !== undefined ||
    TouchableOpacityProps.onPressIn !== undefined ||
    TouchableOpacityProps.onPressOut !== undefined ||
    TouchableOpacityProps.onLongPress !== undefined

  const $textStyles = [$textStyle, $textStyleOverride, TextProps?.style]

  const $containerStyles = [
    topSeparator && $separatorTop,
    bottomSeparator && $separatorBottom,
    $containerStyleOverride,
  ]

  const $touchableStyles = [$styles.row, $touchableStyle, { minHeight: height }, style]

  const Wrapper: ComponentType<TouchableOpacityProps> = isTouchable ? TouchableOpacity : View

  return (
    <View ref={ref} style={themed($containerStyles)}>
      <Wrapper {...TouchableOpacityProps} style={$touchableStyles}>
        <ListItemAction
          side="left"
          size={height}
          icon={leftIcon}
          iconColor={leftIconColor}
          Component={LeftComponent}
        />

        <Text {...TextProps} tx={tx} text={text} txOptions={txOptions} style={themed($textStyles)}>
          {children}
        </Text>

        <ListItemAction
          side="right"
          size={height}
          icon={rightIcon}
          iconColor={rightIconColor}
          Component={RightComponent}
        />
      </Wrapper>
    </View>
  )
})

/**
 * @param {ListItemActionProps} props - The props for the `ListItemAction` component.
 * @returns {JSX.Element | null} The rendered `ListItemAction` component.
 */
function ListItemAction(props: ListItemActionProps) {
  const { icon, Component, iconColor, size, side } = props
  const { themed } = useAppTheme()

  const $iconContainerStyles = [$iconContainer]

  if (Component) return Component

  if (icon !== undefined) {
    return (
      <Icon
        size={24}
        icon={icon}
        color={iconColor}
        containerStyle={themed([
          $iconContainerStyles,
          side === "left" && $iconContainerLeft,
          side === "right" && $iconContainerRight,
          { height: size },
        ])}
      />
    )
  }

  return null
}

const $separatorTop: ThemedStyle<ViewStyle> = ({ colors }) => ({
  borderTopWidth: 1,
  borderTopColor: colors.separator,
})

const $separatorBottom: ThemedStyle<ViewStyle> = ({ colors }) => ({
  borderBottomWidth: 1,
  borderBottomColor: colors.separator,
})

const $textStyle: ThemedStyle<TextStyle> = ({ spacing }) => ({
  paddingVertical: spacing.xs,
  alignSelf: "center",
  flexGrow: 1,
  flexShrink: 1,
})

const $touchableStyle: ViewStyle = {
  alignItems: "flex-start",
}

const $iconContainer: ViewStyle = {
  justifyContent: "center",
  alignItems: "center",
  flexGrow: 0,
}
const $iconContainerLeft: ThemedStyle<ViewStyle> = ({ spacing }) => ({
  marginEnd: spacing.md,
})

const $iconContainerRight: ThemedStyle<ViewStyle> = ({ spacing }) => ({
  marginStart: spacing.md,
})
===== END FILE: app/components/ListItem.tsx =====


===== BEGIN FILE: app/components/Text.test.tsx =====
import { NavigationContainer } from "@react-navigation/native"
import { render } from "@testing-library/react-native"

import { Text } from "./Text"
import { ThemeProvider } from "../theme/context"

/* This is an example component test using react-native-testing-library. For more
 * information on how to write your own, see the documentation here:
 * https://callstack.github.io/react-native-testing-library/ */
const testText = "Test string"

describe("Text", () => {
  it("should render the component", () => {
    const { getByText } = render(
      <ThemeProvider>
        <NavigationContainer>
          <Text text={testText} />
        </NavigationContainer>
      </ThemeProvider>,
    )
    expect(getByText(testText)).toBeDefined()
  })
})
===== END FILE: app/components/Text.test.tsx =====


===== BEGIN FILE: app/components/Button.tsx =====
import { ComponentType } from "react"
import {
  Pressable,
  PressableProps,
  PressableStateCallbackType,
  StyleProp,
  TextStyle,
  ViewStyle,
} from "react-native"

import { useAppTheme } from "@/theme/context"
import { $styles } from "@/theme/styles"
import type { ThemedStyle, ThemedStyleArray } from "@/theme/types"

import { Text, TextProps } from "./Text"

type Presets = "default" | "filled" | "reversed"

export interface ButtonAccessoryProps {
  style: StyleProp<any>
  pressableState: PressableStateCallbackType
  disabled?: boolean
}

export interface ButtonProps extends PressableProps {
  /**
   * Text which is looked up via i18n.
   */
  tx?: TextProps["tx"]
  /**
   * The text to display if not using `tx` or nested components.
   */
  text?: TextProps["text"]
  /**
   * Optional options to pass to i18n. Useful for interpolation
   * as well as explicitly setting locale or translation fallbacks.
   */
  txOptions?: TextProps["txOptions"]
  /**
   * An optional style override useful for padding & margin.
   */
  style?: StyleProp<ViewStyle>
  /**
   * An optional style override for the "pressed" state.
   */
  pressedStyle?: StyleProp<ViewStyle>
  /**
   * An optional style override for the button text.
   */
  textStyle?: StyleProp<TextStyle>
  /**
   * An optional style override for the button text when in the "pressed" state.
   */
  pressedTextStyle?: StyleProp<TextStyle>
  /**
   * An optional style override for the button text when in the "disabled" state.
   */
  disabledTextStyle?: StyleProp<TextStyle>
  /**
   * One of the different types of button presets.
   */
  preset?: Presets
  /**
   * An optional component to render on the right side of the text.
   * Example: `RightAccessory={(props) => <View {...props} />}`
   */
  RightAccessory?: ComponentType<ButtonAccessoryProps>
  /**
   * An optional component to render on the left side of the text.
   * Example: `LeftAccessory={(props) => <View {...props} />}`
   */
  LeftAccessory?: ComponentType<ButtonAccessoryProps>
  /**
   * Children components.
   */
  children?: React.ReactNode
  /**
   * disabled prop, accessed directly for declarative styling reasons.
   * https://reactnative.dev/docs/pressable#disabled
   */
  disabled?: boolean
  /**
   * An optional style override for the disabled state
   */
  disabledStyle?: StyleProp<ViewStyle>
}

/**
 * A component that allows users to take actions and make choices.
 * Wraps the Text component with a Pressable component.
 * @see [Documentation and Examples]{@link https://docs.infinite.red/ignite-cli/boilerplate/app/components/Button/}
 * @param {ButtonProps} props - The props for the `Button` component.
 * @returns {JSX.Element} The rendered `Button` component.
 * @example
 * <Button
 *   tx="common:ok"
 *   style={styles.button}
 *   textStyle={styles.buttonText}
 *   onPress={handleButtonPress}
 * />
 */
export function Button(props: ButtonProps) {
  const {
    tx,
    text,
    txOptions,
    style: $viewStyleOverride,
    pressedStyle: $pressedViewStyleOverride,
    textStyle: $textStyleOverride,
    pressedTextStyle: $pressedTextStyleOverride,
    disabledTextStyle: $disabledTextStyleOverride,
    children,
    RightAccessory,
    LeftAccessory,
    disabled,
    disabledStyle: $disabledViewStyleOverride,
    ...rest
  } = props

  const { themed } = useAppTheme()

  const preset: Presets = props.preset ?? "default"
  /**
   * @param {PressableStateCallbackType} root0 - The root object containing the pressed state.
   * @param {boolean} root0.pressed - The pressed state.
   * @returns {StyleProp<ViewStyle>} The view style based on the pressed state.
   */
  function $viewStyle({ pressed }: PressableStateCallbackType): StyleProp<ViewStyle> {
    return [
      themed($viewPresets[preset]),
      $viewStyleOverride,
      !!pressed && themed([$pressedViewPresets[preset], $pressedViewStyleOverride]),
      !!disabled && $disabledViewStyleOverride,
    ]
  }
  /**
   * @param {PressableStateCallbackType} root0 - The root object containing the pressed state.
   * @param {boolean} root0.pressed - The pressed state.
   * @returns {StyleProp<TextStyle>} The text style based on the pressed state.
   */
  function $textStyle({ pressed }: PressableStateCallbackType): StyleProp<TextStyle> {
    return [
      themed($textPresets[preset]),
      $textStyleOverride,
      !!pressed && themed([$pressedTextPresets[preset], $pressedTextStyleOverride]),
      !!disabled && $disabledTextStyleOverride,
    ]
  }

  return (
    <Pressable
      style={$viewStyle}
      accessibilityRole="button"
      accessibilityState={{ disabled: !!disabled }}
      {...rest}
      disabled={disabled}
    >
      {(state) => (
        <>
          {!!LeftAccessory && (
            <LeftAccessory style={$leftAccessoryStyle} pressableState={state} disabled={disabled} />
          )}

          <Text tx={tx} text={text} txOptions={txOptions} style={$textStyle(state)}>
            {children}
          </Text>

          {!!RightAccessory && (
            <RightAccessory
              style={$rightAccessoryStyle}
              pressableState={state}
              disabled={disabled}
            />
          )}
        </>
      )}
    </Pressable>
  )
}

const $baseViewStyle: ThemedStyle<ViewStyle> = ({ spacing }) => ({
  minHeight: 56,
  borderRadius: 4,
  justifyContent: "center",
  alignItems: "center",
  paddingVertical: spacing.sm,
  paddingHorizontal: spacing.sm,
  overflow: "hidden",
})

const $baseTextStyle: ThemedStyle<TextStyle> = ({ typography }) => ({
  fontSize: 16,
  lineHeight: 20,
  fontFamily: typography.primary.medium,
  textAlign: "center",
  flexShrink: 1,
  flexGrow: 0,
  zIndex: 2,
})

const $rightAccessoryStyle: ThemedStyle<ViewStyle> = ({ spacing }) => ({
  marginStart: spacing.xs,
  zIndex: 1,
})
const $leftAccessoryStyle: ThemedStyle<ViewStyle> = ({ spacing }) => ({
  marginEnd: spacing.xs,
  zIndex: 1,
})

const $viewPresets: Record<Presets, ThemedStyleArray<ViewStyle>> = {
  default: [
    $styles.row,
    $baseViewStyle,
    ({ colors }) => ({
      borderWidth: 1,
      borderColor: colors.palette.neutral400,
      backgroundColor: colors.palette.neutral100,
    }),
  ],
  filled: [
    $styles.row,
    $baseViewStyle,
    ({ colors }) => ({ backgroundColor: colors.palette.neutral300 }),
  ],
  reversed: [
    $styles.row,
    $baseViewStyle,
    ({ colors }) => ({ backgroundColor: colors.palette.neutral800 }),
  ],
}

const $textPresets: Record<Presets, ThemedStyleArray<TextStyle>> = {
  default: [$baseTextStyle],
  filled: [$baseTextStyle],
  reversed: [$baseTextStyle, ({ colors }) => ({ color: colors.palette.neutral100 })],
}

const $pressedViewPresets: Record<Presets, ThemedStyle<ViewStyle>> = {
  default: ({ colors }) => ({ backgroundColor: colors.palette.neutral200 }),
  filled: ({ colors }) => ({ backgroundColor: colors.palette.neutral400 }),
  reversed: ({ colors }) => ({ backgroundColor: colors.palette.neutral700 }),
}

const $pressedTextPresets: Record<Presets, ThemedStyle<TextStyle>> = {
  default: () => ({ opacity: 0.9 }),
  filled: () => ({ opacity: 0.9 }),
  reversed: () => ({ opacity: 0.9 }),
}
===== END FILE: app/components/Button.tsx =====


===== BEGIN FILE: app/components/Text.tsx =====
import { ReactNode, forwardRef, ForwardedRef } from "react"
// eslint-disable-next-line no-restricted-imports
import { StyleProp, Text as RNText, TextProps as RNTextProps, TextStyle } from "react-native"
import { TOptions } from "i18next"

import { isRTL, TxKeyPath } from "@/i18n"
import { translate } from "@/i18n/translate"
import type { ThemedStyle, ThemedStyleArray } from "@/theme/types"
import { useAppTheme } from "@/theme/context"
import { typography } from "@/theme/typography"

type Sizes = keyof typeof $sizeStyles
type Weights = keyof typeof typography.primary
type Presets = "default" | "bold" | "heading" | "subheading" | "formLabel" | "formHelper"

export interface TextProps extends RNTextProps {
  /**
   * Text which is looked up via i18n.
   */
  tx?: TxKeyPath
  /**
   * The text to display if not using `tx` or nested components.
   */
  text?: string
  /**
   * Optional options to pass to i18n. Useful for interpolation
   * as well as explicitly setting locale or translation fallbacks.
   */
  txOptions?: TOptions
  /**
   * An optional style override useful for padding & margin.
   */
  style?: StyleProp<TextStyle>
  /**
   * One of the different types of text presets.
   */
  preset?: Presets
  /**
   * Text weight modifier.
   */
  weight?: Weights
  /**
   * Text size modifier.
   */
  size?: Sizes
  /**
   * Children components.
   */
  children?: ReactNode
}

/**
 * For your text displaying needs.
 * This component is a HOC over the built-in React Native one.
 * @see [Documentation and Examples]{@link https://docs.infinite.red/ignite-cli/boilerplate/app/components/Text/}
 * @param {TextProps} props - The props for the `Text` component.
 * @returns {JSX.Element} The rendered `Text` component.
 */
export const Text = forwardRef(function Text(props: TextProps, ref: ForwardedRef<RNText>) {
  const { weight, size, tx, txOptions, text, children, style: $styleOverride, ...rest } = props
  const { themed } = useAppTheme()

  const i18nText = tx && translate(tx, txOptions)
  const content = i18nText || text || children

  const preset: Presets = props.preset ?? "default"
  const $styles: StyleProp<TextStyle> = [
    $rtlStyle,
    themed($presets[preset]),
    weight && $fontWeightStyles[weight],
    size && $sizeStyles[size],
    $styleOverride,
  ]

  return (
    <RNText {...rest} style={$styles} ref={ref}>
      {content}
    </RNText>
  )
})

const $sizeStyles = {
  xxl: { fontSize: 36, lineHeight: 44 } satisfies TextStyle,
  xl: { fontSize: 24, lineHeight: 34 } satisfies TextStyle,
  lg: { fontSize: 20, lineHeight: 32 } satisfies TextStyle,
  md: { fontSize: 18, lineHeight: 26 } satisfies TextStyle,
  sm: { fontSize: 16, lineHeight: 24 } satisfies TextStyle,
  xs: { fontSize: 14, lineHeight: 21 } satisfies TextStyle,
  xxs: { fontSize: 12, lineHeight: 18 } satisfies TextStyle,
}

const $fontWeightStyles = Object.entries(typography.primary).reduce((acc, [weight, fontFamily]) => {
  return { ...acc, [weight]: { fontFamily } }
}, {}) as Record<Weights, TextStyle>

const $baseStyle: ThemedStyle<TextStyle> = (theme) => ({
  ...$sizeStyles.sm,
  ...$fontWeightStyles.normal,
  color: theme.colors.text,
})

const $presets: Record<Presets, ThemedStyleArray<TextStyle>> = {
  default: [$baseStyle],
  bold: [$baseStyle, { ...$fontWeightStyles.bold }],
  heading: [
    $baseStyle,
    {
      ...$sizeStyles.xxl,
      ...$fontWeightStyles.bold,
    },
  ],
  subheading: [$baseStyle, { ...$sizeStyles.lg, ...$fontWeightStyles.medium }],
  formLabel: [$baseStyle, { ...$fontWeightStyles.medium }],
  formHelper: [$baseStyle, { ...$sizeStyles.sm, ...$fontWeightStyles.normal }],
}
const $rtlStyle: TextStyle = isRTL ? { writingDirection: "rtl" } : {}
===== END FILE: app/components/Text.tsx =====


===== BEGIN FILE: app/components/RadioGroup.tsx =====
import React, { memo } from "react"
import { View } from "react-native"
import { RadioChip, RadioChipValue } from "./RadioChip"

type Option = { label: string; value: RadioChipValue; disabled?: boolean }

type RadioGroupProps = {
  value: RadioChipValue
  onChange: (value: RadioChipValue) => void
  options: Option[]
  size?: "md" | "lg"
  gap?: number
  wrap?: boolean
}

export const RadioGroup = memo(function RadioGroup({
  value,
  onChange,
  options,
  size = "md",
  gap = 8,
  wrap = false,
}: RadioGroupProps) {
  return (
    <View style={{ flexDirection: "row", flexWrap: wrap ? "wrap" : "nowrap", gap }}>
      {options.map((opt) => (
        <RadioChip
          key={`${opt.value}`}
          label={opt.label}
          value={opt.value}
          selected={value === opt.value}
          onChange={onChange}
          disabled={opt.disabled}
          size={size}
        />
      ))}
    </View>
  )
})
===== END FILE: app/components/RadioGroup.tsx =====


===== BEGIN FILE: app/components/EmptyState.tsx =====
import { Image, ImageProps, ImageStyle, StyleProp, TextStyle, View, ViewStyle } from "react-native"

import { translate } from "@/i18n/translate"
import type { ThemedStyle } from "@/theme/types"
import { useAppTheme } from "@/theme/context"

import { Button, ButtonProps } from "./Button"
import { Text, TextProps } from "./Text"

const sadFace = require("@assets/images/sad-face.png")

interface EmptyStateProps {
  /**
   * An optional prop that specifies the text/image set to use for the empty state.
   */
  preset?: "generic"
  /**
   * Style override for the container.
   */
  style?: StyleProp<ViewStyle>
  /**
   * An Image source to be displayed above the heading.
   */
  imageSource?: ImageProps["source"]
  /**
   * Style overrides for image.
   */
  imageStyle?: StyleProp<ImageStyle>
  /**
   * Pass any additional props directly to the Image component.
   */
  ImageProps?: Omit<ImageProps, "source">
  /**
   * The heading text to display if not using `headingTx`.
   */
  heading?: TextProps["text"]
  /**
   * Heading text which is looked up via i18n.
   */
  headingTx?: TextProps["tx"]
  /**
   * Optional heading options to pass to i18n. Useful for interpolation
   * as well as explicitly setting locale or translation fallbacks.
   */
  headingTxOptions?: TextProps["txOptions"]
  /**
   * Style overrides for heading text.
   */
  headingStyle?: StyleProp<TextStyle>
  /**
   * Pass any additional props directly to the heading Text component.
   */
  HeadingTextProps?: TextProps
  /**
   * The content text to display if not using `contentTx`.
   */
  content?: TextProps["text"]
  /**
   * Content text which is looked up via i18n.
   */
  contentTx?: TextProps["tx"]
  /**
   * Optional content options to pass to i18n. Useful for interpolation
   * as well as explicitly setting locale or translation fallbacks.
   */
  contentTxOptions?: TextProps["txOptions"]
  /**
   * Style overrides for content text.
   */
  contentStyle?: StyleProp<TextStyle>
  /**
   * Pass any additional props directly to the content Text component.
   */
  ContentTextProps?: TextProps
  /**
   * The button text to display if not using `buttonTx`.
   */
  button?: TextProps["text"]
  /**
   * Button text which is looked up via i18n.
   */
  buttonTx?: TextProps["tx"]
  /**
   * Optional button options to pass to i18n. Useful for interpolation
   * as well as explicitly setting locale or translation fallbacks.
   */
  buttonTxOptions?: TextProps["txOptions"]
  /**
   * Style overrides for button.
   */
  buttonStyle?: ButtonProps["style"]
  /**
   * Style overrides for button text.
   */
  buttonTextStyle?: ButtonProps["textStyle"]
  /**
   * Called when the button is pressed.
   */
  buttonOnPress?: ButtonProps["onPress"]
  /**
   * Pass any additional props directly to the Button component.
   */
  ButtonProps?: ButtonProps
}

interface EmptyStatePresetItem {
  imageSource: ImageProps["source"]
  heading: TextProps["text"]
  content: TextProps["text"]
  button: TextProps["text"]
}

/**
 * A component to use when there is no data to display. It can be utilized to direct the user what to do next.
 * @see [Documentation and Examples]{@link https://docs.infinite.red/ignite-cli/boilerplate/app/components/EmptyState/}
 * @param {EmptyStateProps} props - The props for the `EmptyState` component.
 * @returns {JSX.Element} The rendered `EmptyState` component.
 */
export function EmptyState(props: EmptyStateProps) {
  const {
    theme,
    themed,
    theme: { spacing },
  } = useAppTheme()

  const EmptyStatePresets = {
    generic: {
      imageSource: sadFace,
      heading: translate("emptyStateComponent:generic.heading"),
      content: translate("emptyStateComponent:generic.content"),
      button: translate("emptyStateComponent:generic.button"),
    } as EmptyStatePresetItem,
  } as const

  const preset = EmptyStatePresets[props.preset ?? "generic"]

  const {
    button = preset.button,
    buttonTx,
    buttonOnPress,
    buttonTxOptions,
    content = preset.content,
    contentTx,
    contentTxOptions,
    heading = preset.heading,
    headingTx,
    headingTxOptions,
    imageSource = preset.imageSource,
    style: $containerStyleOverride,
    buttonStyle: $buttonStyleOverride,
    buttonTextStyle: $buttonTextStyleOverride,
    contentStyle: $contentStyleOverride,
    headingStyle: $headingStyleOverride,
    imageStyle: $imageStyleOverride,
    ButtonProps,
    ContentTextProps,
    HeadingTextProps,
    ImageProps,
  } = props

  const isImagePresent = !!imageSource
  const isHeadingPresent = !!(heading || headingTx)
  const isContentPresent = !!(content || contentTx)
  const isButtonPresent = !!(button || buttonTx)

  const $containerStyles = [$containerStyleOverride]
  const $imageStyles = [
    $image,
    (isHeadingPresent || isContentPresent || isButtonPresent) && { marginBottom: spacing.xxxs },
    $imageStyleOverride,
    ImageProps?.style,
  ]
  const $headingStyles = [
    themed($heading),
    isImagePresent && { marginTop: spacing.xxxs },
    (isContentPresent || isButtonPresent) && { marginBottom: spacing.xxxs },
    $headingStyleOverride,
    HeadingTextProps?.style,
  ]
  const $contentStyles = [
    themed($content),
    (isImagePresent || isHeadingPresent) && { marginTop: spacing.xxxs },
    isButtonPresent && { marginBottom: spacing.xxxs },
    $contentStyleOverride,
    ContentTextProps?.style,
  ]
  const $buttonStyles = [
    (isImagePresent || isHeadingPresent || isContentPresent) && { marginTop: spacing.xl },
    $buttonStyleOverride,
    ButtonProps?.style,
  ]

  return (
    <View style={$containerStyles}>
      {isImagePresent && (
        <Image
          source={imageSource}
          {...ImageProps}
          style={$imageStyles}
          tintColor={theme.colors.palette.neutral900}
        />
      )}

      {isHeadingPresent && (
        <Text
          preset="subheading"
          text={heading}
          tx={headingTx}
          txOptions={headingTxOptions}
          {...HeadingTextProps}
          style={$headingStyles}
        />
      )}

      {isContentPresent && (
        <Text
          text={content}
          tx={contentTx}
          txOptions={contentTxOptions}
          {...ContentTextProps}
          style={$contentStyles}
        />
      )}

      {isButtonPresent && (
        <Button
          onPress={buttonOnPress}
          text={button}
          tx={buttonTx}
          txOptions={buttonTxOptions}
          textStyle={$buttonTextStyleOverride}
          {...ButtonProps}
          style={$buttonStyles}
        />
      )}
    </View>
  )
}

const $image: ImageStyle = { alignSelf: "center" }
const $heading: ThemedStyle<TextStyle> = ({ spacing }) => ({
  textAlign: "center",
  paddingHorizontal: spacing.lg,
})
const $content: ThemedStyle<TextStyle> = ({ spacing }) => ({
  textAlign: "center",
  paddingHorizontal: spacing.lg,
})
===== END FILE: app/components/EmptyState.tsx =====


===== BEGIN FILE: app/components/SmileySlider.tsx =====
import React, { useMemo } from "react"
import { View, StyleSheet } from "react-native"
import Slider from "@react-native-community/slider"
import { Text } from "@/components/Text"

// Map value (0..5) → emoji + label
function getFace(v: number) {
  if (v < 1) return { emoji: "😡", label: "oolshik:ratingBad" }
  if (v < 2) return { emoji: "🙁", label: "oolshik:ratingPoor" }
  if (v < 3) return { emoji: "😐", label: "oolshik:ratingOkay" }
  if (v < 4) return { emoji: "🙂", label: "oolshik:ratingGood" }
  return { emoji: "😄", label: "oolshik:ratingGreat" }
}
const SLIDER_COLOR = "#FF6B2C"

export type SmileySliderProps = {
  disabled?: boolean
  value: number
  onChange: (v: number) => void
  onSlidingComplete?: (v: number) => void
}

export function SmileySlider({ disabled, value, onChange, onSlidingComplete }: SmileySliderProps) {
  const face = useMemo(() => getFace(value), [value])

  return (
    <View style={styles.wrapper}>
      <View style={styles.faceRow}>
        <Text style={styles.faceEmoji}>{face.emoji}</Text>
        <Text tx={face.label} style={styles.faceLabel} />
      </View>

      <View style={styles.sliderRow}>
        <Text style={styles.edgeEmoji}>😡</Text>
        <View style={{ flex: 1 }}>
          <Slider
            disabled={disabled}
            value={value}
            onValueChange={onChange}
            onSlidingComplete={onSlidingComplete}
            minimumValue={0}
            maximumValue={5}
            step={1}
            minimumTrackTintColor={SLIDER_COLOR} // green-ish
            maximumTrackTintColor="#d1d5db" // gray-300
            thumbTintColor={SLIDER_COLOR} // emerald-500
            accessibilityLabel="Rate your experience"
          />
        </View>
        <Text style={styles.edgeEmoji}>😄</Text>
      </View>

      <Text tx="oolshik:leftRightExperience" style={styles.helperText} />
    </View>
  )
}

const styles = StyleSheet.create({
  wrapper: { gap: 8 },
  faceRow: { alignItems: "center", justifyContent: "center" },
  faceEmoji: { fontSize: 40, lineHeight: 44 },
  faceLabel: { marginTop: 4, fontSize: 14, opacity: 0.7 },
  sliderRow: { flexDirection: "row", alignItems: "center", gap: 8 },
  edgeEmoji: { width: 24, textAlign: "center" },
  helperText: { marginTop: 4, fontSize: 12, opacity: 0.6, textAlign: "center" },
})
===== END FILE: app/components/SmileySlider.tsx =====


===== BEGIN FILE: app/components/Toggle/Radio.tsx =====
import { useEffect, useRef } from "react"
import { StyleProp, View, ViewStyle, Animated } from "react-native"

import { useAppTheme } from "@/theme/context"
import { $styles } from "@/theme/styles"

import { $inputOuterBase, BaseToggleInputProps, ToggleProps, Toggle } from "./Toggle"

export interface RadioToggleProps extends Omit<ToggleProps<RadioInputProps>, "ToggleInput"> {
  /**
   * Optional style prop that affects the dot View.
   */
  inputDetailStyle?: ViewStyle
}

interface RadioInputProps extends BaseToggleInputProps<RadioToggleProps> {}

/**
 * @param {RadioToggleProps} props - The props for the `Radio` component.
 * @see [Documentation and Examples]{@link https://docs.infinite.red/ignite-cli/boilerplate/app/components/Radio}
 * @returns {JSX.Element} The rendered `Radio` component.
 */
export function Radio(props: RadioToggleProps) {
  return <Toggle accessibilityRole="radio" {...props} ToggleInput={RadioInput} />
}

function RadioInput(props: RadioInputProps) {
  const {
    on,
    status,
    disabled,
    outerStyle: $outerStyleOverride,
    innerStyle: $innerStyleOverride,
    detailStyle: $detailStyleOverride,
  } = props

  const {
    theme: { colors },
  } = useAppTheme()

  const opacity = useRef(new Animated.Value(0))

  useEffect(() => {
    Animated.timing(opacity.current, {
      toValue: on ? 1 : 0,
      duration: 300,
      useNativeDriver: true,
    }).start()
  }, [on])

  const offBackgroundColor = [
    disabled && colors.palette.neutral400,
    status === "error" && colors.errorBackground,
    colors.palette.neutral200,
  ].filter(Boolean)[0]

  const outerBorderColor = [
    disabled && colors.palette.neutral400,
    status === "error" && colors.error,
    !on && colors.palette.neutral800,
    colors.palette.secondary500,
  ].filter(Boolean)[0]

  const onBackgroundColor = [
    disabled && colors.transparent,
    status === "error" && colors.errorBackground,
    colors.palette.neutral100,
  ].filter(Boolean)[0]

  const dotBackgroundColor = [
    disabled && colors.palette.neutral600,
    status === "error" && colors.error,
    colors.palette.secondary500,
  ].filter(Boolean)[0]

  return (
    <View
      style={[
        $inputOuter,
        { backgroundColor: offBackgroundColor, borderColor: outerBorderColor },
        $outerStyleOverride,
      ]}
    >
      <Animated.View
        style={[
          $styles.toggleInner,
          { backgroundColor: onBackgroundColor },
          $innerStyleOverride,
          { opacity: opacity.current },
        ]}
      >
        <View
          style={[$radioDetail, { backgroundColor: dotBackgroundColor }, $detailStyleOverride]}
        />
      </Animated.View>
    </View>
  )
}

const $radioDetail: ViewStyle = {
  width: 12,
  height: 12,
  borderRadius: 6,
}

const $inputOuter: StyleProp<ViewStyle> = [$inputOuterBase, { borderRadius: 12 }]
===== END FILE: app/components/Toggle/Radio.tsx =====


===== BEGIN FILE: app/components/Toggle/Switch.tsx =====
import { useEffect, useMemo, useRef, useCallback } from "react"
import { Animated, Image, ImageStyle, Platform, StyleProp, View, ViewStyle } from "react-native"

import { iconRegistry } from "@/components/Icon"
import { isRTL } from "@/i18n"
import type { ThemedStyle } from "@/theme/types"
import { useAppTheme } from "@/theme/context"
import { $styles } from "@/theme/styles"

import { $inputOuterBase, BaseToggleInputProps, Toggle, ToggleProps } from "./Toggle"

export interface SwitchToggleProps extends Omit<ToggleProps<SwitchInputProps>, "ToggleInput"> {
  /**
   * Switch-only prop that adds a text/icon label for on/off states.
   */
  accessibilityMode?: "text" | "icon"
  /**
   * Optional style prop that affects the knob View.
   * Note: `width` and `height` rules should be points (numbers), not percentages.
   */
  inputDetailStyle?: Omit<ViewStyle, "width" | "height"> & { width?: number; height?: number }
}

interface SwitchInputProps extends BaseToggleInputProps<SwitchToggleProps> {
  accessibilityMode?: SwitchToggleProps["accessibilityMode"]
}

/**
 * @param {SwitchToggleProps} props - The props for the `Switch` component.
 * @see [Documentation and Examples]{@link https://docs.infinite.red/ignite-cli/boilerplate/app/components/Switch}
 * @returns {JSX.Element} The rendered `Switch` component.
 */
export function Switch(props: SwitchToggleProps) {
  const { accessibilityMode, ...rest } = props
  const switchInput = useCallback(
    (toggleProps: SwitchInputProps) => (
      <SwitchInput {...toggleProps} accessibilityMode={accessibilityMode} />
    ),
    [accessibilityMode],
  )
  return <Toggle accessibilityRole="switch" {...rest} ToggleInput={switchInput} />
}

function SwitchInput(props: SwitchInputProps) {
  const {
    on,
    status,
    disabled,
    outerStyle: $outerStyleOverride,
    innerStyle: $innerStyleOverride,
    detailStyle: $detailStyleOverride,
  } = props

  const {
    theme: { colors },
    themed,
  } = useAppTheme()

  const animate = useRef(new Animated.Value(on ? 1 : 0)) // Initial value is set based on isActive
  const opacity = useRef(new Animated.Value(0))

  useEffect(() => {
    Animated.timing(animate.current, {
      toValue: on ? 1 : 0,
      duration: 300,
      useNativeDriver: true, // Enable native driver for smoother animations
    }).start()
  }, [on])

  useEffect(() => {
    Animated.timing(opacity.current, {
      toValue: on ? 1 : 0,
      duration: 300,
      useNativeDriver: true,
    }).start()
  }, [on])

  const knobSizeFallback = 2

  const knobWidth = [$detailStyleOverride?.width, $switchDetail?.width, knobSizeFallback].find(
    (v) => typeof v === "number",
  )

  const knobHeight = [$detailStyleOverride?.height, $switchDetail?.height, knobSizeFallback].find(
    (v) => typeof v === "number",
  )

  const offBackgroundColor = [
    disabled && colors.palette.neutral400,
    status === "error" && colors.errorBackground,
    colors.palette.neutral300,
  ].filter(Boolean)[0]

  const onBackgroundColor = [
    disabled && colors.transparent,
    status === "error" && colors.errorBackground,
    colors.palette.secondary500,
  ].filter(Boolean)[0]

  const knobBackgroundColor = (function () {
    if (on) {
      return [
        $detailStyleOverride?.backgroundColor,
        status === "error" && colors.error,
        disabled && colors.palette.neutral600,
        colors.palette.neutral100,
      ].filter(Boolean)[0]
    } else {
      return [
        $innerStyleOverride?.backgroundColor,
        disabled && colors.palette.neutral600,
        status === "error" && colors.error,
        colors.palette.neutral200,
      ].filter(Boolean)[0]
    }
  })()

  const rtlAdjustment = isRTL ? -1 : 1
  const $themedSwitchInner = useMemo(() => themed([$styles.toggleInner, $switchInner]), [themed])

  const offsetLeft = ($innerStyleOverride?.paddingStart ||
    $innerStyleOverride?.paddingLeft ||
    $themedSwitchInner?.paddingStart ||
    $themedSwitchInner?.paddingLeft ||
    0) as number

  const offsetRight = ($innerStyleOverride?.paddingEnd ||
    $innerStyleOverride?.paddingRight ||
    $themedSwitchInner?.paddingEnd ||
    $themedSwitchInner?.paddingRight ||
    0) as number

  const outputRange =
    Platform.OS === "web"
      ? isRTL
        ? [+(knobWidth || 0) + offsetRight, offsetLeft]
        : [offsetLeft, +(knobWidth || 0) + offsetRight]
      : [rtlAdjustment * offsetLeft, rtlAdjustment * (+(knobWidth || 0) + offsetRight)]

  const $animatedSwitchKnob = animate.current.interpolate({
    inputRange: [0, 1],
    outputRange,
  })

  return (
    <View style={[$inputOuter, { backgroundColor: offBackgroundColor }, $outerStyleOverride]}>
      <Animated.View
        style={[
          $themedSwitchInner,
          { backgroundColor: onBackgroundColor },
          $innerStyleOverride,
          { opacity: opacity.current },
        ]}
      />

      <SwitchAccessibilityLabel {...props} role="on" />
      <SwitchAccessibilityLabel {...props} role="off" />

      <Animated.View
        style={[
          $switchDetail,
          $detailStyleOverride,
          { transform: [{ translateX: $animatedSwitchKnob }] },
          { width: knobWidth, height: knobHeight },
          { backgroundColor: knobBackgroundColor },
        ]}
      />
    </View>
  )
}

/**
 * @param {ToggleInputProps & { role: "on" | "off" }} props - The props for the `SwitchAccessibilityLabel` component.
 * @returns {JSX.Element} The rendered `SwitchAccessibilityLabel` component.
 */
function SwitchAccessibilityLabel(props: SwitchInputProps & { role: "on" | "off" }) {
  const { on, disabled, status, accessibilityMode, role, innerStyle, detailStyle } = props

  const {
    theme: { colors },
  } = useAppTheme()

  if (!accessibilityMode) return null

  const shouldLabelBeVisible = (on && role === "on") || (!on && role === "off")

  const $switchAccessibilityStyle: StyleProp<ViewStyle> = [
    $switchAccessibility,
    role === "off" && { end: "5%" },
    role === "on" && { left: "5%" },
  ]

  const color = (function () {
    if (disabled) return colors.palette.neutral600
    if (status === "error") return colors.error
    if (!on) return innerStyle?.backgroundColor || colors.palette.secondary500
    return detailStyle?.backgroundColor || colors.palette.neutral100
  })()

  return (
    <View style={$switchAccessibilityStyle}>
      {accessibilityMode === "text" && shouldLabelBeVisible && (
        <View
          style={[
            role === "on" && $switchAccessibilityLine,
            role === "on" && { backgroundColor: color },
            role === "off" && $switchAccessibilityCircle,
            role === "off" && { borderColor: color },
          ]}
        />
      )}

      {accessibilityMode === "icon" && shouldLabelBeVisible && (
        <Image
          style={[$switchAccessibilityIcon, { tintColor: color }]}
          source={role === "off" ? iconRegistry.hidden : iconRegistry.view}
        />
      )}
    </View>
  )
}

const $inputOuter: StyleProp<ViewStyle> = [
  $inputOuterBase,
  { height: 32, width: 56, borderRadius: 16, borderWidth: 0 },
]

const $switchInner: ThemedStyle<ViewStyle> = ({ colors }) => ({
  borderColor: colors.transparent,
  position: "absolute",
  paddingStart: 4,
  paddingEnd: 4,
})

const $switchDetail: SwitchToggleProps["inputDetailStyle"] = {
  borderRadius: 12,
  position: "absolute",
  width: 24,
  height: 24,
}

const $switchAccessibility: ViewStyle = {
  width: "40%",
  justifyContent: "center",
  alignItems: "center",
}

const $switchAccessibilityIcon: ImageStyle = {
  width: 14,
  height: 14,
  resizeMode: "contain",
}

const $switchAccessibilityLine: ViewStyle = {
  width: 2,
  height: 12,
}

const $switchAccessibilityCircle: ViewStyle = {
  borderWidth: 2,
  width: 12,
  height: 12,
  borderRadius: 6,
}
===== END FILE: app/components/Toggle/Switch.tsx =====


===== BEGIN FILE: app/components/Toggle/Toggle.tsx =====
import { ComponentType, FC, useMemo } from "react"
import {
  GestureResponderEvent,
  ImageStyle,
  StyleProp,
  SwitchProps,
  TextInputProps,
  TextStyle,
  TouchableOpacity,
  TouchableOpacityProps,
  View,
  ViewProps,
  ViewStyle,
} from "react-native"

import type { ThemedStyle } from "@/theme/types"
import { useAppTheme } from "@/theme/context"
import { $styles } from "@/theme/styles"

import { Text, TextProps } from "../Text"

export interface ToggleProps<T> extends Omit<TouchableOpacityProps, "style"> {
  /**
   * A style modifier for different input states.
   */
  status?: "error" | "disabled"
  /**
   * If false, input is not editable. The default value is true.
   */
  editable?: TextInputProps["editable"]
  /**
   * The value of the field. If true the component will be turned on.
   */
  value?: boolean
  /**
   * Invoked with the new value when the value changes.
   */
  onValueChange?: SwitchProps["onValueChange"]
  /**
   * Style overrides for the container
   */
  containerStyle?: StyleProp<ViewStyle>
  /**
   * Style overrides for the input wrapper
   */
  inputWrapperStyle?: StyleProp<ViewStyle>
  /**
   * Optional input wrapper style override.
   * This gives the inputs their size, shape, "off" background-color, and outer border.
   */
  inputOuterStyle?: ViewStyle
  /**
   * Optional input style override.
   * This gives the inputs their inner characteristics and "on" background-color.
   */
  inputInnerStyle?: ViewStyle
  /**
   * Optional detail style override.
   * See Checkbox, Radio, and Switch for more details
   */
  inputDetailStyle?: ViewStyle
  /**
   * The position of the label relative to the action component.
   * Default: right
   */
  labelPosition?: "left" | "right"
  /**
   * The label text to display if not using `labelTx`.
   */
  label?: TextProps["text"]
  /**
   * Label text which is looked up via i18n.
   */
  labelTx?: TextProps["tx"]
  /**
   * Optional label options to pass to i18n. Useful for interpolation
   * as well as explicitly setting locale or translation fallbacks.
   */
  labelTxOptions?: TextProps["txOptions"]
  /**
   * Style overrides for label text.
   */
  labelStyle?: StyleProp<TextStyle>
  /**
   * Pass any additional props directly to the label Text component.
   */
  LabelTextProps?: TextProps
  /**
   * The helper text to display if not using `helperTx`.
   */
  helper?: TextProps["text"]
  /**
   * Helper text which is looked up via i18n.
   */
  helperTx?: TextProps["tx"]
  /**
   * Optional helper options to pass to i18n. Useful for interpolation
   * as well as explicitly setting locale or translation fallbacks.
   */
  helperTxOptions?: TextProps["txOptions"]
  /**
   * Pass any additional props directly to the helper Text component.
   */
  HelperTextProps?: TextProps
  /**
   * The input control for the type of toggle component
   */
  ToggleInput: FC<BaseToggleInputProps<T>>
}

export interface BaseToggleInputProps<T> {
  on: boolean
  status: ToggleProps<T>["status"]
  disabled: boolean
  outerStyle: ViewStyle
  innerStyle: ViewStyle
  detailStyle: ViewStyle | ImageStyle
}

/**
 * Renders a boolean input.
 * This is a controlled component that requires an onValueChange callback that updates the value prop in order for the component to reflect user actions. If the value prop is not updated, the component will continue to render the supplied value prop instead of the expected result of any user actions.
 * @param {ToggleProps} props - The props for the `Toggle` component.
 * @returns {JSX.Element} The rendered `Toggle` component.
 */
export function Toggle<T>(props: ToggleProps<T>) {
  const {
    editable = true,
    status,
    value,
    onPress,
    onValueChange,
    labelPosition = "right",
    helper,
    helperTx,
    helperTxOptions,
    HelperTextProps,
    containerStyle: $containerStyleOverride,
    inputWrapperStyle: $inputWrapperStyleOverride,
    ToggleInput,
    accessibilityRole,
    ...WrapperProps
  } = props

  const {
    theme: { colors },
    themed,
  } = useAppTheme()

  const disabled = editable === false || status === "disabled" || props.disabled

  const Wrapper = useMemo(
    () => (disabled ? View : TouchableOpacity) as ComponentType<TouchableOpacityProps | ViewProps>,
    [disabled],
  )

  const $containerStyles = [$containerStyleOverride]
  const $inputWrapperStyles = [$styles.row, $inputWrapper, $inputWrapperStyleOverride]
  const $helperStyles = themed([
    $helper,
    status === "error" && { color: colors.error },
    HelperTextProps?.style,
  ])

  /**
   * @param {GestureResponderEvent} e - The event object.
   */
  function handlePress(e: GestureResponderEvent) {
    if (disabled) return
    onValueChange?.(!value)
    onPress?.(e)
  }

  return (
    <Wrapper
      activeOpacity={1}
      accessibilityRole={accessibilityRole}
      accessibilityState={{ checked: value, disabled }}
      {...WrapperProps}
      style={$containerStyles}
      onPress={handlePress}
    >
      <View style={$inputWrapperStyles}>
        {labelPosition === "left" && <FieldLabel<T> {...props} labelPosition={labelPosition} />}

        <ToggleInput
          on={!!value}
          disabled={!!disabled}
          status={status}
          outerStyle={props.inputOuterStyle ?? {}}
          innerStyle={props.inputInnerStyle ?? {}}
          detailStyle={props.inputDetailStyle ?? {}}
        />

        {labelPosition === "right" && <FieldLabel<T> {...props} labelPosition={labelPosition} />}
      </View>

      {!!(helper || helperTx) && (
        <Text
          preset="formHelper"
          text={helper}
          tx={helperTx}
          txOptions={helperTxOptions}
          {...HelperTextProps}
          style={$helperStyles}
        />
      )}
    </Wrapper>
  )
}

/**
 * @param {ToggleProps} props - The props for the `FieldLabel` component.
 * @returns {JSX.Element} The rendered `FieldLabel` component.
 */
function FieldLabel<T>(props: ToggleProps<T>) {
  const {
    status,
    label,
    labelTx,
    labelTxOptions,
    LabelTextProps,
    labelPosition,
    labelStyle: $labelStyleOverride,
  } = props

  const {
    theme: { colors },
    themed,
  } = useAppTheme()

  if (!label && !labelTx && !LabelTextProps?.children) return null

  const $labelStyle = themed([
    $label,
    status === "error" && { color: colors.error },
    labelPosition === "right" && $labelRight,
    labelPosition === "left" && $labelLeft,
    $labelStyleOverride,
    LabelTextProps?.style,
  ])

  return (
    <Text
      preset="formLabel"
      text={label}
      tx={labelTx}
      txOptions={labelTxOptions}
      {...LabelTextProps}
      style={$labelStyle}
    />
  )
}

const $inputWrapper: ViewStyle = {
  alignItems: "center",
}

export const $inputOuterBase: ViewStyle = {
  height: 24,
  width: 24,
  borderWidth: 2,
  alignItems: "center",
  overflow: "hidden",
  flexGrow: 0,
  flexShrink: 0,
  justifyContent: "space-between",
  flexDirection: "row",
}

const $helper: ThemedStyle<TextStyle> = ({ spacing }) => ({
  marginTop: spacing.xs,
})

const $label: TextStyle = {
  flex: 1,
}

const $labelRight: ThemedStyle<TextStyle> = ({ spacing }) => ({
  marginStart: spacing.md,
})

const $labelLeft: ThemedStyle<TextStyle> = ({ spacing }) => ({
  marginEnd: spacing.md,
})
===== END FILE: app/components/Toggle/Toggle.tsx =====


===== BEGIN FILE: app/components/Toggle/Checkbox.tsx =====
import { useEffect, useRef, useCallback } from "react"
import { Image, ImageStyle, Animated, StyleProp, View, ViewStyle } from "react-native"

import { useAppTheme } from "@/theme/context"
import { $styles } from "@/theme/styles"

import { iconRegistry, IconTypes } from "../Icon"
import { $inputOuterBase, BaseToggleInputProps, ToggleProps, Toggle } from "./Toggle"

export interface CheckboxToggleProps extends Omit<ToggleProps<CheckboxInputProps>, "ToggleInput"> {
  /**
   * Optional style prop that affects the Image component.
   */
  inputDetailStyle?: ImageStyle
  /**
   * Checkbox-only prop that changes the icon used for the "on" state.
   */
  icon?: IconTypes
}

interface CheckboxInputProps extends BaseToggleInputProps<CheckboxToggleProps> {
  icon?: CheckboxToggleProps["icon"]
}
/**
 * @param {CheckboxToggleProps} props - The props for the `Checkbox` component.
 * @see [Documentation and Examples]{@link https://docs.infinite.red/ignite-cli/boilerplate/app/components/Checkbox}
 * @returns {JSX.Element} The rendered `Checkbox` component.
 */
export function Checkbox(props: CheckboxToggleProps) {
  const { icon, ...rest } = props
  const checkboxInput = useCallback(
    (toggleProps: CheckboxInputProps) => <CheckboxInput {...toggleProps} icon={icon} />,
    [icon],
  )
  return <Toggle accessibilityRole="checkbox" {...rest} ToggleInput={checkboxInput} />
}

function CheckboxInput(props: CheckboxInputProps) {
  const {
    on,
    status,
    disabled,
    icon = "check",
    outerStyle: $outerStyleOverride,
    innerStyle: $innerStyleOverride,
    detailStyle: $detailStyleOverride,
  } = props

  const {
    theme: { colors },
  } = useAppTheme()

  const opacity = useRef(new Animated.Value(0))

  useEffect(() => {
    Animated.timing(opacity.current, {
      toValue: on ? 1 : 0,
      duration: 300,
      useNativeDriver: true,
    }).start()
  }, [on])

  const offBackgroundColor = [
    disabled && colors.palette.neutral400,
    status === "error" && colors.errorBackground,
    colors.palette.neutral200,
  ].filter(Boolean)[0]

  const outerBorderColor = [
    disabled && colors.palette.neutral400,
    status === "error" && colors.error,
    !on && colors.palette.neutral800,
    colors.palette.secondary500,
  ].filter(Boolean)[0]

  const onBackgroundColor = [
    disabled && colors.transparent,
    status === "error" && colors.errorBackground,
    colors.palette.secondary500,
  ].filter(Boolean)[0]

  const iconTintColor = [
    disabled && colors.palette.neutral600,
    status === "error" && colors.error,
    colors.palette.accent100,
  ].filter(Boolean)[0]

  return (
    <View
      style={[
        $inputOuter,
        { backgroundColor: offBackgroundColor, borderColor: outerBorderColor },
        $outerStyleOverride,
      ]}
    >
      <Animated.View
        style={[
          $styles.toggleInner,
          { backgroundColor: onBackgroundColor },
          $innerStyleOverride,
          { opacity: opacity.current },
        ]}
      >
        <Image
          source={icon ? iconRegistry[icon] : iconRegistry.check}
          style={[
            $checkboxDetail,
            !!iconTintColor && { tintColor: iconTintColor },
            $detailStyleOverride as ImageStyle,
          ]}
        />
      </Animated.View>
    </View>
  )
}

const $checkboxDetail: ImageStyle = {
  width: 20,
  height: 20,
  resizeMode: "contain",
}

const $inputOuter: StyleProp<ViewStyle> = [$inputOuterBase, { borderRadius: 4 }]
===== END FILE: app/components/Toggle/Checkbox.tsx =====


===== BEGIN FILE: app/audio/useAudioRecorder.expo.ts =====
// app/audio/useAudioRecorder.expo.ts
// Expo path using expo-av
import { Audio } from "expo-av"
import { useEffect, useRef, useState } from "react"

export type RecordingState = "idle" | "recording" | "paused" | "stopped"
export type Recording = { path: string; durationMs: number }

export function useAudioRecorder() {
  const [state, setState] = useState<RecordingState>("idle")
  const [path, setPath] = useState<string | null>(null)
  const [durationMs, setDurationMs] = useState(0)
  const recRef = useRef<Audio.Recording | null>(null)

  useEffect(() => {
    return () => {
      try {
        recRef.current?.stopAndUnloadAsync()
      } catch {}
    }
  }, [])

  const start = async () => {
    const perm = await Audio.requestPermissionsAsync()
    if (!perm.granted) return
    await Audio.setAudioModeAsync({ allowsRecordingIOS: true, playsInSilentModeIOS: true })
    const recording = new Audio.Recording()
    await recording.prepareToRecordAsync(Audio.RecordingOptionsPresets.HIGH_QUALITY)
    await recording.startAsync()
    recRef.current = recording
    setState("recording")
    const interval = setInterval(async () => {
      const s = await recording.getStatusAsync()
      if (s.isRecording) setDurationMs(s.durationMillis || 0)
      else clearInterval(interval)
    }, 300)
  }

  const pause = async () => {
    await recRef.current?.pauseAsync()
    setState("paused")
  }
  const resume = async () => {
    await recRef.current?.startAsync()
    setState("recording")
  }
  const stop = async (): Promise<Recording | null> => {
    if (!recRef.current) return null
    await recRef.current.stopAndUnloadAsync()
    const uri = recRef.current.getURI()!
    setPath(uri)
    setState("stopped")
    return { path: uri, durationMs }
  }

  return { state, start, pause, resume, stop, path, durationMs }
}
===== END FILE: app/audio/useAudioRecorder.expo.ts =====


===== BEGIN FILE: app/audio/useAudioRecorder.rn.ts =====
// app/audio/useAudioRecorder.rn.ts
// Bare React Native path using react-native-audio-recorder-player
import { useEffect, useRef, useState } from "react"
import { Platform, PermissionsAndroid, Alert } from "react-native"
import AudioRecorderPlayer, {
  AVEncoderAudioQualityIOSType,
  AVEncodingOption,
} from "react-native-audio-recorder-player"

export type RecordingState = "idle" | "recording" | "paused" | "stopped"
export type Recording = { path: string; durationMs: number }

export function useAudioRecorder() {
  const arpRef = useRef(new AudioRecorderPlayer())
  const [state, setState] = useState<RecordingState>("idle")
  const [path, setPath] = useState<string | null>(null)
  const [durationMs, setDurationMs] = useState(0)

  useEffect(() => {
    return () => {
      try {
        arpRef.current.stopRecorder()
      } catch {}
    }
  }, [])

  const requestPermission = async () => {
    if (Platform.OS === "android") {
      const granted = await PermissionsAndroid.requestMultiple([
        PermissionsAndroid.PERMISSIONS.RECORD_AUDIO,
        PermissionsAndroid.PERMISSIONS.WRITE_EXTERNAL_STORAGE,
      ])
      if (
        granted[PermissionsAndroid.PERMISSIONS.RECORD_AUDIO] !== PermissionsAndroid.RESULTS.GRANTED
      ) {
        Alert.alert("Permission required", "Recording permission is needed.")
        return false
      }
    }
    return true
  }

  const start = async () => {
    if (!(await requestPermission())) return
    const fname = `oolshik_${Date.now()}.m4a`
    const uri = Platform.select({ ios: `/${fname}`, android: undefined })
    const result = await arpRef.current.startRecorder(uri, {
      quality: AVEncoderAudioQualityIOSType.high,
      audioSource: 6,
      AVNumberOfChannelsKeyIOS: 1,
      AVFormatIDKeyIOS: AVEncodingOption.aac,
      SampleRateIOS: 44100,
    })
    setPath(result)
    setState("recording")
    arpRef.current.addRecordBackListener((e) => setDurationMs(e.currentPosition))
  }

  const pause = async () => {
    if (state === "recording") {
      await arpRef.current.pauseRecorder()
      setState("paused")
    }
  }
  const resume = async () => {
    if (state === "paused") {
      await arpRef.current.resumeRecorder()
      setState("recording")
    }
  }
  const stop = async (): Promise<Recording | null> => {
    if (state === "idle") return null
    const result = await arpRef.current.stopRecorder()
    arpRef.current.removeRecordBackListener()
    setState("stopped")
    setPath(result)
    return { path: result, durationMs }
  }

  return { state, start, pause, resume, stop, path, durationMs }
}
===== END FILE: app/audio/useAudioRecorder.rn.ts =====


===== BEGIN FILE: app/audio/uploadAudio.ts =====
// app/audio/uploadAudio.ts
import RNFS from "react-native-fs"
import { api as Api } from "@/api/client"
import { initUpload, uploadChunk, completeUpload, ensureOk, streamUrl } from "@/api/audio"

const CHUNK_SIZE = 5 * 1024 * 1024 // 5MB

type Opts = {
  uri: string // file://...
  filename: string // defaults to recording_<ts>.m4a
  mimeType: string // defaults to audio/m4a
  durationMs: number
  sampleRate?: number
  requestId?: string // optional client-provided upload ID (for deduping)
}

/**
 * Uploads audio:
 * - tries S3 presigned PUT first (if backend supports it),
 * - otherwise falls back to server-buffered chunk upload (works on media.storage=local).
 * Returns a URL your app can play (S3 public URL OR backend /stream URL).
 */
export async function uploadAudioSmart(opts: Opts): Promise<{ ok: true; url: string }> {
  const mimeType = opts.mimeType ?? "audio/m4a"
  const filename = opts.filename ?? `recording_${Date.now()}.m4a`

  // Try presigned S3 first (will 501/500 on local → we catch and fallback)
  try {
    const pres = await Api.post<{ uploadUrl: string; fileUrl: string; objectKey: string }>(
      "/media/pre-signed",
      { contentType: mimeType },
    )
    if (pres.ok && pres.data) {
      const { uploadUrl, fileUrl } = pres.data
      // Upload file as binary (no base64) using RNFS
      const stat = await RNFS.stat(opts.uri.replace("file://", ""))
      const data = await RNFS.readFile(opts.uri, "base64")
      const res = await fetch(uploadUrl, {
        method: "PUT",
        headers: { "Content-Type": mimeType },
        body: Buffer.from(data, "base64") as any,
      })
      if (!res.ok) throw new Error(`PUT failed ${res.status}`)
      return { ok: true, url: fileUrl }
    }
  } catch {
    // ignore; fall back to chunked
  }

  // ---- Fallback: server-buffered chunk upload (LOCAL) ----
  // 1) stat
  const filePath = opts.uri.startsWith("file://") ? opts.uri.replace("file://", "") : opts.uri
  const st = await RNFS.stat(filePath)
  const size = Number(st.size)
  if (!Number.isFinite(size) || size <= 0) throw new Error("File not found or empty")

  // 2) init
  const initRes = await initUpload({ filename, mimeType, size })
  const initData = ensureOk<{ uploadId: string }>(initRes)
  const uploadId = initData.uploadId

  // 3) chunk loop
  let offset = 0
  let index = 0
  while (offset < size) {
    const len = Math.min(CHUNK_SIZE, size - offset)
    // RNFS read with length + position (base64 → bytes)
    const base64 = await RNFS.read(filePath, len, offset, "base64")
    const bytes = base64ToBytes(base64)
    const put = await uploadChunk(uploadId, index, bytes as unknown as Uint8Array)
    if (!put.ok) throw new Error(`Chunk ${index} failed`)
    offset += len
    index++
  }

  // 4) complete → server returns AudioFile (id, etc.)
  const comp = await completeUpload({
    uploadId,
    totalChunks: index,
    durationMs: opts.durationMs,
    sampleRate: opts.sampleRate,
  })
  if (!comp.ok || !comp.data) throw new Error("Complete upload failed")
  const saved: any = comp.data

  // 5) build play URL via the same base used by client/api
  const url = streamUrl(saved.id) // e.g. http://.../api/media/audio/{id}/stream
  return { ok: true, url }
}

function base64ToBytes(b64: string): Uint8Array {
  // fast base64 decoder (no atob dependency)
  const chars = "ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789+/"
  let i = 0,
    out: number[] = []
  b64 = b64.replace(/[^A-Za-z0-9+/=]/g, "")
  while (i < b64.length) {
    const e1 = chars.indexOf(b64[i++])
    const e2 = chars.indexOf(b64[i++])
    const e3 = chars.indexOf(b64[i++])
    const e4 = chars.indexOf(b64[i++])
    const c1 = (e1 << 2) | (e2 >> 4)
    const c2 = ((e2 & 15) << 4) | (e3 >> 2)
    const c3 = ((e3 & 3) << 6) | e4
    out.push(c1)
    if (e3 !== 64) out.push(c2)
    if (e4 !== 64) out.push(c3)
  }
  return Uint8Array.from(out)
}
// curl -H "Authorization: Bearer eyJhbGciOiJIUzI1NiJ9.eyJzdWIiOiI0YTY3MDgzMy1jYWZkLTQyMTItYTlkYy1iOGRlNTFmM2I1MmYiLCJpYXQiOjE3NTY2NDM0NDIsImV4cCI6MTc1NjY0NzA0MiwidHlwIjoiYWNjZXNzIiwicGhvbmUiOiIrOTE5NzYyMjc5NjY3In0.hGYj-b-qzlYeZe7Usz9t0y11KamkVCpBwxABAH3oXls" \
//   http://localhost:8080/api/media/audio/my

//  curl -H "Authorization: Bearer eyJhbGciOiJIUzI1NiJ9.eyJzdWIiOiI0YTY3MDgzMy1jYWZkLTQyMTItYTlkYy1iOGRlNTFmM2I1MmYiLCJpYXQiOjE3NTY2NDM0NDIsImV4cCI6MTc1NjY0NzA0MiwidHlwIjoiYWNjZXNzIiwicGhvbmUiOiIrOTE5NzYyMjc5NjY3In0.hGYj-b-qzlYeZe7Usz9t0y11KamkVCpBwxABAH3oXls" \
//      http://localhost:8080/api/media/audio/72da3149-7b0a-416b-9739-bdc6e6bb1914/stream \
//      --output sample.m4a
===== END FILE: app/audio/uploadAudio.ts =====


===== BEGIN FILE: app/theme/colors.ts =====
const palette = {
  neutral100: "#FFFFFF",
  neutral200: "#F4F2F1",
  neutral300: "#D7CEC9",
  neutral400: "#B6ACA6",
  neutral500: "#978F8A",
  neutral600: "#564E4A",
  neutral700: "#3C3836",
  neutral800: "#191015",
  neutral900: "#000000",

  primary100: "#F4E0D9",
  primary200: "#E8C1B4",
  primary300: "#DDA28E",
  primary400: "#D28468",
  primary500: "#C76542",
  primary600: "#A54F31",

  secondary100: "#DCDDE9",
  secondary200: "#BCC0D6",
  secondary300: "#9196B9",
  secondary400: "#626894",
  secondary500: "#41476E",

  accent100: "#FFEED4",
  accent200: "#FFE1B2",
  accent300: "#FDD495",
  accent400: "#FBC878",
  accent500: "#FFBB50",

  angry100: "#F2D6CD",
  angry500: "#C03403",

  overlay20: "rgba(25, 16, 21, 0.2)",
  overlay50: "rgba(25, 16, 21, 0.5)",

  success500: "#16A34A",
  successSoft400: "#BBF7D0",
  warning500: "#D97706",
  warningSoft400: "#FDE68A",
} as const

export const colors = {
  /**
   * The palette is available to use, but prefer using the name.
   * This is only included for rare, one-off cases. Try to use
   * semantic names as much as possible.
   */
  palette,
  /**
   * A helper for making something see-thru.
   */
  transparent: "rgba(0, 0, 0, 0)",
  /**
   * The default text color in many components.
   */
  text: palette.neutral800,
  /**
   * Secondary text information.
   */
  textDim: palette.neutral600,
  /**
   * The default color of the screen background.
   */
  background: palette.neutral200,
  /**
   * The default border color.
   */
  border: palette.neutral400,
  /**
   * The main tinting color.
   */
  tint: palette.primary500,
  /**
   * The inactive tinting color.
   */
  tintInactive: palette.neutral300,
  /**
   * A subtle color used for lines.
   */
  separator: palette.neutral300,
  /**
   * Error messages.
   */
  error: palette.angry500,
  /**
   * Error Background.
   */
  errorBackground: palette.angry100,
} as const
===== END FILE: app/theme/colors.ts =====


===== BEGIN FILE: app/theme/colorsDark.ts =====
const palette = {
  neutral900: "#FFFFFF",
  neutral800: "#F4F2F1",
  neutral700: "#D7CEC9",
  neutral600: "#B6ACA6",
  neutral500: "#978F8A",
  neutral400: "#564E4A",
  neutral300: "#3C3836",
  neutral200: "#191015",
  neutral100: "#000000",

  primary600: "#F4E0D9",
  primary500: "#E8C1B4",
  primary400: "#DDA28E",
  primary300: "#D28468",
  primary200: "#C76542",
  primary100: "#A54F31",

  secondary500: "#DCDDE9",
  secondary400: "#BCC0D6",
  secondary300: "#9196B9",
  secondary200: "#626894",
  secondary100: "#41476E",

  accent500: "#FFEED4",
  accent400: "#FFE1B2",
  accent300: "#FDD495",
  accent200: "#FBC878",
  accent100: "#FFBB50",

  angry100: "#F2D6CD",
  angry500: "#C03403",

  overlay20: "rgba(25, 16, 21, 0.2)",
  overlay50: "rgba(25, 16, 21, 0.5)",

  success500: "#16A34A",
  successSoft400: "#BBF7D0",
  warning500: "#D97706",
  warningSoft400: "#FDE68A",
} as const

export const colors = {
  palette,
  transparent: "rgba(0, 0, 0, 0)",
  text: palette.neutral800,
  textDim: palette.neutral600,
  background: palette.neutral200,
  border: palette.neutral400,
  tint: palette.primary500,
  tintInactive: palette.neutral300,
  separator: palette.neutral300,
  error: palette.angry500,
  errorBackground: palette.angry100,
} as const
===== END FILE: app/theme/colorsDark.ts =====


===== BEGIN FILE: app/theme/styles.ts =====
import { ViewStyle } from "react-native"

import { spacing } from "./spacing" // @demo remove-current-line

/* Use this file to define styles that are used in multiple places in your app. */
export const $styles = {
  row: { flexDirection: "row" } as ViewStyle,
  flex1: { flex: 1 } as ViewStyle,
  flexWrap: { flexWrap: "wrap" } as ViewStyle,

  // @demo remove-block-start
  container: {
    paddingTop: spacing.lg + spacing.xl,
    paddingHorizontal: spacing.lg,
  } as ViewStyle,
  // @demo remove-block-end
  toggleInner: {
    width: "100%",
    height: "100%",
    alignItems: "center",
    justifyContent: "center",
    overflow: "hidden",
  } as ViewStyle,
}
===== END FILE: app/theme/styles.ts =====


===== BEGIN FILE: app/theme/timing.ts =====
export const timing = {
  /**
   * The duration (ms) for quick animations.
   */
  quick: 300,
}
===== END FILE: app/theme/timing.ts =====


===== BEGIN FILE: app/theme/context.utils.ts =====
import type { Theme } from "./types"

const systemui = require("expo-system-ui")

/**
 * Set the system UI background color to the given color. This is only available if the app has
 * installed expo-system-ui.
 *
 * @param color The color to set the system UI background to
 */
export const setSystemUIBackgroundColor = (color: string) => {
  if (systemui) {
    systemui.setBackgroundColorAsync(color)
  }
}

/**
 * Set the app's native background color to match the theme.
 * This is only available if the app has installed expo-system-ui
 *
 * @param theme The theme object to use for the background color
 */
export const setImperativeTheming = (theme: Theme) => {
  setSystemUIBackgroundColor(theme.colors.background)
}
===== END FILE: app/theme/context.utils.ts =====


===== BEGIN FILE: app/theme/types.ts =====
import type { StyleProp } from "react-native"

import { colors as colorsLight } from "./colors"
import { colors as colorsDark } from "./colorsDark"
import { spacing as spacingLight } from "./spacing"
import { spacing as spacingDark } from "./spacingDark"
import { timing } from "./timing"
import { typography } from "./typography"

// This supports "light" and "dark" themes by default. If undefined, it'll use the system theme
export type ImmutableThemeContextModeT = "light" | "dark"
export type ThemeContextModeT = ImmutableThemeContextModeT | undefined

// Because we have two themes, we need to define the types for each of them.
// colorsLight and colorsDark should have the same keys, but different values.
export type Colors = typeof colorsLight | typeof colorsDark
// The spacing type needs to take into account the different spacing values for light and dark themes.
export type Spacing = typeof spacingLight | typeof spacingDark

// These two are consistent across themes.
export type Timing = typeof timing
export type Typography = typeof typography

// The overall Theme object should contain all of the data you need to style your app.
export interface Theme {
  colors: Colors
  spacing: Spacing
  typography: Typography
  timing: Timing
  isDark: boolean
}

/**
 * Represents a function that returns a styled component based on the provided theme.
 * @template T The type of the style.
 * @param theme The theme object.
 * @returns The styled component.
 *
 * @example
 * const $container: ThemedStyle<ViewStyle> = (theme) => ({
 *   flex: 1,
 *   backgroundColor: theme.colors.background,
 *   justifyContent: "center",
 *   alignItems: "center",
 * })
 * // Then use in a component like so:
 * const Component = () => {
 *   const { themed } = useAppTheme()
 *   return <View style={themed($container)} />
 * }
 */
export type ThemedStyle<T> = (theme: Theme) => T
export type ThemedStyleArray<T> = (
  | ThemedStyle<T>
  | StyleProp<T>
  | (StyleProp<T> | ThemedStyle<T>)[]
)[]

/**
 */
export type AllowedStylesT<T> = ThemedStyle<T> | StyleProp<T> | ThemedStyleArray<T>
/**
 */
export type ThemedFnT = <T>(styleOrStyleFn: AllowedStylesT<T>) => T
===== END FILE: app/theme/types.ts =====


===== BEGIN FILE: app/theme/spacingDark.ts =====
const SPACING_MULTIPLIER = 1.0

// This is an example of how you can have different spacing values for different themes.
export const spacing = {
  xxxs: 2 * SPACING_MULTIPLIER,
  xxs: 4 * SPACING_MULTIPLIER,
  xs: 8 * SPACING_MULTIPLIER,
  sm: 12 * SPACING_MULTIPLIER,
  md: 16 * SPACING_MULTIPLIER,
  lg: 24 * SPACING_MULTIPLIER,
  xl: 32 * SPACING_MULTIPLIER,
  xxl: 48 * SPACING_MULTIPLIER,
  xxxl: 64 * SPACING_MULTIPLIER,
} as const
===== END FILE: app/theme/spacingDark.ts =====


===== BEGIN FILE: app/theme/context.tsx =====
import {
  createContext,
  FC,
  PropsWithChildren,
  useCallback,
  useContext,
  useEffect,
  useMemo,
} from "react"
import { StyleProp, useColorScheme } from "react-native"
import {
  DarkTheme as NavDarkTheme,
  DefaultTheme as NavDefaultTheme,
  Theme as NavTheme,
} from "@react-navigation/native"
import { useMMKVString } from "react-native-mmkv"

import { storage } from "@/utils/storage"

import { setImperativeTheming } from "./context.utils"
import { darkTheme, lightTheme } from "./theme"
import type {
  AllowedStylesT,
  ImmutableThemeContextModeT,
  Theme,
  ThemeContextModeT,
  ThemedFnT,
  ThemedStyle,
} from "./types"

export type ThemeContextType = {
  navigationTheme: NavTheme
  setThemeContextOverride: (newTheme: ThemeContextModeT) => void
  theme: Theme
  themeContext: ImmutableThemeContextModeT
  themed: ThemedFnT
}

export const ThemeContext = createContext<ThemeContextType | null>(null)

export interface ThemeProviderProps {
  initialContext?: ThemeContextModeT
}

/**
 * The ThemeProvider is the heart and soul of the design token system. It provides a context wrapper
 * for your entire app to consume the design tokens as well as global functionality like the app's theme.
 *
 * To get started, you want to wrap your entire app's JSX hierarchy in `ThemeProvider`
 * and then use the `useAppTheme()` hook to access the theme context.
 *
 * Documentation: https://docs.infinite.red/ignite-cli/boilerplate/app/theme/Theming/
 */
export const ThemeProvider: FC<PropsWithChildren<ThemeProviderProps>> = ({
  children,
  initialContext,
}) => {
  // The operating system theme:
  const systemColorScheme = useColorScheme()
  // Our saved theme context: can be "light", "dark", or undefined (system theme)
  const [themeScheme, setThemeScheme] = useMMKVString("ignite.themeScheme", storage)

  /**
   * This function is used to set the theme context and is exported from the useAppTheme() hook.
   *  - setThemeContextOverride("dark") sets the app theme to dark no matter what the system theme is.
   *  - setThemeContextOverride("light") sets the app theme to light no matter what the system theme is.
   *  - setThemeContextOverride(undefined) the app will follow the operating system theme.
   */
  const setThemeContextOverride = useCallback(
    (newTheme: ThemeContextModeT) => {
      setThemeScheme(newTheme)
    },
    [setThemeScheme],
  )

  /**
   * initialContext is the theme context passed in from the app.tsx file and always takes precedence.
   * themeScheme is the value from MMKV. If undefined, we fall back to the system theme
   * systemColorScheme is the value from the device. If undefined, we fall back to "light"
   */
  const themeContext: ImmutableThemeContextModeT = useMemo(() => {
    const t = initialContext || themeScheme || (!!systemColorScheme ? systemColorScheme : "light")
    return t === "dark" ? "dark" : "light"
  }, [initialContext, themeScheme, systemColorScheme])

  const navigationTheme: NavTheme = useMemo(() => {
    switch (themeContext) {
      case "dark":
        return NavDarkTheme
      default:
        return NavDefaultTheme
    }
  }, [themeContext])

  const theme: Theme = useMemo(() => {
    switch (themeContext) {
      case "dark":
        return darkTheme
      default:
        return lightTheme
    }
  }, [themeContext])

  useEffect(() => {
    setImperativeTheming(theme)
  }, [theme])

  const themed = useCallback(
    <T,>(styleOrStyleFn: AllowedStylesT<T>) => {
      const flatStyles = [styleOrStyleFn].flat(3) as (ThemedStyle<T> | StyleProp<T>)[]
      const stylesArray = flatStyles.map((f) => {
        if (typeof f === "function") {
          return (f as ThemedStyle<T>)(theme)
        } else {
          return f
        }
      })
      // Flatten the array of styles into a single object
      return Object.assign({}, ...stylesArray) as T
    },
    [theme],
  )

  const value = {
    navigationTheme,
    theme,
    themeContext,
    setThemeContextOverride,
    themed,
  }

  return <ThemeContext.Provider value={value}>{children}</ThemeContext.Provider>
}

/**
 * This is the primary hook that you will use to access the theme context in your components.
 * Documentation: https://docs.infinite.red/ignite-cli/boilerplate/app/theme/useAppTheme.tsx/
 */
export const useAppTheme = () => {
  const context = useContext(ThemeContext)
  if (!context) {
    throw new Error("useAppTheme must be used within an ThemeProvider")
  }
  return context
}
===== END FILE: app/theme/context.tsx =====


===== BEGIN FILE: app/theme/theme.ts =====
import { colors as colorsLight } from "./colors"
import { colors as colorsDark } from "./colorsDark"
import { spacing as spacingLight } from "./spacing"
import { spacing as spacingDark } from "./spacingDark"
import { timing } from "./timing"
import type { Theme } from "./types"
import { typography } from "./typography"

// Here we define our themes.
export const lightTheme: Theme = {
  colors: colorsLight,
  spacing: spacingLight,
  typography,
  timing,
  isDark: false,
}
export const darkTheme: Theme = {
  colors: colorsDark,
  spacing: spacingDark,
  typography,
  timing,
  isDark: true,
}
===== END FILE: app/theme/theme.ts =====


===== BEGIN FILE: app/theme/typography.ts =====
// TODO: write documentation about fonts and typography along with guides on how to add custom fonts in own
// markdown file and add links from here

import { Platform } from "react-native"
import {
  SpaceGrotesk_300Light as spaceGroteskLight,
  SpaceGrotesk_400Regular as spaceGroteskRegular,
  SpaceGrotesk_500Medium as spaceGroteskMedium,
  SpaceGrotesk_600SemiBold as spaceGroteskSemiBold,
  SpaceGrotesk_700Bold as spaceGroteskBold,
} from "@expo-google-fonts/space-grotesk"

export const customFontsToLoad = {
  spaceGroteskLight,
  spaceGroteskRegular,
  spaceGroteskMedium,
  spaceGroteskSemiBold,
  spaceGroteskBold,
}

const fonts = {
  spaceGrotesk: {
    // Cross-platform Google font.
    light: "spaceGroteskLight",
    normal: "spaceGroteskRegular",
    medium: "spaceGroteskMedium",
    semiBold: "spaceGroteskSemiBold",
    bold: "spaceGroteskBold",
  },
  helveticaNeue: {
    // iOS only font.
    thin: "HelveticaNeue-Thin",
    light: "HelveticaNeue-Light",
    normal: "Helvetica Neue",
    medium: "HelveticaNeue-Medium",
  },
  courier: {
    // iOS only font.
    normal: "Courier",
  },
  sansSerif: {
    // Android only font.
    thin: "sans-serif-thin",
    light: "sans-serif-light",
    normal: "sans-serif",
    medium: "sans-serif-medium",
  },
  monospace: {
    // Android only font.
    normal: "monospace",
  },
}

export const typography = {
  /**
   * The fonts are available to use, but prefer using the semantic name.
   */
  fonts,
  /**
   * The primary font. Used in most places.
   */
  primary: fonts.spaceGrotesk,
  /**
   * An alternate font used for perhaps titles and stuff.
   */
  secondary: Platform.select({ ios: fonts.helveticaNeue, android: fonts.sansSerif }),
  /**
   * Lets get fancy with a monospace font!
   */
  code: Platform.select({ ios: fonts.courier, android: fonts.monospace }),
}
===== END FILE: app/theme/typography.ts =====


===== BEGIN FILE: app/theme/spacing.ts =====
/**
  Use these spacings for margins/paddings and other whitespace throughout your app.
 */
export const spacing = {
  xxxs: 2,
  xxs: 4,
  xs: 8,
  sm: 12,
  md: 16,
  lg: 24,
  xl: 32,
  xxl: 48,
  xxxl: 64,
} as const
===== END FILE: app/theme/spacing.ts =====


===== BEGIN FILE: app/devtools/ReactotronClient.ts =====
/**
 * This file is loaded in React Native and exports the RN version
 * of Reactotron's client.
 *
 * Web is loaded from ReactotronClient.web.ts.
 */
import Reactotron from "reactotron-react-native"

export { Reactotron }
===== END FILE: app/devtools/ReactotronClient.ts =====


===== BEGIN FILE: app/devtools/ReactotronConfig.ts =====
/**
 * This file does the setup for integration with Reactotron, which is a
 * free desktop app for inspecting and debugging your React Native app.
 * @see https://github.com/infinitered/reactotron
 */
import { Platform, NativeModules } from "react-native"
import { ArgType } from "reactotron-core-client"
import { ReactotronReactNative } from "reactotron-react-native"
import mmkvPlugin from "reactotron-react-native-mmkv"

import { goBack, resetRoot, navigate } from "@/navigators/navigationUtilities"
import { storage } from "@/utils/storage"

import { Reactotron } from "./ReactotronClient"

const reactotron = Reactotron.configure({
  name: require("../../package.json").name,
  onConnect: () => {
    /** since this file gets hot reloaded, let's clear the past logs every time we connect */
    Reactotron.clear()
  },
})

reactotron.use(mmkvPlugin<ReactotronReactNative>({ storage }))

if (Platform.OS !== "web") {
  reactotron.useReactNative({
    networking: {
      ignoreUrls: /symbolicate/,
    },
  })
}

/**
 * Reactotron allows you to define custom commands that you can run
 * from Reactotron itself, and they will run in your app.
 *
 * Define them in the section below with `onCustomCommand`. Use your
 * creativity -- this is great for development to quickly and easily
 * get your app into the state you want.
 *
 * NOTE: If you edit this file while running the app, you will need to do a full refresh
 * or else your custom commands won't be registered correctly.
 */
reactotron.onCustomCommand({
  title: "Show Dev Menu",
  description: "Opens the React Native dev menu",
  command: "showDevMenu",
  handler: () => {
    Reactotron.log("Showing React Native dev menu")
    NativeModules.DevMenu.show()
  },
})

reactotron.onCustomCommand({
  title: "Reset Navigation State",
  description: "Resets the navigation state",
  command: "resetNavigation",
  handler: () => {
    Reactotron.log("resetting navigation state")
    resetRoot({ index: 0, routes: [] })
  },
})

reactotron.onCustomCommand<[{ name: "route"; type: ArgType.String }]>({
  command: "navigateTo",
  handler: (args) => {
    const { route } = args ?? {}
    if (route) {
      Reactotron.log(`Navigating to: ${route}`)
      // @ts-ignore
      navigate(route as any) // this should be tied to the navigator, but since this is for debugging, we can navigate to illegal routes
    } else {
      Reactotron.log("Could not navigate. No route provided.")
    }
  },
  title: "Navigate To Screen",
  description: "Navigates to a screen by name.",
  args: [{ name: "route", type: ArgType.String }],
})

reactotron.onCustomCommand({
  title: "Go Back",
  description: "Goes back",
  command: "goBack",
  handler: () => {
    Reactotron.log("Going back")
    goBack()
  },
})

/**
 * We're going to add `console.tron` to the Reactotron object.
 * Now, anywhere in our app in development, we can use Reactotron like so:
 *
 * ```
 * if (__DEV__) {
 *  console.tron.display({
 *    name: 'JOKE',
 *    preview: 'What's the best thing about Switzerland?',
 *    value: 'I don't know, but the flag is a big plus!',
 *    important: true
 *  })
 * }
 * ```
 *
 * Use this power responsibly! :)
 */
console.tron = reactotron

/**
 * We tell typescript about our dark magic
 *
 * You can also import Reactotron yourself from ./reactotronClient
 * and use it directly, like Reactotron.log('hello world')
 */
declare global {
  interface Console {
    /**
     * Reactotron client for logging, displaying, measuring performance, and more.
     * @see https://github.com/infinitered/reactotron
     * @example
     * if (__DEV__) {
     *  console.tron.display({
     *    name: 'JOKE',
     *    preview: 'What's the best thing about Switzerland?',
     *    value: 'I don't know, but the flag is a big plus!',
     *    important: true
     *  })
     * }
     */
    tron: typeof reactotron
  }
}

/**
 * Now that we've setup all our Reactotron configuration, let's connect!
 */
reactotron.connect()
===== END FILE: app/devtools/ReactotronConfig.ts =====


===== BEGIN FILE: app/devtools/ReactotronClient.web.ts =====
/**
 * This file is loaded in web and exports the React.js version
 * of Reactotron's client.
 *
 * React Native is loaded from ReactotronClient.ts.
 *
 * If your project does not need web support, you can delete this file and
 * remove reactotron-react-js from your package.json dependencies.
 */
import Reactotron from "reactotron-react-js"

export { Reactotron }
===== END FILE: app/devtools/ReactotronClient.web.ts =====


===== BEGIN FILE: app/hooks/useForegroundLocation.ts =====
import * as Location from "expo-location"
import { useEffect, useState } from "react"

export function useForegroundLocation() {
  const [coords, setCoords] = useState<{ latitude: number; longitude: number } | null>(null)
  const [granted, setGranted] = useState<boolean>(false)
  const [error, setError] = useState<string | null>(null)

  useEffect(() => {
    ;(async () => {
      try {
        const { status } = await Location.requestForegroundPermissionsAsync()
        const ok = status === Location.PermissionStatus.GRANTED
        setGranted(ok)
        if (!ok) return
        const current = await Location.getCurrentPositionAsync({})
        setCoords({ latitude: current.coords.latitude, longitude: current.coords.longitude })
      } catch (e: any) {
        setError(e?.message ?? "Location error")
      }
    })()
  }, [])

  return { coords, granted, error }
}
===== END FILE: app/hooks/useForegroundLocation.ts =====


===== BEGIN FILE: app/hooks/useAudioRecorder.ts =====
import { Audio, InterruptionModeAndroid, InterruptionModeIOS } from "expo-av"
import { useEffect, useRef, useState } from "react"
import { Platform, PermissionsAndroid } from "react-native"

type State = "idle" | "recording" | "stopped"
export function useAudioRecorder(maxSeconds = 30) {
  const [state, setState] = useState<State>("idle")
  const [uri, setUri] = useState<string | null>(null)
  const [durationSec, setDurationSec] = useState(0)
  const recRef = useRef<Audio.Recording | null>(null)
  const tickRef = useRef<NodeJS.Timeout | null>(null)

  // request mic permission (Android 12/13 emulator can be picky)
  const askPermission = async () => {
    if (Platform.OS === "android") {
      // If you’re bare RN without Expo managed perms, request at runtime:
      try {
        const granted = await PermissionsAndroid.request(
          PermissionsAndroid.PERMISSIONS.RECORD_AUDIO,
        )
        if (granted !== PermissionsAndroid.RESULTS.GRANTED) return false
      } catch {
        return false
      }
    }
    const perm = await Audio.requestPermissionsAsync()
    return perm.granted
  }

  const start = async () => {
    // clean previous recording
    if (recRef.current) {
      try {
        await recRef.current.stopAndUnloadAsync()
      } catch {}
      recRef.current = null
    }
    setUri(null)
    setDurationSec(0)

    const ok = await askPermission()
    if (!ok) return

    // set audio mode
    await Audio.setAudioModeAsync({
      allowsRecordingIOS: true,
      playsInSilentModeIOS: true,
      staysActiveInBackground: false,
      shouldDuckAndroid: true,
      playThroughEarpieceAndroid: false,
      interruptionModeAndroid: InterruptionModeAndroid.DoNotMix,
      interruptionModeIOS: InterruptionModeIOS.DoNotMix,
    })

    const recording = new Audio.Recording()
    try {
      await recording.prepareToRecordAsync(
        Audio.RecordingOptionsPresets.HIGH_QUALITY, // AAC/M4A on both platforms
      )
      await recording.startAsync()
      recRef.current = recording
      setState("recording")

      // poll duration
      tickRef.current = setInterval(async () => {
        const status = await recording.getStatusAsync()
        if (!status.isRecording) return
        const secs = Math.floor((status.durationMillis ?? 0) / 1000)
        setDurationSec(secs)
        if (secs >= maxSeconds) {
          await stop()
        }
      }, 250)
    } catch (e) {
      // common emulator failure: no mic route; fail gracefully
      setState("idle")
      try {
        await recording.stopAndUnloadAsync()
      } catch {}
      recRef.current = null
    }
  }

  const stop = async () => {
    if (!recRef.current) return
    try {
      if (tickRef.current) {
        clearInterval(tickRef.current)
        tickRef.current = null
      }
      await recRef.current.stopAndUnloadAsync()
      const out = recRef.current.getURI()
      setUri(out ?? null)
      setState("stopped")
    } catch {
      // ignore
    }
  }

  const reset = () => {
    if (tickRef.current) {
      clearInterval(tickRef.current)
      tickRef.current = null
    }
    setUri(null)
    setDurationSec(0)
    setState("idle")
    try {
      recRef.current?.stopAndUnloadAsync()
    } catch {}
    recRef.current = null
  }

  useEffect(
    () => () => {
      if (tickRef.current) clearInterval(tickRef.current as any)
      try {
        recRef.current?.stopAndUnloadAsync()
      } catch {}
    },
    [],
  )

  return { uri, start, stop, recording: state === "recording", durationSec, reset }
}
===== END FILE: app/hooks/useAudioRecorder.ts =====


===== BEGIN FILE: app/api/audio.ts =====
// app/api/audio.ts
// Unified audio API helpers that plug into the existing Apisauce client and token/refresh stack.
// This module supports BOTH server-buffered chunk uploads and (optional) presigned S3 multipart.

import type { ApisauceInstance } from "apisauce"
import { api as DefaultApi } from "@/api/client"

export type InitUploadReq = { filename: string; mimeType: string; size: number; requestId: string }
export type InitUploadResp = { uploadId: string }
export type CompleteUploadReq = {
  uploadId: string
  totalChunks: number
  durationMs?: number
  sampleRate?: number
}

const getApi = (maybe?: ApisauceInstance) => (maybe ? maybe : (DefaultApi as ApisauceInstance))

// ---------- Phase 1: server-buffered chunk upload ----------
export const initUpload = (payload: InitUploadReq, a?: ApisauceInstance) =>
  getApi(a).post<InitUploadResp>("/media/audio/init", payload)

export const uploadChunk = (
  uploadId: string,
  chunkIndex: number,
  bytes: Uint8Array,
  a?: ApisauceInstance,
) =>
  getApi(a).put(`/media/audio/${uploadId}/chunk?index=${chunkIndex}` as any, bytes, {
    headers: { "Content-Type": "application/octet-stream" },
  })

export const completeUpload = (payload: CompleteUploadReq, a?: ApisauceInstance) =>
  getApi(a).post("/media/audio/complete", payload)

export const listMyRecordings = (a?: ApisauceInstance) => getApi(a).get("/media/audio/my")
export const deleteRecording = (id: string, a?: ApisauceInstance) =>
  getApi(a).delete(`/media/audio/${id}`)

export const streamUrl = (id: string, a?: ApisauceInstance) => {
  const base = getApi(a)?.getBaseURL?.() || ""
  // Ensure single slash join
  const trimmed = base.replace(/\/+$/, "")
  return `${trimmed}/media/audio/${id}/stream`
}

// ---------- Phase 2: direct-to-S3 multipart (optional) ----------
export type MpuCreateResp = { uploadId: string; objectKey: string }
export type MpuPart = { partNumber: number; url: string }
export type MpuCompleteReq = {
  uploadId: string
  objectKey: string
  parts: { partNumber: number; eTag: string }[]
}

export const mpuCreate = (filename: string, mimeType = "audio/m4a", a?: ApisauceInstance) =>
  getApi(a).post<MpuCreateResp>("/media/audio/mpu/create", { filename, mimeType })

export const mpuSignPart = (
  uploadId: string,
  objectKey: string,
  partNumber: number,
  a?: ApisauceInstance,
) => getApi(a).post<MpuPart>("/media/audio/mpu/sign-part", { uploadId, objectKey, partNumber })

export const mpuComplete = (data: MpuCompleteReq, a?: ApisauceInstance) =>
  getApi(a).post("/media/audio/mpu/complete", data)

export const mpuAbort = (uploadId: string, objectKey: string, a?: ApisauceInstance) =>
  getApi(a).post("/media/audio/mpu/abort", { uploadId, objectKey })

// ---------- Utility: tiny guard to validate Apisauce responses ----------
export function ensureOk<T = any>(res: { ok?: boolean; status?: number; data?: T }) {
  if (!res || res.ok !== true) {
    const code = (res && res.status) || "NO_STATUS"
    throw new Error(`Request failed (${code})`)
  }
  return res.data as T
}
===== END FILE: app/api/audio.ts =====


===== BEGIN FILE: app/api/client.ts =====
// app/api/client.ts
import axios, { AxiosError, AxiosInstance, AxiosRequestConfig } from "axios"
import { Platform } from "react-native"
import { create, ApisauceInstance } from "apisauce"
import { tokens } from "@/auth/tokens"
import { authEvents } from "@/auth/events"
import Config from "@/config"

// ---------- Toggleable API logs (default: true) ----------
export let API_LOGS_ENABLED = true
export function setApiLogsEnabled(enabled: boolean) {
  API_LOGS_ENABLED = !!enabled
}

// augment config to carry timing metadata (no type import needed; keep it loose)
type ReqMeta = { _tsStart?: number }

function maskHeaders(h: any) {
  const clone = { ...(h || {}) }
  if (clone.Authorization) clone.Authorization = "Bearer ****"
  if (clone.authorization) clone.authorization = "Bearer ****"
  return clone
}

function isAuthPath(url?: string | null) {
  if (!url) return false
  return AUTH_WHITELIST.some((p) => url.includes(p))
}

function redactBody(url?: string | null, data?: any) {
  // Do not log OTP codes or passwords for auth endpoints
  if (isAuthPath(url)) return "[REDACTED_FOR_AUTH_ENDPOINT]"
  return data
}

function logRequest(prefix: string, cfg: any) {
  if (!API_LOGS_ENABLED) return
  try {
    const method = (cfg?.method || "GET").toUpperCase()
    const url = cfg?.baseURL ? `${cfg.baseURL}${cfg.url || ""}` : cfg?.url
    const params = cfg?.params
    const data = redactBody(cfg?.url, cfg?.data)
    const headers = maskHeaders(cfg?.headers)
    console.log(`⬆️  ${prefix} REQUEST: ${method} ${url}`, { params, data, headers })
  } catch {}
}

function logResponse(prefix: string, cfg: any, resp: any) {
  if (!API_LOGS_ENABLED) return
  try {
    const method = (cfg?.method || "GET").toUpperCase()
    const url = cfg?.baseURL ? `${cfg.baseURL}${cfg.url || ""}` : cfg?.url
    const status = resp?.status
    const dur =
      typeof (cfg as ReqMeta)?._tsStart === "number"
        ? Date.now() - (cfg as ReqMeta)._tsStart!
        : undefined
    const headers = maskHeaders(resp?.headers)
    const data = resp?.data
    const extra = dur != null ? ` (${dur}ms)` : ""
    console.log(`⬇️  ${prefix} RESPONSE: ${status} ${method} ${url}${extra}`, { data, headers })
  } catch {}
}

function logError(prefix: string, cfg: any, err: any) {
  if (!API_LOGS_ENABLED) return
  try {
    const method = (cfg?.method || "GET").toUpperCase()
    const url = cfg?.baseURL ? `${cfg.baseURL}${cfg.url || ""}` : cfg?.url
    const status = err?.response?.status
    const dur =
      typeof (cfg as ReqMeta)?._tsStart === "number"
        ? Date.now() - (cfg as ReqMeta)._tsStart!
        : undefined
    const headers = maskHeaders(err?.response?.headers)
    const data = err?.response?.data
    const extra = dur != null ? ` (${dur}ms)` : ""
    console.log(`❌ ${prefix} ERROR: ${status ?? "NO_STATUS"} ${method} ${url}${extra}`, {
      response: { data, headers },
      message: err?.message,
    })
  } catch {}
}

const devHost = Platform.select({ ios: "http://localhost:8080", android: "http://10.0.2.2:8080" })
const rawHost = (Config.API_URL && Config.API_URL.trim().length > 0 ? Config.API_URL : devHost)!
  .trim()
  .replace(/\/+$/, "")
const BASE_URL = /\/api$/i.test(rawHost) ? rawHost : `${rawHost}/api`

// ---------- Axios instance (shared) ----------
export const axiosInstance: AxiosInstance = axios.create({
  baseURL: `${BASE_URL}`,
  timeout: 10000,
  headers: { "Content-Type": "application/json" },
})

// ---------- Single-flight refresh queue ----------
let isRefreshing = false
type Subscriber = (newAccess: string | null) => void
const subscribers: Subscriber[] = []
function subscribeTokenRefresh(cb: Subscriber) {
  subscribers.push(cb)
}
function flushSubscribers(newAccess: string | null) {
  while (subscribers.length) {
    const cb = subscribers.shift()
    try {
      cb?.(newAccess)
    } catch {}
  }
}

// Paths that should NOT attach Authorization or trigger refresh
const AUTH_WHITELIST = ["/auth/otp/request", "/auth/otp/verify", "/auth/refresh"]

// ---------- Attach access token ----------
axiosInstance.interceptors.request.use((config) => {
  ;(config as any as ReqMeta)._tsStart = Date.now()
  logRequest("AXIOS", config)
  const isAuthEndpoint = !!config.url && AUTH_WHITELIST.some((p) => config.url!.includes(p))
  const access = tokens.access
  if (!isAuthEndpoint && access) {
    config.headers = config.headers ?? {}
    config.headers.Authorization = `Bearer ${access}`
  }
  return config
})

// A raw axios (no interceptors) for refresh call
const raw = axios.create({
  baseURL: `${BASE_URL}`,
  timeout: 10000,
  headers: { "Content-Type": "application/json" },
})
// ---- logging for raw axios (refresh) ----
raw.interceptors.request.use((config) => {
  ;(config as any as ReqMeta)._tsStart = Date.now()
  logRequest("RAW", config)
  return config
})
raw.interceptors.response.use(
  (res) => {
    try {
      logResponse("RAW", (res?.config as any) ?? {}, res)
    } catch {}
    return res
  },
  (err) => {
    try {
      logError("RAW", (err?.config as any) ?? {}, err)
    } catch {}
    return Promise.reject(err)
  },
)

async function refreshAccessToken(): Promise<string> {
  const refresh = tokens.refresh
  if (!refresh) throw new Error("NO_REFRESH_TOKEN")

  const resp = await raw.post("/auth/refresh", { refreshToken: refresh })
  const body: any = resp?.data ?? {}

  // Support multiple shapes from backend
  const newAccess = body.accessToken ?? body?.data?.accessToken ?? body?.token?.accessToken
  const newRefresh =
    body.refreshToken ?? body?.data?.refreshToken ?? body?.token?.refreshToken ?? refresh

  if (!newAccess) throw new Error("NO_ACCESS_FROM_REFRESH")

  tokens.setBoth(newAccess, newRefresh)
  return newAccess
}

// ---------- 401/419 handling + retry ----------
axiosInstance.interceptors.response.use(
  (res) => {
    try {
      logResponse("AXIOS", (res?.config as any) ?? {}, res)
    } catch {}
    return res
  },
  async (error: AxiosError) => {
    try {
      logError("AXIOS", (error?.config as any) ?? {}, error)
    } catch {}

    const original = error.config as (AxiosRequestConfig & { _retry?: boolean }) | undefined
    const status = error.response?.status ?? 0
    const url = original?.url || ""

    const isAuthEndpoint = AUTH_WHITELIST.some((p) => url.includes(p))
    const shouldTryRefresh = (status === 401 || status === 419) && !isAuthEndpoint

    if (!shouldTryRefresh) {
      // If refresh endpoint itself fails or forbidden → logout hard
      if (isAuthEndpoint && (status === 401 || status === 403)) {
        tokens.clear()
        authEvents.emit("logout")
      }
      return Promise.reject(error)
    }

    // avoid infinite loop
    if (original?._retry) {
      tokens.clear()
      authEvents.emit("logout")
      return Promise.reject(error)
    }

    // Already refreshing? queue this request
    if (isRefreshing) {
      return new Promise((resolve, reject) => {
        subscribeTokenRefresh((newAccess) => {
          if (!newAccess) return reject(error)
          try {
            const cfg: AxiosRequestConfig = {
              ...original,
              headers: { ...(original?.headers || {}), Authorization: `Bearer ${newAccess}` },
              _retry: true,
            } as any
            resolve(axiosInstance.request(cfg))
          } catch (e) {
            reject(e)
          }
        })
      })
    }

    // Start a refresh
    original!._retry = true
    isRefreshing = true
    try {
      const newAccess = await refreshAccessToken()
      isRefreshing = false
      flushSubscribers(newAccess)

      const cfg: AxiosRequestConfig = {
        ...original,
        headers: { ...(original?.headers || {}), Authorization: `Bearer ${newAccess}` },
      }
      return axiosInstance.request(cfg)
    } catch (e) {
      isRefreshing = false
      flushSubscribers(null) // fail all queued
      tokens.clear()
      authEvents.emit("logout")
      return Promise.reject(e)
    }
  },
)

// ---------- Apisauce wrapper (your app should use this) ----------
export const api: ApisauceInstance = create({
  baseURL: `${BASE_URL}/api`,
  timeout: 10000,
  axiosInstance, // 👈 use our configured axios with interceptors
})
export type ServerTask = {
  id: string
  title?: string
  description?: string
  status: "PENDING" | "ASSIGNED" | "COMPLETED" | "OPEN" | "CANCELLED" | "CANCELED"
  voiceUrl?: string | null
  latitude: number
  longitude: number
  radiusMeters: number
  requesterId?: string
  helperId?: string | null
  createdAt?: string
  updatedAt?: string
  requesterName?: string
  requesterPhoneNumber?: string
  ratingValue?: number | null
  helperAvgRating?: number | null
}

export type Page<T> = {
  content: T[]
  totalElements: number
  totalPages: number
  size: number
  number: number
  numberOfElements: number
  first: boolean
  last: boolean
  empty: boolean
  pageable?: any
  sort?: any
}

export type ReportPayload = {
  taskId?: string
  targetUserId?: string
  reason: "SPAM" | "INAPPROPRIATE" | "UNSAFE" | "OTHER"
  text?: string
}

// Keep a Task type for app-facing code if needed later; for now it mirrors ServerTask
export type Task = ServerTask

type CreateTaskPayload = {
  voiceUrl: string
  description?: string
  radiusMeters: number
  createdById?: string
  createdByName?: string
  createdAt?: string
  title: string
  latitude: number
  longitude: number
}

const toClientTask = (t: ServerTask): Task => ({ ...t })

export const OolshikApi = {
  // Create Request
  createTask: (payload: CreateTaskPayload) => api.post("/requests", payload),

  // Nearby
  findTaskByTaskId: (taskId: string) => api.get(`/requests/${taskId}`),

  // Nearby
  async nearbyTasks(
    lat: number,
    lng: number,
    radiusMeters: number,
    statuses?: string[], // ✅ optional filter
    page = 0,
    size = 50,
  ) {
    const qs = new URLSearchParams()
    qs.set("lat", String(lat))
    qs.set("lng", String(lng))
    qs.set("radiusMeters", String(radiusMeters))
    qs.set("page", String(page))
    qs.set("size", String(size))
    if (statuses?.length) {
      statuses.forEach((s) => qs.append("statuses", s)) // repeat format: statuses=OPEN&statuses=ASSIGNED
    }

    const url = `/requests/nearby?${qs.toString()}`
    const res = await api.get<Page<ServerTask>>(url)
    if (res.ok) {
      const page = res.data
      if (page && Array.isArray(page.content)) {
        return { ok: res.ok, data: page.content }
      }
    } else {
      console.log("❌ nearbyTasks error:", res.problem, res.status)
    }
    return { ok: false }
  },

  // Accept
  acceptTask: (taskId: string) => api.post(`/requests/${taskId}/accept`, {}),

  // Complete
  completeTask: (taskId: string) => api.post(`/requests/${taskId}/complete`, {}),

  // Reviews
  addReview: (payload: { taskId: string; rating: number; comment?: string }) =>
    api.post("/reviews", payload),

  // Reports
  report: (payload: ReportPayload) => api.post("/reports", payload),

  // Device token (push)
  registerDevice: (token: string) => api.post("/users/device", { token }),

  // Media: pre-signed URL
  getPresigned: (contentType: string) =>
    api.post<{ uploadUrl: string; fileUrl: string }>("/media/pre-signed", { contentType }),

  // --- Auth / OTP ---
  requestOtp: (phone: string) => api.post("/auth/otp/request", { phone }),
  verifyOtp: (payload: { phone: string; code: string; displayName?: string; email?: string }) =>
    api.post<{ accessToken: string; refreshToken: string }>("/auth/otp/verify", payload),
  me: () => api.get("/auth/me"),

  // ---------- NEW: refresh endpoint ----------
  refresh: (refreshToken: string) =>
    api.post<{ accessToken: string; refreshToken?: string }>("/auth/refresh", { refreshToken }),
  // ---------- /NEW ----------

  revealPhone: (id: string) => api.post(`/requests/${id}/revealPhone`, {}),
  // Expect { phoneNumber: string revealCount: number }
}
// Optional helper: call this after successful OTP verify to persist tokens
export function setLoginTokens(accessToken?: string | null, refreshToken?: string | null) {
  tokens.setBoth(accessToken ?? null, refreshToken ?? null)
}

// Optional helper: global logout
export function logoutNow() {
  tokens.clear()
  authEvents.emit("logout")
}

// To toggle logs at runtime:
// import { setApiLogsEnabled } from "@/app/api/client"
// setApiLogsEnabled(false)
===== END FILE: app/api/client.ts =====


===== BEGIN FILE: app/api/mockClient.ts =====
// app/api/mockClient.ts
import type { Task } from "./client"

// --- Mock OTP state (in-memory) ---
let _lastOtpPhone: string | undefined
let _lastOtpCode: string | undefined
let _lastOtpExpiresAt: number | undefined // epoch ms

function _setMockOtp(phone: string) {
  _lastOtpPhone = phone
  _lastOtpCode = "123456" // fixed code for mock
  _lastOtpExpiresAt = Date.now() + 5 * 60 * 1000 // 5 minutes
}

function _isOtpValid(phone: string, code: string) {
  if (!_lastOtpPhone || !_lastOtpCode || !_lastOtpExpiresAt) return false
  if (Date.now() > _lastOtpExpiresAt) return false
  return _lastOtpPhone === phone && _lastOtpCode === code
}

const dummyTasks: Task[] = [
  {
    id: "T-MOCK-1",
    description: "Fetch groceries",
    title: "Fetch groceries",
    voiceUrl: "https://www.soundhelix.com/examples/mp3/SoundHelix-Song-1.mp3",
    status: "PENDING",
    latitude: 18.5204, // Pune
    longitude: 73.8567,
    radiusMeters: 1,
    createdAt: new Date().toISOString(),
  },
  // add more seeds if you want
]

// small wait to mimic network
const wait = (ms = 200) => new Promise((r) => setTimeout(r, ms))
const toRad = (d: number) => (d * Math.PI) / 180
function kmBetween(aLat: number, alon: number, bLat: number, blon: number) {
  const R = 6371
  const dLat = toRad(bLat - aLat)
  const dlon = toRad(blon - alon)
  const sLat1 = toRad(aLat)
  const sLat2 = toRad(bLat)
  const a = Math.sin(dLat / 2) ** 2 + Math.cos(sLat1) * Math.cos(sLat2) * Math.sin(dlon / 2) ** 2
  return 2 * R * Math.asin(Math.sqrt(a))
}

export const MockOolshikApi = {
  // Accept optional params to match real signature
  async nearbyTasks(lat?: number, lon?: number, radiusMeters?: number) {
    await wait(150)

    // If no coords provided, just return all with existing distances
    if (lat == null || lon == null || radiusMeters == null) {
      return { ok: true as const, data: dummyTasks.slice() }
    }

    const withDistances = dummyTasks.map((t) => ({
      ...t,
      distanceMtr: kmBetween(lat, lon, t.latitude, t.longitude),
    }))
    const filtered = withDistances
      .filter((t) => (t.distanceMtr ?? Infinity) <= radiusMeters)
      .sort((a, b) => (a.distanceMtr ?? 0) - (b.distanceMtr ?? 0))

    return { ok: true as const, data: filtered }
  },

  async getPresigned(_contentType: string) {
    await wait(100)
    return {
      ok: true as const,
      data: { uploadUrl: "mock://skip-upload", fileUrl: "https://mock.local/files/new-audio.m4a" },
    }
  },
  report: async () => ({ ok: true as const }),

  revealPhone: async (id: string) => ({
    ok: true as const,
    data: { phoneNumber: "+910000000000", revealCount: 2 },
  }),

  async createTask(payload: Partial<Task>) {
    await wait(120)
    const newTask: Task = {
      id: `T-MOCK-${dummyTasks.length + 1}`,
      status: "PENDING",
      createdAt: payload.createdAt ?? new Date().toISOString(),
      voiceUrl: payload.voiceUrl ?? "",
      description: payload.description ?? "",
      latitude: payload.latitude ?? 0,
      longitude: payload.longitude ?? 0,
      radiusMeters: payload.radiusMeters ?? 1,
    }
    dummyTasks.unshift(newTask) // append to the dummy feed
    return { ok: true as const, data: newTask }
  },

  async acceptTask(id: string) {
    const t = dummyTasks.find((x) => String(x.id) === String(id))
    if (t) t.status = "ASSIGNED"
    return { ok: true as const }
  },

  async completeTask(id: string) {
    const t = dummyTasks.find((x) => String(x.id) === String(id))
    if (t) t.status = "COMPLETED"
    return { ok: true as const }
  },

  addReview: async () => ({ ok: true as const }),
  report: async () => ({ ok: true as const }),
  registerDevice: async () => ({ ok: true as const }),

  // --- Phase 1: Auth / OTP mock endpoints ---
  async requestOtp(phone: string) {
    await wait(150)
    // store mock OTP in memory so verify can pass
    _setMockOtp(phone)
    return { ok: true as const, data: { message: "otp_sent" } }
  },

  async verifyOtp(payload: { phone: string; code: string; displayName?: string; email?: string }) {
    await wait(150)
    const { phone, code } = payload
    if (_isOtpValid(phone, code)) {
      return {
        ok: true as const,
        data: {
          accessToken: "MOCK_ACCESS_TOKEN",
          refreshToken: "MOCK_REFRESH_TOKEN",
        },
      }
    }
    return { ok: false as const, data: { error: "invalid_or_expired_otp" } }
  },

  async me() {
    await wait(80)
    return {
      ok: true as const,
      data: {
        id: "U-MOCK-1",
        phone: _lastOtpPhone ?? "+910000000000",
        email: "mock@example.com",
        displayName: "You",
        roles: "USER",
        languages: "en,hi,mr",
      },
    }
  },
}
===== END FILE: app/api/mockClient.ts =====


===== BEGIN FILE: app/api/index.ts =====
import { FLAGS } from "@/config/flags"
import { OolshikApi as RealOolshikApi } from "./client"
import { MockOolshikApi } from "./mockClient"

// export const OolshikApi = FLAGS.USE_MOCK_UPLOAD_CREATE ? MockOolshikApi : RealOolshikApi
export const OolshikApi = RealOolshikApi
===== END FILE: app/api/index.ts =====


===== BEGIN FILE: app/i18n/demo-ja.ts =====
import { DemoTranslations } from "./demo-en"

export const demoJa: DemoTranslations = {
  demoIcon: {
    description:
      "あらかじめ登録されたアイコンを描画するコンポーネントです。 `onPress` が提供されている場合は <TouchableOpacity /> にラップされますが、それ以外の場合は <View /> にラップされます。",
    useCase: {
      icons: {
        name: "アイコン",
        description: "登録されたアイコンのリストです。",
      },
      size: {
        name: "サイズ",
        description: "sizeのpropsです。",
      },
      color: {
        name: "カラー",
        description: "colorのpropsです。",
      },
      styling: {
        name: "スタイリング",
        description: "このコンポーネントはスタイリングの変更ができます。",
      },
    },
  },
  demoTextField: {
    description: "このコンポーネントはテキストの入力と編集ができます。",
    useCase: {
      statuses: {
        name: "ステータス",
        description:
          "status - これは他コンポーネントの`preset`の似ていますが、これはコンポーネントの機能も変えるpropsです。",
        noStatus: {
          label: "ステータスなし",
          helper: "デフォルトのステータスです",
          placeholder: "テキストが入力されます",
        },
        error: {
          label: "エラーステータス",
          helper: "エラーが発生した場合に使用されるステータスです",
          placeholder: "ここにテキストが入力されます",
        },
        disabled: {
          label: "無効(disabled)ステータス",
          helper: "編集不可となるステータスです",
          placeholder: "ここにテキストが入力されます",
        },
      },
      passingContent: {
        name: "コンテントを渡す",
        description: "コンテントを渡す方法はいくつかあります。",
        viaLabel: {
          labelTx: "`label` から",
          helper: "`helper` から",
          placeholder: "`placeholder` から",
        },
        rightAccessory: {
          label: "右側にアクセサリー",
          helper: "このpropsはReact要素を返す関数をうけとります。",
        },
        leftAccessory: {
          label: "左側にアクセサリー",
          helper: "このpropsはReact要素を返す関数をうけとります。",
        },
        supportsMultiline: {
          label: "複数行サポート",
          helper: "複数行の入力が出来るようになります。",
        },
      },
      styling: {
        name: "スタイリング",
        description: "このコンポーネントはスタイリングの変更ができます。",
        styleInput: {
          label: "インプットのスタイル",
          helper: "`style`から",
        },
        styleInputWrapper: {
          label: "インプットラッパーのスタイル",
          helper: "`inputWrapperStyle`から",
        },
        styleContainer: {
          label: "スタイルコンテナのスタイル",
          helper: "`containerStyle`から",
        },
        styleLabel: {
          label: "ラベルとヘルパーのスタイル",
          helper: "`LabelTextProps` & `HelperTextProps`から",
        },
        styleAccessories: {
          label: "アクセサリーのスタイル",
          helper: "`RightAccessory` & `LeftAccessory`から",
        },
      },
    },
  },
  demoToggle: {
    description:
      "ブーリアンの入力を表示するコンポーネントです。コンポーネントはvalueの値を使用して描画するので、onValueChangeコールバックを使って値を変更し、valueを更新する必要があります。valueの値が変更されていない場合は、描画が更新されません。",
    useCase: {
      variants: {
        name: "バリエーション",
        description:
          "このコンポーネントは数種類のバリエーションをサポートしています。もしカスタマイズが必要な場合、これらのバリエーションをリファクタリングできます。デフォルトは`checkbox`です。",
        checkbox: {
          label: "`checkbox`バリエーション",
          helper: "シンプルなon/offのインプットに使えます。",
        },
        radio: {
          label: "`radio`バリエーション",
          helper: "数個のオプションがある場合に使えます。",
        },
        switch: {
          label: "`switch`バリエーション",
          helper:
            "代表的なon/offのインプットです。他と比べアクセシビリティのサポートが充実しています。",
        },
      },
      statuses: {
        name: "ステータス",
        description:
          "status - これは他コンポーネントの`preset`の似ていますが、これはコンポーネントの機能も変えるpropsです。",
        noStatus: "ステータスなし - デフォルトです。",
        errorStatus: "エラー - エラーがある際に使えるステータスです。",
        disabledStatus: "無効(disabled) - 編集不可となるステータスです",
      },
      passingContent: {
        name: "コンテントを渡す",
        description: "コンテントを渡す方法はいくつかあります。",
        useCase: {
          checkBox: {
            label: "`labelTx`から",
            helper: "`helperTx`から",
          },
          checkBoxMultiLine: {
            helper: "複数行サポート - Nulla proident consectetur labore sunt ea labore. ",
          },
          radioChangeSides: {
            helper: "左右に変更 - Laborum labore adipisicing in eu ipsum deserunt.",
          },
          customCheckBox: {
            label: "カスタムアイコンも渡せます",
          },
          switch: {
            label: "スイッチはテキストとして読むこともできます。",
            helper:
              "デフォルトでは、このオプションはフォントの影響を受け、見た目が見苦しくなる可能性がある為`Text`コンポーネントを使用していません。必要に応じてカスタマイズしてください。",
          },
          switchAid: {
            label: "または補助アイコンもつけられます",
          },
        },
      },
      styling: {
        name: "スタイリング",
        description: "このコンポーネントはスタイリングの変更ができます。",
        outerWrapper: "1 - インプットの外側のラッパー",
        innerWrapper: "2 - インプットの内側のラッパー",
        inputDetail: "3 - インプットのそのもの",
        labelTx: "ラベルのスタイルも変更できます。",
        styleContainer: "もしくは、コンポーネントのコンテナ全体をスタイルすることもできます。",
      },
    },
  },
  demoButton: {
    description:
      "ユーザーにアクションや選択を促すコンポーネントです。`Text`コンポーネントを`Pressable`コンポーネントでラップしています。",
    useCase: {
      presets: {
        name: "プリセット",
        description: "数種類のプリセットが用意されています。",
      },
      passingContent: {
        name: "コンテントを渡す",
        description: "コンテントを渡す方法はいくつかあります。",
        viaTextProps: "`text`から - Billum In",
        children: "Childrenから - Irure Reprehenderit",
        rightAccessory: "RightAccessoryから - Duis Quis",
        leftAccessory: "LeftAccessoryから - Duis Proident",
        nestedChildren: "ネストされたchildrenから - proident veniam.",
        nestedChildren2: "Ullamco cupidatat officia exercitation velit non ullamco nisi..",
        nestedChildren3: "Occaecat aliqua irure proident veniam.",
        multiLine:
          "Multilineから - consequat veniam veniam reprehenderit. Fugiat id nisi quis duis sunt proident mollit dolor mollit adipisicing proident deserunt.",
      },
      styling: {
        name: "スタイリング",
        description: "このコンポーネントはスタイリングの変更ができます。",
        styleContainer: "コンテナのスタイル - Exercitation",
        styleText: "テキストのスタイル - Ea Anim",
        styleAccessories: "アクセサリーのスタイル - enim ea id fugiat anim ad.",
        pressedState: "押された状態のスタイル - fugiat anim",
      },
      disabling: {
        name: "無効化",
        description:
          "このコンポーネントは無効化できます。スタイルも同時に変更され、押した際の挙動も無効化されます。",
        standard: "無効化 - standard",
        filled: "無効化 - filled",
        reversed: "無効化 - reversed",
        accessory: "無効化されたアクセサリーのスタイル",
        textStyle: "無効化されたテキストのスタイル",
      },
    },
  },
  demoListItem: {
    description:
      "スタイルを指定されたリストの行のコンポーネントです。FlatListやSectionListなどのコンポーネントを使用することもできますし、単体でも使用できます。",
    useCase: {
      height: {
        name: "高さ",
        description: "高さの指定ができます。",
        defaultHeight: "デフォルトの高さ (56px)",
        customHeight: "`height`を使ったカスタムの高さ",
        textHeight:
          "テキストによって決まった高さ - Reprehenderit incididunt deserunt do do ea labore.",
        longText: "テキストを1行に制限する- Reprehenderit incididunt deserunt do do ea labore.",
      },
      separators: {
        name: "セパレーター",
        description: "セパレーター/ディバイダーは用意されてるかつ任意です。",
        topSeparator: "トップセパレーターのみ",
        topAndBottomSeparator: "トップとボトムのセパレーター",
        bottomSeparator: "ボトムのセパレーター",
      },
      icons: {
        name: "アイコン",
        description: "右または左のアイコンをカスタマイズすることができます。",
        leftIcon: "左のアイコン",
        rightIcon: "右のアイコン",
        leftRightIcons: "左右のアイコン",
      },
      customLeftRight: {
        name: "左右のコンポーネントのカスタマイズ",
        description: "左右のコンポーネントをカスタマイズすることができます。",
        customLeft: "カスタムされた左コンポーネント",
        customRight: "カスタムされた右コンポーネント",
      },
      passingContent: {
        name: "コンテントを渡す",
        description: "コンテントを渡す方法はいくつかあります。",
        text: "`text`から - reprehenderit sint",
        children: "Childrenから - mostrud mollit",
        nestedChildren1: "ネストされたchildrenから - proident veniam.",
        nestedChildren2: "Ullamco cupidatat officia exercitation velit non ullamco nisi..",
      },
      listIntegration: {
        name: "FlatList に組みこむ場合",
        description:
          "このコンポーネントはお好みのリスト系のコンポーネントへ容易に組み込むことができます。",
      },
      styling: {
        name: "スタイリング",
        description: "このコンポーネントはスタイリングの変更ができます。",
        styledText: "スタイルされたテキスト",
        styledContainer: "スタイルされたコンテナ(セパレーター)",
        tintedIcons: "アイコンに色をつける",
      },
    },
  },
  demoCard: {
    description:
      "カードは関連する情報同士をまとめるのに役立ちます。ListItemが横に情報を表示するのに使え、こちらは縦に表示するのに使えます。",
    useCase: {
      presets: {
        name: "プリセット",
        description: "数種類のプリセットが用意されています。",
        default: {
          heading: "デフォルトのプリセット",
          content: "Incididunt magna ut aliquip consectetur mollit dolor.",
          footer: "Consectetur nulla non aliquip velit.",
        },
        reversed: {
          heading: "リバースのプリセット",
          content: "Reprehenderit occaecat proident amet id laboris.",
          footer: "Consectetur tempor ea non labore anim .",
        },
      },
      verticalAlignment: {
        name: "縦の位置調整",
        description: "カードは用意されたプリセットを使っての縦位置調整ができます。",
        top: {
          heading: "Top(デフォルト)",
          content: "全てのコンテンツは自動的に上に配置されます。",
          footer: "Footerも同じように上に配置されます。",
        },
        center: {
          heading: "センター",
          content: "全てのコンテンツはカードの高さから見て中央に配置されます。",
          footer: "Footerである私も!",
        },
        spaceBetween: {
          heading: "Space Between",
          content: "全てのコンテンツは均等に分配されます。",
          footer: "Footerの私はここが一番落ち着くね",
        },
        reversed: {
          heading: "Footerのみを下に配置する",
          content: "その名の通り、Footerのみを下に配置することができます。",
          footer: "Footerは一人で寂しい",
        },
      },
      passingContent: {
        name: "コンテントを渡す",
        description: "コンテントを渡す方法はいくつかあります。",
        heading: "`heading`から",
        content: "`content`から",
        footer: "`footer`から",
      },
      customComponent: {
        name: "カスタムコンポーネント",
        description:
          "全てのプリセットはカスタムコンポーネントを使って拡張/変更することができます。",
        rightComponent: "右コンポーネント",
        leftComponent: "左コンポーネント",
      },
      style: {
        name: "スタイリング",
        description: "このコンポーネントはスタイリングの変更ができます。",
        heading: "ヘディングのスタイル",
        content: "コンテントのスタイル",
        footer: "フッターのスタイル",
      },
    },
  },
  demoAutoImage: {
    description: "リモートまたはデータURIによって自動的にサイズを変更する画像コンポーネントです。",
    useCase: {
      remoteUri: { name: "リモート URI" },
      base64Uri: { name: "Base64 URI" },
      scaledToFitDimensions: {
        name: "ディメンションにフィットするように拡大する",
        description:
          "`maxWidth` と/または `maxHeight`を指定することで、アスペクト比を維持したままサイズを変更することができます。`resizeMode: 'contain'`との違いとしては: \n1. 一方のサイズの指定でも良い（両方の指定の必要がない）。 \n2. 画像のコンテナに押し込められるのではなく、画像のディメンションを保ったまま指定したサイズに拡大、縮小を行うことができます。",
        heightAuto: "width: 60 / height: auto",
        widthAuto: "width: auto / height: 32",
        bothManual: "width: 60 / height: 60",
      },
    },
  },
  demoText: {
    description:
      "テキストを表示する為のコンポーネントです。これはReact NativeのTextコンポーネントを内包する高階コンポーネント(Higher Order Component)です。",
    useCase: {
      presets: {
        name: "プリセット",
        description: "数種類のプリセットが用意されています。",
        default:
          "デフォルトのプリセット - Cillum eu laboris in labore. Excepteur mollit tempor reprehenderit fugiat elit et eu consequat laborum.",
        bold: "ボールドのプリセット - Tempor et ullamco cupidatat in officia. Nulla ea duis elit id sunt ipsum cillum duis deserunt nostrud ut nostrud id.",
        subheading: "サブヘディングのプリセット - In Cupidatat Cillum.",
        heading: "ヘディングのプリセット - Voluptate Adipis.",
      },
      sizes: {
        name: "サイズ",
        description: "サイズ用のpropsです.",
        xs: "xs - Ea ipsum est ea ex sunt.",
        sm: "sm - Lorem sunt adipisicin.",
        md: "md - Consequat id do lorem.",
        lg: "lg - Nostrud ipsum ea.",
        xl: "xl - Eiusmod ex excepteur.",
        xxl: "xxl - Cillum eu laboris.",
      },
      weights: {
        name: "ウエイト",
        description: "ウエイト用のpropです。",
        light:
          "ライト - Nulla magna incididunt excepteur est occaecat duis culpa dolore cupidatat enim et.",
        normal:
          "ノーマル - Magna incididunt dolor ut veniam veniam laboris aliqua velit ea incididunt.",
        medium: "ミディアム - Non duis laborum quis laboris occaecat culpa cillum.",
        semibold: "セミボールド - Exercitation magna nostrud pariatur laborum occaecat aliqua.",
        bold: "ボールド - Eiusmod ullamco magna exercitation est excepteur.",
      },
      passingContent: {
        name: "コンテントを渡す",
        description: "コンテントを渡す方法はいくつかあります。",
        viaText:
          "`text`から - Billum in aute fugiat proident nisi pariatur est. Cupidatat anim cillum eiusmod ad. Officia eu magna aliquip labore dolore consequat.",
        viaTx: "`tx`から -",
        children: "childrenから - Aliqua velit irure reprehenderit eu qui amet veniam consectetur.",
        nestedChildren: "ネストされたchildrenから -",
        nestedChildren2: "Occaecat aliqua irure proident veniam.",
        nestedChildren3: "Ullamco cupidatat officia exercitation velit non ullamco nisi..",
        nestedChildren4: "Occaecat aliqua irure proident veniam.",
      },
      styling: {
        name: "スタイリング",
        description: "このコンポーネントはスタイリングの変更ができます。",
        text: "Consequat ullamco veniam velit mollit proident excepteur aliquip id culpa ipsum velit sint nostrud.",
        text2:
          "Eiusmod occaecat laboris eu ex veniam ipsum adipisicing consectetur. Magna ullamco adipisicing tempor adipisicing.",
        text3:
          "Eiusmod occaecat laboris eu ex veniam ipsum adipisicing consectetur. Magna ullamco adipisicing tempor adipisicing.",
      },
    },
  },
  demoHeader: {
    description:
      "様々なスクリーンで登場するコンポーネントです。ナビゲーションのボタンとスクリーンタイトルを含みます。",
    useCase: {
      actionIcons: {
        name: "アクションアイコン",
        description: "左右にアイコンを表示させることができます。",
        leftIconTitle: "左アイコン",
        rightIconTitle: "右アイコン",
        bothIconsTitle: "両方のアイコン",
      },
      actionText: {
        name: "アクションテキスト",
        description: "左右にテキストを表示させることができます。",
        leftTxTitle: "`leftTx`から",
        rightTextTitle: "`rightText`から",
      },
      customActionComponents: {
        name: "カスタムアクションコンポーネント",
        description:
          "アイコンまたはテキスト以外のものが必要な場合は、カスタムのアクションコンポーネントを渡すことができます。",
        customLeftActionTitle: "カスタムの左アクション",
      },
      titleModes: {
        name: "タイトルモード",
        description:
          "タイトルはデフォルトで中央に配置されますが、長すぎるとカットされてしまいます。Flexを使うことでアクションボタンから自動的にポジションを調整することもできます。",
        centeredTitle: "Centered Title",
        flexTitle: "Flex Title",
      },
      styling: {
        name: "スタイリング",
        description: "このコンポーネントはスタイリングの変更ができます。",
        styledTitle: "スタイルされたタイトル",
        styledWrapperTitle: "スタイルされたラッパー",
        tintedIconsTitle: "色付けされたアイコン",
      },
    },
  },
  demoEmptyState: {
    description:
      "表示する為のデータが存在しない場合に使えるコンポーネントです。ユーザーに取るべきアクションをお勧めする際に有用です。",
    useCase: {
      presets: {
        name: "プリセット",
        description:
          "text/imageのセットを使ってカスタマイズすることができます。これは`generic`のものです。カスタマイズが必要になることを想定して、このコンポーネントにデフォルトのプリセットは存在しません。",
      },
      passingContent: {
        name: "コンテントを渡す",
        description: "コンテントを渡す方法はいくつかあります。",
        customizeImageHeading: "画像をカスタマイズ",
        customizeImageContent: "画像のソースを渡すことができます。",
        viaHeadingProp: "`heading`から",
        viaContentProp: "`content`から",
        viaButtonProp: "`button`から",
      },
      styling: {
        name: "スタイリング",
        description: "このコンポーネントはスタイリングの変更ができます。",
      },
    },
  },
}

export default demoJa

// @demo remove-file
===== END FILE: app/i18n/demo-ja.ts =====


===== BEGIN FILE: app/i18n/ar.ts =====
import demoAr from "./demo-ar" // @demo remove-current-line
import { Translations } from "./en"

const ar: Translations = {
  common: {
    ok: "نعم",
    cancel: "حذف",
    back: "خلف",
    logOut: "تسجيل خروج", // @demo remove-current-line
  },
  welcomeScreen: {
    postscript:
      "ربما لا يكون هذا هو الشكل الذي يبدو عليه تطبيقك مالم يمنحك المصمم هذه الشاشات وشحنها في هذه الحالة",
    readyForLaunch: "تطبيقك تقريبا جاهز للتشغيل",
    exciting: "اوه هذا مثير",
    letsGo: "لنذهب", // @demo remove-current-line
  },
  errorScreen: {
    title: "هناك خطأ ما",
    friendlySubtitle:
      "هذه هي الشاشة التي سيشاهدها المستخدمون في عملية الانتاج عند حدوث خطأ. سترغب في تخصيص هذه الرسالة ( الموجودة في 'ts.en/i18n/app') وربما التخطيط ايضاً ('app/screens/ErrorScreen'). إذا كنت تريد إزالة هذا بالكامل، تحقق من 'app/app.tsp' من اجل عنصر <ErrorBoundary>.",
    reset: "اعادة تعيين التطبيق",
    traceTitle: "خطأ من مجموعة %{name}", // @demo remove-current-line
  },
  emptyStateComponent: {
    generic: {
      heading: "فارغة جداً....حزين",
      content: "لا توجد بيانات حتى الآن. حاول النقر فوق الزر لتحديث التطبيق او اعادة تحميله.",
      button: "لنحاول هذا مرّة أخرى",
    },
  },
  // @demo remove-block-start
  errors: {
    invalidEmail: "عنوان البريد الالكتروني غير صالح",
  },
  loginScreen: {
    logIn: "تسجيل الدخول",
    enterDetails:
      ".ادخل التفاصيل الخاصة بك ادناه لفتح معلومات سرية للغاية. لن تخمن ابداً ما الذي ننتظره. او ربما ستفعل انها انها ليست علم الصواريخ",
    emailFieldLabel: "البريد الالكتروني",
    passwordFieldLabel: "كلمة السر",
    emailFieldPlaceholder: "ادخل بريدك الالكتروني",
    passwordFieldPlaceholder: "كلمة السر هنا فائقة السر",
    tapToLogIn: "انقر لتسجيل الدخول!",
    hint: "(: تلميح: يمكنك استخدام اي عنوان بريد الكتروني وكلمة السر المفضلة لديك",
  },
  demoNavigator: {
    componentsTab: "عناصر",
    debugTab: "تصحيح",
    communityTab: "واصل اجتماعي",
    podcastListTab: "البودكاست",
  },
  demoCommunityScreen: {
    title: "تواصل مع المجتمع",
    tagLine:
      "قم بالتوصيل لمنتدى Infinite Red الذي يضم تفاعل المهندسين المحلّيين ورفع مستوى تطوير تطبيقك معنا",
    joinUsOnSlackTitle: "انضم الينا على Slack",
    joinUsOnSlack:
      "هل ترغب في وجود مكان للتواصل مع مهندسي React Native حول العالم؟ الانضمام الى المحادثة في سلاك المجتمع الاحمر اللانهائي! مجتمعناالمتنامي هو مساحةآمنة لطرح الاسئلة والتعلم من الآخرين وتنمية شبكتك.",
    joinSlackLink: "انضم الي مجتمع Slack",
    makeIgniteEvenBetterTitle: "اجعل Ignite افضل",
    makeIgniteEvenBetter:
      "هل لديك فكرة لجعل Ignite افضل؟ نحن سعداء لسماع ذلك! نحن نبحث دائماً عن الآخرين الذين يرغبون في مساعدتنا في بناء افضل الادوات المحلية التفاعلية المتوفرة هناك. انضم الينا عبر GitHub للانضمام الينا في بناء مستقبل Ignite",
    contributeToIgniteLink: "ساهم في Ignite",
    theLatestInReactNativeTitle: "الاحدث في React Native",
    theLatestInReactNative: "نخن هنا لنبقيك محدثاً على جميع React Native التي تعرضها",
    reactNativeRadioLink: "راديو React Native",
    reactNativeNewsletterLink: "نشرة اخبار React Native",
    reactNativeLiveLink: "مباشر React Native",
    chainReactConferenceLink: "مؤتمر Chain React",
    hireUsTitle: "قم بتوظيف Infinite Red لمشروعك القادم",
    hireUs:
      "سواء كان الامر يتعلّق بتشغيل مشروع كامل او اعداد الفرق بسرعة من خلال التدريب العلمي لدينا، يمكن ان يساعد Infinite Red اللامتناهي في اي مشروع محلي يتفاعل معه.",
    hireUsLink: "ارسل لنا رسالة",
  },
  demoShowroomScreen: {
    jumpStart: "مكونات او عناصر لبدء مشروعك",
    lorem2Sentences:
      "عامل الناس بأخلاقك لا بأخلاقهم. عامل الناس بأخلاقك لا بأخلاقهم. عامل الناس بأخلاقك لا بأخلاقهم",
    demoHeaderTxExample: "ياي",
    demoViaTxProp: "عبر `tx` Prop",
    demoViaSpecifiedTxProp: "Prop `{{prop}}Tx` عبر",
  },
  demoDebugScreen: {
    howTo: "كيف",
    title: "التصحيح",
    tagLine: "مبروك، لديك نموذج اصلي متقدم للغاية للتفاعل هنا. الاستفادة من هذه النمذجة",
    reactotron: "Reactotron ارسل إلى",
    reportBugs: "الابلاغ عن اخطاء",
    demoList: "قائمة تجريبية",
    demoPodcastList: "قائمة البودكاست التجريبي",
    androidReactotronHint:
      "اذا لم ينجح ذللك، فتأكد من تشغيل تطبيق الحاسوب الخاص Reactotron، وقم بتشغيل عكس adb tcp:9090 \ntcp:9090 من جهازك الطرفي ، واعد تحميل التطبيق",
    iosReactotronHint:
      "اذا لم ينجح ذلك، فتأكد من تشغيل تطبيق الحاسوب الخاص ب Reactotron وأعد تحميل التطبيق",
    macosReactotronHint: "اذا لم ينجح ذلك، فتأكد من تشغيل الحاسوب ب Reactotron وأعد تحميل التطبيق",
    webReactotronHint: "اذا لم ينجح ذلك، فتأكد من تشغيل الحاسوب ب Reactotron وأعد تحميل التطبيق",
    windowsReactotronHint:
      "اذا لم ينجح ذلك، فتأكد من تشغيل الحاسوب ب Reactotron وأعد تحميل التطبيق",
  },
  demoPodcastListScreen: {
    title: "حلقات إذاعية React Native",
    onlyFavorites: "المفضلة فقط",
    favoriteButton: "المفضل",
    unfavoriteButton: "غير مفضل",
    accessibility: {
      cardHint: "انقر مرّتين للاستماع على الحلقة. انقر مرّتين وانتظر لتفعيل {{action}} هذه الحلقة.",
      switch: "قم بالتبديل لاظهار المفضّلة فقط.",
      favoriteAction: "تبديل المفضلة",
      favoriteIcon: "الحلقة الغير مفضّلة",
      unfavoriteIcon: "الحلقة المفضّلة",
      publishLabel: "نشرت {{date}}",
      durationLabel: "المدّة: {{hours}} ساعات {{minutes}} دقائق {{seconds}} ثواني",
    },
    noFavoritesEmptyState: {
      heading: "هذا يبدو فارغاً بعض الشيء.",
      content:
        "لم تتم اضافة اي مفضلات حتى الان. اضغط على القلب في إحدى الحلقات لإضافته الى المفضلة.",
    },
  },
  // @demo remove-block-start
  ...demoAr,
  // @demo remove-block-end
}

export default ar
===== END FILE: app/i18n/ar.ts =====


===== BEGIN FILE: app/i18n/es.ts =====
import demoEs from "./demo-es" // @demo remove-current-line
import { Translations } from "./en"

const es: Translations = {
  common: {
    ok: "OK",
    cancel: "Cancelar",
    back: "Volver",
    logOut: "Cerrar sesión", // @demo remove-current-line
  },
  welcomeScreen: {
    postscript:
      "psst — Esto probablemente no es cómo se va a ver tu app. (A menos que tu diseñador te haya enviado estas pantallas, y en ese caso, ¡lánzalas en producción!)",
    readyForLaunch: "Tu app, casi lista para su lanzamiento",
    exciting: "(¡ohh, esto es emocionante!)",
    letsGo: "¡Vamos!", // @demo remove-current-line
  },
  errorScreen: {
    title: "¡Algo salió mal!",
    friendlySubtitle:
      "Esta es la pantalla que verán tus usuarios en producción cuando haya un error. Vas a querer personalizar este mensaje (que está ubicado en `app/i18n/es.ts`) y probablemente también su diseño (`app/screens/ErrorScreen`). Si quieres eliminarlo completamente, revisa `app/app.tsx` y el componente <ErrorBoundary>.",
    reset: "REINICIA LA APP",
    traceTitle: "Error desde %{name}", // @demo remove-current-line
  },
  emptyStateComponent: {
    generic: {
      heading: "Muy vacío... muy triste",
      content:
        "No se han encontrado datos por el momento. Intenta darle clic en el botón para refrescar o recargar la app.",
      button: "Intentemos de nuevo",
    },
  },
  // @demo remove-block-start
  errors: {
    invalidEmail: "Email inválido.",
  },
  loginScreen: {
    logIn: "Iniciar sesión",
    enterDetails:
      "Ingresa tus datos a continuación para desbloquear información ultra secreta. Nunca vas a adivinar lo que te espera al otro lado. O quizás si lo harás; la verdad no hay mucha ciencia alrededor.",
    emailFieldLabel: "Email",
    passwordFieldLabel: "Contraseña",
    emailFieldPlaceholder: "Ingresa tu email",
    passwordFieldPlaceholder: "Contraseña super secreta aquí",
    tapToLogIn: "¡Presiona acá para iniciar sesión!",
    hint: "Consejo: puedes usar cualquier email y tu contraseña preferida :)",
  },
  demoNavigator: {
    componentsTab: "Componentes",
    debugTab: "Debug",
    communityTab: "Comunidad",
    podcastListTab: "Podcasts",
  },
  demoCommunityScreen: {
    title: "Conecta con la comunidad",
    tagLine:
      "Únete a la comunidad React Native con los ingenieros de Infinite Red y mejora con nosotros tus habilidades para el desarrollo de apps.",
    joinUsOnSlackTitle: "Únete a nosotros en Slack",
    joinUsOnSlack:
      "¿Quieres conectar con desarrolladores de React Native de todo el mundo? Únete a la conversación en nuestra comunidad de Slack. Nuestra comunidad, que crece día a día, es un espacio seguro para hacer preguntas, aprender de los demás y ampliar tu red.",
    joinSlackLink: "Únete a la comunidad de Slack",
    makeIgniteEvenBetterTitle: "Haz que Ignite sea aún mejor",
    makeIgniteEvenBetter:
      "¿Tienes una idea para hacer que Ignite sea aún mejor? ¡Nos encantaría escucharla! Estamos siempre buscando personas que quieran ayudarnos a construir las mejores herramientas para React Native. Únete a nosotros en GitHub para ayudarnos a construir el futuro de Ignite.",
    contributeToIgniteLink: "Contribuir a Ignite",
    theLatestInReactNativeTitle: "Lo último en el mundo de React Native",
    theLatestInReactNative:
      "Estamos aquí para mantenerte al día con todo lo que React Native tiene para ofrecer.",
    reactNativeRadioLink: "React Native Radio",
    reactNativeNewsletterLink: "Newsletter de React Native",
    reactNativeLiveLink: "React Native Live",
    chainReactConferenceLink: "Conferencia Chain React",
    hireUsTitle: "Trabaja con Infinite Red en tu próximo proyecto",
    hireUs:
      "Ya sea para gestionar un proyecto de inicio a fin o educación a equipos a través de nuestros cursos y capacitación práctica, Infinite Red puede ayudarte en casi cualquier proyecto de React Native.",
    hireUsLink: "Envíanos un mensaje",
  },
  demoShowroomScreen: {
    jumpStart: "Componentes para comenzar tu proyecto",
    lorem2Sentences:
      "Nulla cupidatat deserunt amet quis aliquip nostrud do adipisicing. Adipisicing excepteur elit laborum Lorem adipisicing do duis.",
    demoHeaderTxExample: "Yay",
    demoViaTxProp: "A través de el atributo `tx`",
    demoViaSpecifiedTxProp: "A través de el atributo específico `{{prop}}Tx`",
  },
  demoDebugScreen: {
    howTo: "CÓMO HACERLO",
    title: "Debug",
    tagLine:
      "Felicidades, aquí tienes una propuesta de arquitectura y base de código avanzada para una app en React Native. ¡Disfrutalos!",
    reactotron: "Enviar a Reactotron",
    reportBugs: "Reportar errores",
    demoList: "Lista demo",
    demoPodcastList: "Lista demo de podcasts",
    androidReactotronHint:
      "Si esto no funciona, asegúrate de que la app de escritorio de Reactotron se esté ejecutando, corre adb reverse tcp:9090 tcp:9090 desde tu terminal, y luego recarga la app.",
    iosReactotronHint:
      "Si esto no funciona, asegúrate de que la app de escritorio de Reactotron se esté ejecutando, y luego recarga la app.",
    macosReactotronHint:
      "Si esto no funciona, asegúrate de que la app de escritorio de Reactotron se esté ejecutando, y luego recarga la app.",
    webReactotronHint:
      "Si esto no funciona, asegúrate de que la app de escritorio de Reactotron se esté ejecutando, y luego recarga la app.",
    windowsReactotronHint:
      "Si esto no funciona, asegúrate de que la app de escritorio de Reactotron se esté ejecutando, y luego recarga la app.",
  },
  demoPodcastListScreen: {
    title: "Episodios de React Native Radio",
    onlyFavorites: "Mostrar solo favoritos",
    favoriteButton: "Favorito",
    unfavoriteButton: "No favorito",
    accessibility: {
      cardHint:
        "Haz doble clic para escuchar el episodio. Haz doble clic y mantén presionado para {{action}} este episodio.",
      switch: "Activa para mostrar solo favoritos",
      favoriteAction: "Cambiar a favorito",
      favoriteIcon: "Episodio no favorito",
      unfavoriteIcon: "Episodio favorito",
      publishLabel: "Publicado el {{date}}",
      durationLabel: "Duración: {{hours}} horas {{minutes}} minutos {{seconds}} segundos",
    },
    noFavoritesEmptyState: {
      heading: "Esto está un poco vacío",
      content:
        "No se han agregado episodios favoritos todavía. ¡Presiona el corazón dentro de un episodio para agregarlo a tus favoritos!",
    },
  },
  // @demo remove-block-start
  ...demoEs,
  // @demo remove-block-end
}

export default es
===== END FILE: app/i18n/es.ts =====


===== BEGIN FILE: app/i18n/en.ts =====
import demoEn from "./demo-en" // @demo remove-current-line

const en = {
  oolshik: {
    nearbyTasks: "Nearby Tasks",
    create: "Create",
    appName: "Oolshik",
    home: "Home",
    feed: "Nearby Tasks",
    createTask: "Create Task",
    taskDetail: "Task Detail",
    myTasks: "My Tasks",
    chat: "Chat",
    profile: "Profile",
    report: "Report",
    radius: "Radius (km)",
    radius1: "1 km",
    radius2: "2 km",
    radius5: "5 km",
    descriptionOptional: "Short description (optional)",
    recordAudio: "Record Audio (≤ 30s)",
    stop: "Stop",
    play: "Play",
    submitTask: "Post Task",
    locationPermissionTitle: "Location Permission",
    locationPermissionMsg: "We only need foreground location permission to show nearby tasks.",
    allow: "Allow",
    language: "Language",
    marathi: "Marathi",
    english: "English",
    consentTitle: "Terms & Location Usage",
    consentAgree: "I Agree",
    rating: "Rating",
    completeTask: "Mark as Complete",
    acceptTask: "Accept",
    alreadyAssigned: "Already Assigned",
    distanceAway: "{{km}} km away",
    emptyNearby: "No nearby tasks yet — try a larger radius.",
    nearbyForYouHeader: "Nearby for You",
    myRequestsHeader: "My Requests",
    tabForYou: "For You",
    tabMyRequests: "My Requests",
    emptyForYou: "No nearby requests right now.",
    emptyMine: "You haven't created any requests yet.",
    distanceFilter: "Distance",
    statusFilter: "Status",
    yourExperience: "Your Experience",
    leftRightExperience: "(Left: Bad • Right: Great)",
    ratingBad: "Bad",
    ratingPoor: "Poor",
    ratingOkay: "Okay",
    ratingGood: "Good",
    ratingGreat: "Great",
  },
  common: {
    ok: "OK!",
    cancel: "Cancel",
    back: "Back",
    logOut: "Log Out", // @demo remove-current-line
  },
  welcomeScreen: {
    postscript:
      "psst  — This probably isn't what your app looks like. (Unless your designer handed you these screens, and in that case, ship it!)",
    readyForLaunch: "Your app, almost ready for launch!",
    exciting: "(ohh, this is exciting!)",
    letsGo: "Let's go!", // @demo remove-current-line
  },
  errorScreen: {
    title: "Something went wrong!",
    friendlySubtitle:
      "This is the screen that your users will see in production when an error is thrown. You'll want to customize this message (located in `app/i18n/en.ts`) and probably the layout as well (`app/screens/ErrorScreen`). If you want to remove this entirely, check `app/app.tsx` for the <ErrorBoundary> component.",
    reset: "RESET APP",
    traceTitle: "Error from %{name} stack", // @demo remove-current-line
  },
  emptyStateComponent: {
    generic: {
      heading: "So empty... so sad",
      content: "No data found yet. Try clicking the button to refresh or reload the app.",
      button: "Let's try this again",
    },
  },
  // @demo remove-block-start
  errors: {
    invalidEmail: "Invalid email address.",
  },
  loginScreen: {
    logIn: "Log In",
    enterDetails:
      "Enter your details below to unlock top secret info. You'll never guess what we've got waiting. Or maybe you will; it's not rocket science here.",
    emailFieldLabel: "Email",
    passwordFieldLabel: "Password",
    emailFieldPlaceholder: "Enter your email address",
    passwordFieldPlaceholder: "Super secret password here",
    tapToLogIn: "Tap to log in!",
    hint: "Hint: you can use any email address and your favorite password :)",
  },
  demoNavigator: {
    componentsTab: "Components",
    debugTab: "Debug",
    communityTab: "Community",
    podcastListTab: "Podcast",
  },
  demoCommunityScreen: {
    title: "Connect with the community",
    tagLine:
      "Plug in to Infinite Red's community of React Native engineers and level up your app development with us!",
    joinUsOnSlackTitle: "Join us on Slack",
    joinUsOnSlack:
      "Wish there was a place to connect with React Native engineers around the world? Join the conversation in the Infinite Red Community Slack! Our growing community is a safe space to ask questions, learn from others, and grow your network.",
    joinSlackLink: "Join the Slack Community",
    makeIgniteEvenBetterTitle: "Make Ignite even better",
    makeIgniteEvenBetter:
      "Have an idea to make Ignite even better? We're happy to hear that! We're always looking for others who want to help us build the best React Native tooling out there. Join us over on GitHub to join us in building the future of Ignite.",
    contributeToIgniteLink: "Contribute to Ignite",
    theLatestInReactNativeTitle: "The latest in React Native",
    theLatestInReactNative: "We're here to keep you current on all React Native has to offer.",
    reactNativeRadioLink: "React Native Radio",
    reactNativeNewsletterLink: "React Native Newsletter",
    reactNativeLiveLink: "React Native Live",
    chainReactConferenceLink: "Chain React Conference",
    hireUsTitle: "Hire Infinite Red for your next project",
    hireUs:
      "Whether it's running a full project or getting teams up to speed with our hands-on training, Infinite Red can help with just about any React Native project.",
    hireUsLink: "Send us a message",
  },
  demoShowroomScreen: {
    jumpStart: "Components to jump start your project!",
    lorem2Sentences:
      "Nulla cupidatat deserunt amet quis aliquip nostrud do adipisicing. Adipisicing excepteur elit laborum Lorem adipisicing do duis.",
    demoHeaderTxExample: "Yay",
    demoViaTxProp: "Via `tx` Prop",
    demoViaSpecifiedTxProp: "Via `{{prop}}Tx` Prop",
  },
  demoDebugScreen: {
    howTo: "HOW TO",
    title: "Debug",
    tagLine:
      "Congratulations, you've got a very advanced React Native app template here.  Take advantage of this boilerplate!",
    reactotron: "Send to Reactotron",
    reportBugs: "Report Bugs",
    demoList: "Demo List",
    demoPodcastList: "Demo Podcast List",
    androidReactotronHint:
      "If this doesn't work, ensure the Reactotron desktop app is running, run adb reverse tcp:9090 tcp:9090 from your terminal, and reload the app.",
    iosReactotronHint:
      "If this doesn't work, ensure the Reactotron desktop app is running and reload app.",
    macosReactotronHint:
      "If this doesn't work, ensure the Reactotron desktop app is running and reload app.",
    webReactotronHint:
      "If this doesn't work, ensure the Reactotron desktop app is running and reload app.",
    windowsReactotronHint:
      "If this doesn't work, ensure the Reactotron desktop app is running and reload app.",
  },
  demoPodcastListScreen: {
    title: "React Native Radio episodes",
    onlyFavorites: "Only Show Favorites",
    favoriteButton: "Favorite",
    unfavoriteButton: "Unfavorite",
    accessibility: {
      cardHint:
        "Double tap to listen to the episode. Double tap and hold to {{action}} this episode.",
      switch: "Switch on to only show favorites",
      favoriteAction: "Toggle Favorite",
      favoriteIcon: "Episode not favorited",
      unfavoriteIcon: "Episode favorited",
      publishLabel: "Published {{date}}",
      durationLabel: "Duration: {{hours}} hours {{minutes}} minutes {{seconds}} seconds",
    },
    noFavoritesEmptyState: {
      heading: "This looks a bit empty",
      content:
        "No favorites have been added yet. Tap the heart on an episode to add it to your favorites!",
    },
  },
  // @demo remove-block-start
  ...demoEn,
  // @demo remove-block-end
}

export default en
export type Translations = typeof en
===== END FILE: app/i18n/en.ts =====


===== BEGIN FILE: app/i18n/demo-ko.ts =====
import { DemoTranslations } from "./demo-en"

export const demoKo: DemoTranslations = {
  demoIcon: {
    description:
      "등록된 아이콘을 렌더링하는 컴포넌트입니다. `onPress`가 구현되어 있으면 <TouchableOpacity />로, 그렇지 않으면 <View />로 감쌉니다.",
    useCase: {
      icons: {
        name: "아이콘",
        description: "컴포넌트에 등록된 아이콘 목록입니다.",
      },
      size: {
        name: "크기",
        description: "크기 속성이 있습니다.",
      },
      color: {
        name: "색상",
        description: "색상 속성이 있습니다.",
      },
      styling: {
        name: "스타일링",
        description: "컴포넌트는 쉽게 스타일링할 수 있습니다.",
      },
    },
  },
  demoTextField: {
    description: "TextField 컴포넌트는 텍스트 입력 및 편집을 허용합니다.",
    useCase: {
      statuses: {
        name: "상태",
        description:
          "다른 컴포넌트의 `preset`과 유사한 상태 속성이 있으며, 컴포넌트의 기능에도 영향을 미칩니다.",
        noStatus: {
          label: "상태 없음",
          helper: "이것이 기본 상태입니다",
          placeholder: "텍스트가 여기에 들어갑니다",
        },
        error: {
          label: "오류 상태",
          helper: "오류가 있을 때 사용하는 상태입니다",
          placeholder: "텍스트가 여기에 들어갑니다",
        },
        disabled: {
          label: "비활성 상태",
          helper: "편집 기능을 비활성화하고 텍스트를 표시하지 않습니다",
          placeholder: "텍스트가 여기에 들어갑니다",
        },
      },
      passingContent: {
        name: "내용 전달",
        description: "내용을 전달하는 몇 가지 방법이 있습니다.",
        viaLabel: {
          labelTx: "`label` 속성으로",
          helper: "`helper` 속성으로",
          placeholder: "`placeholder` 속성으로",
        },
        rightAccessory: {
          label: "오른쪽 액세서리",
          helper: "이 속성은 React 요소를 반환하는 함수를 받습니다.",
        },
        leftAccessory: {
          label: "왼쪽 액세서리",
          helper: "이 속성은 React 요소를 반환하는 함수를 받습니다.",
        },
        supportsMultiline: {
          label: "멀티라인 지원",
          helper: "멀티라인 텍스트를 위한 더 높은 입력을 활성화합니다.",
        },
      },
      styling: {
        name: "스타일링",
        description: "컴포넌트는 쉽게 스타일링할 수 있습니다.",
        styleInput: {
          label: "입력 스타일",
          helper: "`style` 속성으로",
        },
        styleInputWrapper: {
          label: "입력 래퍼 스타일",
          helper: "`inputWrapperStyle` 속성으로",
        },
        styleContainer: {
          label: "컨테이너 스타일",
          helper: "`containerStyle` 속성으로",
        },
        styleLabel: {
          label: "레이블 및 헬퍼 스타일",
          helper: "`LabelTextProps` 및 `HelperTextProps` 스타일 속성으로",
        },
        styleAccessories: {
          label: "액세서리 스타일",
          helper: "`RightAccessory` 및 `LeftAccessory` 스타일 속성으로",
        },
      },
    },
  },
  demoToggle: {
    description:
      "불리언 입력을 렌더링합니다. 사용자가 수행한 작업을 반영하기 위해 값 속성을 업데이트하는 onValueChange 콜백이 필요한 제어된 컴포넌트입니다. 값 속성이 업데이트되지 않으면, 컴포넌트는 사용자 작업의 예상 결과 대신 제공된 값 속성을 계속 렌더링합니다.",
    useCase: {
      variants: {
        name: "변형",
        description:
          "이 컴포넌트는 몇 가지 변형을 지원합니다. 특정 변형을 대폭 커스터마이즈해야 하는 경우에는 쉽게 리팩토링할 수 있습니다. 기본값은 `체크박스`입니다.",
        checkbox: {
          label: "`체크박스` 변형",
          helper: "단일 켜기/끄기 입력에 사용할 수 있습니다.",
        },
        radio: {
          label: "`라디오` 변형",
          helper: "여러 옵션이 있는 경우 사용하십시오.",
        },
        switch: {
          label: "`스위치` 변형",
          helper: "더 눈에 띄는 켜기/끄기 입력입니다. 접근성 지원이 더 좋습니다.",
        },
      },
      statuses: {
        name: "상태",
        description:
          "다른 컴포넌트의 `preset`과 유사한 상태 속성이 있으며, 컴포넌트의 기능에도 영향을 미칩니다.",
        noStatus: "상태 없음 - 기본 상태",
        errorStatus: "오류 상태 - 오류가 있을 때 사용",
        disabledStatus: "비활성 상태 - 편집 기능을 비활성화하고 입력을 표시하지 않음",
      },
      passingContent: {
        name: "내용 전달",
        description: "내용을 전달하는 몇 가지 방법이 있습니다.",
        useCase: {
          checkBox: {
            label: "`labelTx` 속성으로",
            helper: "`helperTx` 속성으로",
          },
          checkBoxMultiLine: {
            helper: "멀티라인 지원 - 멀티라인 지원을 위한 예제 문장입니다. 하나 둘 셋.",
          },
          radioChangeSides: {
            helper: "양쪽을 변경할 수 있습니다 - 양쪽 변경을 위한 예제 문장입니다. 하나 둘 셋.",
          },
          customCheckBox: {
            label: "맞춤 체크박스 아이콘 전달.",
          },
          switch: {
            label: "스위치는 텍스트로 읽을 수 있습니다",
            helper:
              "기본적으로 이 옵션은 `Text`를 사용하지 않습니다. 폰트에 따라 켜기/끄기 문자가 이상하게 보일 수 있기 때문입니다. 필요에 따라 커스터마이즈하세요.",
          },
          switchAid: {
            label: "또는 아이콘으로 보조",
          },
        },
      },
      styling: {
        name: "스타일링",
        description: "컴포넌트는 쉽게 스타일링할 수 있습니다.",
        outerWrapper: "1 - 입력 외부 래퍼 스타일링",
        innerWrapper: "2 - 입력 내부 래퍼 스타일링",
        inputDetail: "3 - 입력 디테일 스타일링",
        labelTx: "labelTx도 스타일링할 수 있습니다",
        styleContainer: "또는 전체 컨테이너 스타일링",
      },
    },
  },
  demoButton: {
    description:
      "사용자가 작업을 수행하고 선택을 할 수 있도록 하는 컴포넌트입니다. Text 컴포넌트를 Pressable 컴포넌트로 감쌉니다.",
    useCase: {
      presets: {
        name: "프리셋",
        description: "사전 구성된 몇 가지 프리셋이 있습니다.",
      },
      passingContent: {
        name: "내용 전달",
        description: "내용을 전달하는 몇 가지 방법이 있습니다.",
        viaTextProps: "`text` 속성으로 - 예제 문장입니다.",
        children: "자식 - 또 다른 예제 문장입니다.",
        rightAccessory: "오른쪽 액세서리 - 예제 문장입니다.",
        leftAccessory: "왼쪽 액세서리 - 예제 문장입니다.",
        nestedChildren: "중첩 자식 - 별 하나에 추억과 별 하나에 사랑과 별 하나에 쓸쓸함과",
        nestedChildren2: "별 하나에 동경과 별 하나에 시와 ",
        nestedChildren3: "별 하나에 어머니, 어머니.",
        multiLine:
          "멀티라인 - 죽는 날까지 하늘을 우러러 한 점 부끄럼이 없기를, 잎새에 이는 바람에도 나는 괴로워했다. 별을 노래하는 마음으로 모든 죽어 가는 것을 사랑해야지 그리고 나한테 주어진 길을 걸어가야겠다. 오늘 밤에도 별이 바람에 스치운다.",
      },
      styling: {
        name: "스타일링",
        description: "컴포넌트는 쉽게 스타일링할 수 있습니다.",
        styleContainer: "스타일 컨테이너 - 예제 문장",
        styleText: "스타일 텍스트 - 예제 문장",
        styleAccessories: "스타일 액세서리 - 또 다른 예제 문장",
        pressedState: "스타일 눌린 상태 - 예제 문장",
      },
      disabling: {
        name: "비활성화",
        description:
          "컴포넌트는 비활성화할 수 있으며, 그에 따라 스타일링할 수 있습니다. 누르는 동작이 비활성화됩니다.",
        standard: "비활성화 - 표준",
        filled: "비활성화 - 채워진",
        reversed: "비활성화 - 역방향",
        accessory: "비활성화된 액세서리 스타일",
        textStyle: "비활성화된 텍스트 스타일",
      },
    },
  },
  demoListItem: {
    description: "FlatList, SectionList 또는 자체적으로 사용할 수 있는 스타일된 행 컴포넌트입니다.",
    useCase: {
      height: {
        name: "높이",
        description: "행은 다른 높이를 가질 수 있습니다.",
        defaultHeight: "기본 높이 (56px)",
        customHeight: "`height` 속성을 통해 사용자 정의 높이",
        textHeight:
          "텍스트 내용에 의해 결정된 높이 - 예제를 위한 긴 문장입니다. 하나 둘 셋. 안녕하세요.",
        longText:
          "긴 텍스트를 한 줄로 제한 - 이것 역시 예제를 위한 긴 문장입니다. 오늘 날씨는 어떤가요?",
      },
      separators: {
        name: "구분선",
        description: "구분선 / 디바이더가 사전 구성되어 있으며 선택 사항입니다.",
        topSeparator: "상단 구분선만",
        topAndBottomSeparator: "상단 및 하단 구분선",
        bottomSeparator: "하단 구분선만",
      },
      icons: {
        name: "아이콘",
        description: "왼쪽 또는 오른쪽 아이콘을 사용자 정의할 수 있습니다.",
        leftIcon: "왼쪽 아이콘",
        rightIcon: "오른쪽 아이콘",
        leftRightIcons: "왼쪽 및 오른쪽 아이콘",
      },
      customLeftRight: {
        name: "사용자 정의 왼쪽/오른쪽 컴포넌트",
        description: "필요시에는 사용자가 정의한 왼쪽/오른쪽 컴포넌트를 전달할 수 있습니다.",
        customLeft: "사용자 정의 왼쪽 컴포넌트",
        customRight: "사용자 정의 오른쪽 컴포넌트",
      },
      passingContent: {
        name: "내용 전달",
        description: "내용을 전달하는 몇 가지 방법이 있습니다.",
        text: "`text` 속성으로 - 예제 문장입니다.",
        children: "자식 - 또 다른 예제 문장입니다.",
        nestedChildren1: "중첩 자식 - 이것도 예제 문장입니다..",
        nestedChildren2: "또 다른 예제 문장, 중첩이 된 형태입니다.",
      },
      listIntegration: {
        name: "FlatList 통합",
        description: "이 컴포넌트는 선호하는 리스트 인터페이스와 쉽게 통합할 수 있습니다.",
      },
      styling: {
        name: "스타일링",
        description: "컴포넌트는 쉽게 스타일링할 수 있습니다.",
        styledText: "스타일된 텍스트",
        styledContainer: "스타일된 컨테이너 (구분선)",
        tintedIcons: "색이 입혀진 아이콘",
      },
    },
  },
  demoCard: {
    description:
      "카드는 관련 정보를 컨테이너에 담아 표시하는 데 유용합니다. ListItem이 내용을 수평으로 표시한다면, 카드는 내용을 수직으로 표시할 수 있습니다.",
    useCase: {
      presets: {
        name: "프리셋",
        description: "사전 구성된 몇 가지 프리셋이 있습니다.",
        default: {
          heading: "기본 프리셋 (기본값)",
          content: "예제 문장입니다. 그믐밤 반디불은 부서진 달조각",
          footer: "숲으로 가자 달조각을 주으려 숲으로 가자.",
        },
        reversed: {
          heading: "역방향 프리셋",
          content: "예제 문장입니다. 그믐밤 반디불은 부서진 달조각",
          footer: "숲으로 가자 달조각을 주으려 숲으로 가자.",
        },
      },
      verticalAlignment: {
        name: "수직 정렬",
        description: "카드는 필요에 따라 미리 구성된 다양한 정렬방법으로 제공됩니다.",
        top: {
          heading: "상단 (기본값)",
          content: "모든 콘텐츠가 자동으로 상단에 정렬됩니다.",
          footer: "심지어 푸터도",
        },
        center: {
          heading: "중앙",
          content: "콘텐츠는 카드 높이에 상대적으로 중앙에 배치됩니다.",
          footer: "나도!",
        },
        spaceBetween: {
          heading: "공간 사이",
          content: "모든 콘텐츠가 고르게 간격을 둡니다.",
          footer: "나는 내가 있고 싶은 곳에 있어요.",
        },
        reversed: {
          heading: "푸터 강제 하단",
          content: "푸터를 원하는 위치에 밀어 넣습니다.",
          footer: "여기 너무 외로워요.",
        },
      },
      passingContent: {
        name: "내용 전달",
        description: "내용을 전달하는 몇 가지 방법이 있습니다.",
        heading: "`heading` 속성으로",
        content: "`content` 속성으로",
        footer: "푸터도 외로워요.",
      },
      customComponent: {
        name: "사용자 정의 컴포넌트",
        description:
          "사전 구성된 컴포넌트 중 하나를 직접 만든 자신의 컴포넌트로 대체할 수 있습니다. 추가 컴포넌트도 덧붙여 넣을 수 있습니다.",
        rightComponent: "오른쪽 컴포넌트",
        leftComponent: "왼쪽 컴포넌트",
      },
      style: {
        name: "스타일링",
        description: "컴포넌트는 쉽게 스타일링할 수 있습니다.",
        heading: "헤딩 스타일링",
        content: "컨텐츠 스타일링",
        footer: "푸터 스타일링",
      },
    },
  },
  demoAutoImage: {
    description: "원격 또는 data-uri 이미지의 크기를 자동으로 조정하는 Image 컴포넌트입니다.",
    useCase: {
      remoteUri: { name: "원격 URI" },
      base64Uri: { name: "Base64 URI" },
      scaledToFitDimensions: {
        name: "치수에 맞게 조정",
        description:
          "`maxWidth` 단독으로, 혹은 `maxHeight` 속성과 함께 제공하면, 이미지는 비율을 유지하면서 자동으로 크기가 조정됩니다. 이것이 `resizeMode: 'contain'`과 다른 점은 무엇일까요? 첫째, 한쪽 크기만 지정할 수 있습니다. 둘째, 이미지가 이미지 컨테이너 내에 포함되는 대신 원하는 치수에 맞게 조정됩니다.",
        heightAuto: "너비: 60 / 높이: 자동",
        widthAuto: "너비: 자동 / 높이: 32",
        bothManual: "너비: 60 / 높이: 60",
      },
    },
  },
  demoText: {
    description:
      "텍스트 표시가 필요한 경우를 위해, 이 컴포넌트는 기본 React Native 컴포넌트 위에 HOC로 제작되었습니다.",
    useCase: {
      presets: {
        name: "프리셋",
        description: "사전 구성된 몇 가지 프리셋이 있습니다.",
        default: "기본 프리셋 - 예제 문장입니다. 하나 둘 셋.",
        bold: "볼드 프리셋 - 예제 문장입니다. 하나 둘 셋.",
        subheading: "서브헤딩 프리셋 - 예제 문장입니다. 하나 둘 셋.",
        heading: "헤딩 프리셋 - 예제 문장입니다. 하나 둘 셋.",
      },
      sizes: {
        name: "크기",
        description: "크기 속성이 있습니다.",
        xs: "xs - 조금 더 작은 크기 속성입니다.",
        sm: "sm - 작은 크기 속성입니다.",
        md: "md - 중간 크기 속성입니다.",
        lg: "lg - 큰 크기 속성입니다.",
        xl: "xl - 조금 더 큰 크기 속성입니다.",
        xxl: "xxl - 아주 큰 크기 속성입니다.",
      },
      weights: {
        name: "굵기",
        description: "굵기 속성이 있습니다.",
        light: "가벼움 - 예제 문장입니다. 안녕하세요. 하나 둘 셋.",
        normal: "보통 - 예제 문장입니다. 안녕하세요. 하나 둘 셋.",
        medium: "중간 - 예제 문장입니다. 안녕하세요. 하나 둘 셋.",
        semibold: "세미볼드 - 예제 문장입니다. 안녕하세요. 하나 둘 셋.",
        bold: "볼드 - 예제 문장입니다. 안녕하세요. 하나 둘 셋.",
      },
      passingContent: {
        name: "내용 전달",
        description: "내용을 전달하는 몇 가지 방법이 있습니다.",
        viaText:
          "`text` 속성으로 - 죽는 날까지 하늘을 우러러 한 점 부끄럼이 없기를, 잎새에 이는 바람에도 나는 괴로워했다. 별을 노래하는 마음으로 모든 죽어 가는 것을 사랑해야지 그리고 나한테 주어진 길을 걸어가야겠다. 오늘 밤에도 별이 바람에 스치운다.",
        viaTx: "`tx` 속성으로",
        children: "자식 - 또 다른 예제 문장입니다. 하나 둘 셋.",
        nestedChildren: "중첩 자식",
        nestedChildren2: "죽는 날까지 하늘을 우러러 한 점 부끄럼이 없기를, ",
        nestedChildren3: "잎새에 이는 바람에도 나는 괴로워했다.",
        nestedChildren4: "별을 노래하는 마음으로 모든 죽어 가는 것을 사랑해야지.",
      },
      styling: {
        name: "스타일링",
        description: "컴포넌트는 쉽게 스타일링할 수 있습니다.",
        text: "그리고 나한테 주어진 길을 걸어가야겠다.",
        text2: "오늘 밤에도 별이 바람에 스치운다.",
        text3: "계속 이어지는 예제 문장입니다. 하나 둘 셋.",
      },
    },
  },
  demoHeader: {
    description:
      "여러 화면에 나타나는 컴포넌트입니다. 네비게이션 버튼과 화면 제목을 포함할 것입니다.",
    useCase: {
      actionIcons: {
        name: "액션 아이콘",
        description: "왼쪽 또는 오른쪽 액션 컴포넌트에 아이콘을 쉽게 전달할 수 있습니다.",
        leftIconTitle: "왼쪽 아이콘",
        rightIconTitle: "오른쪽 아이콘",
        bothIconsTitle: "양쪽 아이콘",
      },
      actionText: {
        name: "액션 텍스트",
        description: "왼쪽 또는 오른쪽 액션 컴포넌트에 텍스트를 쉽게 전달할 수 있습니다.",
        leftTxTitle: "`leftTx`를 통해",
        rightTextTitle: "`rightText`를 통해",
      },
      customActionComponents: {
        name: "사용자 정의 액션 컴포넌트",
        description:
          "아이콘이나 텍스트 옵션이 충분하지 않은 경우, 사용자 정의 액션 컴포넌트를 전달할 수 있습니다.",
        customLeftActionTitle: "사용자 정의 왼쪽 액션",
      },
      titleModes: {
        name: "제목 모드",
        description:
          "제목은 기본적으로 중앙에 고정되지만 너무 길면 잘릴 수 있습니다. 액션 버튼에 맞춰 조정할 수 있습니다.",
        centeredTitle: "중앙 제목",
        flexTitle: "유연한 제목",
      },
      styling: {
        name: "스타일링",
        description: "컴포넌트는 쉽게 스타일링할 수 있습니다.",
        styledTitle: "스타일된 제목",
        styledWrapperTitle: "스타일된 래퍼",
        tintedIconsTitle: "색이 입혀진 아이콘",
      },
    },
  },
  demoEmptyState: {
    description:
      "표시할 데이터가 없을 때 사용할 수 있는 컴포넌트입니다. 사용자가 다음에 무엇을 할지 안내할 수 있습니다.",
    useCase: {
      presets: {
        name: "프리셋",
        description:
          "다양한 텍스트/이미지 세트를 만들 수 있습니다. `generic`이라는 사전 정의된 세트가 하나 있습니다. 기본값이 없으므로 완전히 사용자 정의된 EmptyState를 원할 경우 사용할 수 있습니다.",
      },
      passingContent: {
        name: "내용 전달",
        description: "내용을 전달하는 몇 가지 방법이 있습니다.",
        customizeImageHeading: "이미지 맞춤 설정",
        customizeImageContent: "어떤 이미지 소스도 전달할 수 있습니다.",
        viaHeadingProp: "`heading` 속성으로",
        viaContentProp: "`content` 속성으로",
        viaButtonProp: "`button` 속성으로",
      },
      styling: {
        name: "스타일링",
        description: "컴포넌트는 쉽게 스타일링할 수 있습니다.",
      },
    },
  },
}

export default demoKo

// @demo remove-file
===== END FILE: app/i18n/demo-ko.ts =====


===== BEGIN FILE: app/i18n/hi.ts =====
import demoHi from "./demo-hi" // @demo remove-current-line
import { Translations } from "./en"

const hi: Translations = {
  common: {
    ok: "ठीक है!",
    cancel: "रद्द करें",
    back: "वापस",
    logOut: "लॉग आउट", // @demo remove-current-line
  },
  welcomeScreen: {
    postscript:
      "psst - शायद आपका ऐप ऐसा नहीं दिखता है। (जब तक कि आपके डिजाइनर ने आपको ये स्क्रीन नहीं दी हों, और उस स्थिति में, इसे लॉन्च करें!)",
    readyForLaunch: "आपका ऐप, लगभग लॉन्च के लिए तैयार है!",
    exciting: "(ओह, यह रोमांचक है!)",
    letsGo: "चलो चलते हैं!", // @demo remove-current-line
  },
  errorScreen: {
    title: "कुछ गलत हो गया!",
    friendlySubtitle:
      "यह वह स्क्रीन है जो आपके उपयोगकर्ता संचालन में देखेंगे जब कोई त्रुटि होगी। आप इस संदेश को बदलना चाहेंगे (जो `app/i18n/hi.ts` में स्थित है) और शायद लेआउट भी (`app/screens/ErrorScreen`)। यदि आप इसे पूरी तरह से हटाना चाहते हैं, तो `app/app.tsx` में <ErrorBoundary> कंपोनेंट की जांच करें।",
    reset: "ऐप रीसेट करें",
    traceTitle: "%{name} स्टैक से त्रुटि", // @demo remove-current-line
  },
  emptyStateComponent: {
    generic: {
      heading: "इतना खाली... इतना उदास",
      content: "अभी तक कोई डेटा नहीं मिला। रीफ्रेश करने या ऐप को पुनः लोड करने के लिए बटन दबाएं।",
      button: "चलो फिर से कोशिश करते हैं",
    },
  },
  // @demo remove-block-start
  errors: {
    invalidEmail: "अमान्य ईमेल पता।",
  },
  loginScreen: {
    logIn: "लॉग इन करें",
    enterDetails:
      "सर्वश्रेष्ठ रहस्य पता करने के लिए नीचे अपना विवरण दर्ज करें। आप कभी अनुमान नहीं लगा पाएंगे कि हमारे पास क्या इंतजार कर रहा है। या शायद आप कर सकते हैं; यह रॉकेट साइंस नहीं है।",
    emailFieldLabel: "ईमेल",
    passwordFieldLabel: "पासवर्ड",
    emailFieldPlaceholder: "अपना ईमेल पता दर्ज करें",
    passwordFieldPlaceholder: "सुपर सीक्रेट पासवर्ड यहाँ",
    tapToLogIn: "लॉग इन करने के लिए टैप करें!",
    hint: "संकेत: आप किसी भी ईमेल पते और अपने पसंदीदा पासवर्ड का उपयोग कर सकते हैं :)",
  },
  demoNavigator: {
    componentsTab: "कंपोनेंट्स",
    debugTab: "डीबग",
    communityTab: "समुदाय",
    podcastListTab: "पॉडकास्ट",
  },
  demoCommunityScreen: {
    title: "समुदाय से जुड़ें",
    tagLine:
      "Infinite Red के React Native इंजीनियरों के समुदाय से जुड़ें और हमारे साथ अपने ऐप विकास को बेहतर बनाएं!",
    joinUsOnSlackTitle: "Slack पर हमसे जुड़ें",
    joinUsOnSlack:
      "क्या आप चाहते हैं कि दुनिया भर के React Native इंजीनियरों से जुड़ने के लिए कोई जगह हो? Infinite Red Community Slack में बातचीत में शामिल हों! हमारा बढ़ता हुआ समुदाय प्रश्न पूछने, दूसरों से सीखने और अपने नेटवर्क को बढ़ाने के लिए एक सुरक्षित स्थान है।",
    joinSlackLink: "Slack समुदाय में शामिल हों",
    makeIgniteEvenBetterTitle: "Ignite को और बेहतर बनाएं",
    makeIgniteEvenBetter:
      "Ignite को और बेहतर बनाने का कोई विचार है? हमें यह सुनकर खुशी होगी! हम हमेशा ऐसे लोगों की तलाश में रहते हैं जो हमें सर्वश्रेष्ठ React Native टूलिंग बनाने में मदद करना चाहते हैं। Ignite के भविष्य को बनाने में हमारे साथ शामिल होने के लिए GitHub पर हमसे जुड़ें।",
    contributeToIgniteLink: "Ignite में योगदान दें",
    theLatestInReactNativeTitle: "React Native में नवीनतम",
    theLatestInReactNative: "हम आपको React Native के सभी प्रस्तावों पर अपडेट रखने के लिए यहां हैं।",
    reactNativeRadioLink: "React Native रेडियो",
    reactNativeNewsletterLink: "React Native न्यूजलेटर",
    reactNativeLiveLink: "React Native लाइव",
    chainReactConferenceLink: "Chain React कॉन्फ्रेंस",
    hireUsTitle: "अपने अगले प्रोजेक्ट के लिए Infinite Red को काम पर रखें",
    hireUs:
      "चाहे वह एक पूरा प्रोजेक्ट चलाना हो या हमारे हैंड्स-ऑन प्रशिक्षण के साथ टीमों को गति देना हो, Infinite Red लगभग किसी भी React Native प्रोजेक्ट में मदद कर सकता है।",
    hireUsLink: "हमें एक संदेश भेजें",
  },
  demoShowroomScreen: {
    jumpStart: "अपने प्रोजेक्ट को जंप स्टार्ट करने के लिए कंपोनेंट्स!",
    lorem2Sentences:
      "कोई भी काम जो आप नहीं करना चाहते, उसे करने के लिए किसी और को ढूंढना चाहिए। जो लोग दूसरों की मदद करते हैं, वे खुद की भी मदद करते हैं।",
    demoHeaderTxExample: "हाँ",
    demoViaTxProp: "`tx` प्रॉप के माध्यम से",
    demoViaSpecifiedTxProp: "`{{prop}}Tx` प्रॉप के माध्यम से",
  },
  demoDebugScreen: {
    howTo: "कैसे करें",
    title: "डीबग",
    tagLine:
      "बधाई हो, आपके पास यहां एक बहुत उन्नत React Native ऐप टेम्पलेट है। इस बॉयलरप्लेट का लाभ उठाएं!",
    reactotron: "Reactotron को भेजें",
    reportBugs: "बग्स की रिपोर्ट करें",
    demoList: "डेमो सूची",
    demoPodcastList: "डेमो पॉडकास्ट सूची",
    androidReactotronHint:
      "यदि यह काम नहीं करता है, तो सुनिश्चित करें कि Reactotron डेस्कटॉप ऐप चल रहा है, अपने टर्मिनल से adb reverse tcp:9090 tcp:9090 चलाएं, और ऐप को पुनः लोड करें।",
    iosReactotronHint:
      "यदि यह काम नहीं करता है, तो सुनिश्चित करें कि Reactotron डेस्कटॉप ऐप चल रहा है और ऐप को पुनः लोड करें।",
    macosReactotronHint:
      "यदि यह काम नहीं करता है, तो सुनिश्चित करें कि Reactotron डेस्कटॉप ऐप चल रहा है और ऐप को पुनः लोड करें।",
    webReactotronHint:
      "यदि यह काम नहीं करता है, तो सुनिश्चित करें कि Reactotron डेस्कटॉप ऐप चल रहा है और ऐप को पुनः लोड करें।",
    windowsReactotronHint:
      "यदि यह काम नहीं करता है, तो सुनिश्चित करें कि Reactotron डेस्कटॉप ऐप चल रहा है और ऐप को पुनः लोड करें।",
  },
  demoPodcastListScreen: {
    title: "React Native रेडियो एपिसोड",
    onlyFavorites: "केवल पसंदीदा दिखाएं",
    favoriteButton: "पसंदीदा",
    unfavoriteButton: "नापसंद",
    accessibility: {
      cardHint:
        "एपिसोड सुनने के लिए डबल टैप करें। इस एपिसोड को {{action}} करने के लिए डबल टैप करें और होल्ड करें।",
      switch: "केवल पसंदीदा दिखाने के लिए स्विच करें",
      favoriteAction: "पसंदीदा टॉगल करें",
      favoriteIcon: "एपिसोड पसंदीदा नहीं है",
      unfavoriteIcon: "एपिसोड पसंदीदा है",
      publishLabel: "{{date}} को प्रकाशित",
      durationLabel: "अवधि: {{hours}} घंटे {{minutes}} मिनट {{seconds}} सेकंड",
    },
    noFavoritesEmptyState: {
      heading: "यह थोड़ा खाली लगता है",
      content:
        "अभी तक कोई पसंदीदा नहीं जोड़ा गया है। इसे अपने पसंदीदा में जोड़ने के लिए किसी एपिसोड पर दिल पर टैप करें!",
    },
  },
  // @demo remove-block-end
  // @demo remove-block-start
  ...demoHi,
  // @demo remove-block-end
}

export default hi
===== END FILE: app/i18n/hi.ts =====


===== BEGIN FILE: app/i18n/fr.ts =====
import demoFr from "./demo-fr" // @demo remove-current-line
import { Translations } from "./en"

const fr: Translations = {
  common: {
    ok: "OK !",
    cancel: "Annuler",
    back: "Retour",
    logOut: "Déconnexion", // @demo remove-current-line
  },
  welcomeScreen: {
    postscript:
      "psst  — Ce n'est probablement pas à quoi ressemble votre application. (À moins que votre designer ne vous ait donné ces écrans, dans ce cas, mettez la en prod !)",
    readyForLaunch: "Votre application, presque prête pour le lancement !",
    exciting: "(ohh, c'est excitant !)",
    letsGo: "Allons-y !", // @demo remove-current-line
  },
  errorScreen: {
    title: "Quelque chose s'est mal passé !",
    friendlySubtitle:
      "C'est l'écran que vos utilisateurs verront en production lorsqu'une erreur sera lancée. Vous voudrez personnaliser ce message (situé dans `app/i18n/fr.ts`) et probablement aussi la mise en page (`app/screens/ErrorScreen`). Si vous voulez le supprimer complètement, vérifiez `app/app.tsx` pour le composant <ErrorBoundary>.",
    reset: "RÉINITIALISER L'APPLICATION",
    traceTitle: "Erreur depuis %{name}", // @demo remove-current-line
  },
  emptyStateComponent: {
    generic: {
      heading: "Si vide... si triste",
      content:
        "Aucune donnée trouvée pour le moment. Essayez de cliquer sur le bouton pour rafraîchir ou recharger l'application.",
      button: "Essayons à nouveau",
    },
  },
  // @demo remove-block-start
  errors: {
    invalidEmail: "Adresse e-mail invalide.",
  },
  loginScreen: {
    logIn: "Se connecter",
    enterDetails:
      "Entrez vos informations ci-dessous pour débloquer des informations top secrètes. Vous ne devinerez jamais ce que nous avons en attente. Ou peut-être que vous le ferez ; ce n'est pas de la science spatiale ici.",
    emailFieldLabel: "E-mail",
    passwordFieldLabel: "Mot de passe",
    emailFieldPlaceholder: "Entrez votre adresse e-mail",
    passwordFieldPlaceholder: "Mot de passe super secret ici",
    tapToLogIn: "Appuyez pour vous connecter!",
    hint: "Astuce : vous pouvez utiliser n'importe quelle adresse e-mail et votre mot de passe préféré :)",
  },
  demoNavigator: {
    componentsTab: "Composants",
    debugTab: "Débogage",
    communityTab: "Communauté",
    podcastListTab: "Podcasts",
  },
  demoCommunityScreen: {
    title: "Connectez-vous avec la communauté",
    tagLine:
      "Rejoignez la communauté d'ingénieurs React Native d'Infinite Red et améliorez votre développement d'applications avec nous !",
    joinUsOnSlackTitle: "Rejoignez-nous sur Slack",
    joinUsOnSlack:
      "Vous souhaitez vous connecter avec des ingénieurs React Native du monde entier ? Rejoignez la conversation dans la communauté Slack d'Infinite Red ! Notre communauté en pleine croissance est un espace sûr pour poser des questions, apprendre des autres et développer votre réseau.",
    joinSlackLink: "Rejoindre la communauté Slack",
    makeIgniteEvenBetterTitle: "Rendre Ignite encore meilleur",
    makeIgniteEvenBetter:
      "Vous avez une idée pour rendre Ignite encore meilleur ? Nous sommes heureux de l'entendre ! Nous cherchons toujours des personnes qui veulent nous aider à construire les meilleurs outils React Native. Rejoignez-nous sur GitHub pour nous aider à construire l'avenir d'Ignite.",
    contributeToIgniteLink: "Contribuer à Ignite",
    theLatestInReactNativeTitle: "Les dernières nouvelles de React Native",
    theLatestInReactNative:
      "Nous sommes là pour vous tenir au courant de tout ce que React Native a à offrir.",
    reactNativeRadioLink: "React Native Radio",
    reactNativeNewsletterLink: "React Native Newsletter",
    reactNativeLiveLink: "React Native Live",
    chainReactConferenceLink: "Conférence Chain React",
    hireUsTitle: "Engagez Infinite Red pour votre prochain projet",
    hireUs:
      "Que ce soit pour gérer un projet complet ou pour former des équipes à notre formation pratique, Infinite Red peut vous aider pour presque tous les projets React Native.",
    hireUsLink: "Envoyez-nous un message",
  },
  demoShowroomScreen: {
    jumpStart: "Composants pour démarrer votre projet !",
    lorem2Sentences:
      "Nulla cupidatat deserunt amet quis aliquip nostrud do adipisicing. Adipisicing excepteur elit laborum Lorem adipisicing do duis.",
    demoHeaderTxExample: "Yay",
    demoViaTxProp: "Via la propriété `tx`",
    demoViaSpecifiedTxProp: "Via la propriété `{{prop}}Tx` spécifiée",
  },
  demoDebugScreen: {
    howTo: "COMMENT FAIRE",
    title: "Débugage",
    tagLine:
      "Félicitations, vous avez un modèle d'application React Native très avancé ici. Profitez de cette base de code !",
    reactotron: "Envoyer à Reactotron",
    reportBugs: "Signaler des bugs",
    demoList: "Liste de démonstration",
    demoPodcastList: "Liste de podcasts de démonstration",
    androidReactotronHint:
      "Si cela ne fonctionne pas, assurez-vous que l'application de bureau Reactotron est en cours d'exécution, exécutez adb reverse tcp:9090 tcp:9090 à partir de votre terminal, puis rechargez l'application.",
    iosReactotronHint:
      "Si cela ne fonctionne pas, assurez-vous que l'application de bureau Reactotron est en cours d'exécution, puis rechargez l'application.",
    macosReactotronHint:
      "Si cela ne fonctionne pas, assurez-vous que l'application de bureau Reactotron est en cours d'exécution, puis rechargez l'application.",
    webReactotronHint:
      "Si cela ne fonctionne pas, assurez-vous que l'application de bureau Reactotron est en cours d'exécution, puis rechargez l'application.",
    windowsReactotronHint:
      "Si cela ne fonctionne pas, assurez-vous que l'application de bureau Reactotron est en cours d'exécution, puis rechargez l'application.",
  },
  demoPodcastListScreen: {
    title: "Épisodes de Radio React Native",
    onlyFavorites: "Afficher uniquement les favoris",
    favoriteButton: "Favori",
    unfavoriteButton: "Non favori",
    accessibility: {
      cardHint:
        "Double-cliquez pour écouter l'épisode. Double-cliquez et maintenez pour {{action}} cet épisode.",
      switch: "Activez pour afficher uniquement les favoris",
      favoriteAction: "Basculer en favori",
      favoriteIcon: "Épisode non favori",
      unfavoriteIcon: "Épisode favori",
      publishLabel: "Publié le {{date}}",
      durationLabel: "Durée : {{hours}} heures {{minutes}} minutes {{seconds}} secondes",
    },
    noFavoritesEmptyState: {
      heading: "C'est un peu vide ici",
      content:
        "Aucun favori n'a été ajouté pour le moment. Appuyez sur le cœur d'un épisode pour l'ajouter à vos favoris !",
    },
  },
  // @demo remove-block-start
  ...demoFr,
  // @demo remove-block-end
}

export default fr
===== END FILE: app/i18n/fr.ts =====


===== BEGIN FILE: app/i18n/demo-es.ts =====
import { DemoTranslations } from "./demo-en"

export const demoEs: DemoTranslations = {
  demoIcon: {
    description:
      "Un componente para dibujar un ícono pre-definido. Si se proporciona el atributo `onPress`, se rodea por un componente <TouchableOpacity />. De lo contrario, se rodea por un componente <View />.",
    useCase: {
      icons: {
        name: "Íconos",
        description: "Lista de los íconos pre-definidos para el componente.",
      },
      size: {
        name: "Tamaño",
        description: "Hay un atributo para el tamaño.",
      },
      color: {
        name: "Color",
        description: "Hay un atributo para el color.",
      },
      styling: {
        name: "Estilo",
        description: "El componente puede ser configurado fácilmente.",
      },
    },
  },
  demoTextField: {
    description: "El componente <TextField /> permite el ingreso y edición de texto.",
    useCase: {
      statuses: {
        name: "Estados",
        description:
          "Hay un atributo para el estado - similar a `preset` en otros componentes, pero que además impacta en la funcionalidad del componente.",
        noStatus: {
          label: "Sin estado",
          helper: "Este es el estado por defecto",
          placeholder: "El texto va acá",
        },
        error: {
          label: "Estado de error",
          helper: "Estado para usar en caso de error",
          placeholder: "El texto va acá",
        },
        disabled: {
          label: "Estado desactivado",
          helper: "Desactiva la edición y atenúa el texto",
          placeholder: "El texto va acá",
        },
      },
      passingContent: {
        name: "Entregando contenido",
        description: "Hay varias formas de entregar contenido.",
        viaLabel: {
          labelTx: "A través del atributo `label`",
          helper: "A través del atributo `helper`",
          placeholder: "A través del atributo `placeholder`",
        },
        rightAccessory: {
          label: "Complemento derecho",
          helper: "Este atributo requiere una función que retorne un elemento React.",
        },
        leftAccessory: {
          label: "Complemento izquierdo",
          helper: "Este atributo requiere una función que retorne un elemento React.",
        },
        supportsMultiline: {
          label: "Soporta múltilíneas",
          helper: "Permite un input de texto más largo para texto multilinea.",
        },
      },
      styling: {
        name: "Estilo",
        description: "El componente puede ser configurado fácilmente.",
        styleInput: {
          label: "Estilo del input",
          helper: "A través de el atributo `style`",
        },
        styleInputWrapper: {
          label: "Estilo del contenedor del input",
          helper: "A través de el atributo `inputWrapperStyle`",
        },
        styleContainer: {
          label: "Estilo del contenedor",
          helper: "A través de el atributo `containerStyle`",
        },
        styleLabel: {
          label: "Estilo de la etiqueta y texto de ayuda",
          helper: "A través de las props de estilo `LabelTextProps` y `HelperTextProps`",
        },
        styleAccessories: {
          label: "Estilo de los accesorios",
          helper: "A través de las props de estilo `RightAccessory` y `LeftAccessory`",
        },
      },
    },
  },
  demoToggle: {
    description:
      "Dibuja un switch de tipo booleano. Este componente requiere un callback `onValueChange` que actualice el atributo `value` para que este refleje las acciones del usuario. Si el atributo `value` no se actualiza, el componente seguirá mostrando el valor proporcionado por defecto en lugar de lo esperado por las acciones del usuario.",
    useCase: {
      variants: {
        name: "Variantes",
        description:
          "El componente soporta diferentes variantes. Si se necesita una personalización más avanzada o variante específica, puede ser fácilmente refactorizada. El valor por defecto es `checkbox`.",
        checkbox: {
          label: "Variante `checkbox`",
          helper: "Puede ser utilizada para un único valor del tipo on/off.",
        },
        radio: {
          label: "Variante `radio`",
          helper: "Usa esto cuando tengas múltiples opciones.",
        },
        switch: {
          label: "Variante `switch`",
          helper:
            "Una entrada del tipo on/off que sobresale más. Tiene mejor soporte de accesibilidad.",
        },
      },
      statuses: {
        name: "Estados",
        description:
          "Hay un atributo de estado - similar a `preset` en otros componentes, pero que además impacta en la funcionalidad del componente.",
        noStatus: "Sin estado - este es el valor por defecto",
        errorStatus: "Estado de error - para usar cuando haya un error",
        disabledStatus: "Estado desactivado - desactiva la edición y silencia el input",
      },
      passingContent: {
        name: "Entregando contenido",
        description: "Hay varias formas de entregar contenido.",
        useCase: {
          checkBox: {
            label: "A través del atributo `labelTx`",
            helper: "A través del atributo `helperTx`.",
          },
          checkBoxMultiLine: {
            helper: "Soporta multi líneas - Nulla proident consectetur labore sunt ea labore.",
          },
          radioChangeSides: {
            helper: "Puedes cambiarle el lado - Laborum labore adipisicing in eu ipsum deserunt.",
          },
          customCheckBox: {
            label: "Pasa un ícono para un checkbox personalizado.",
          },
          switch: {
            label: "Los interruptores pueden leerse como texto",
            helper:
              "Por defecto, esta opción no usa `Text` ya que, dependiendo de la fuente, los caracteres on/off podrían no dibujarse bien. Personalízalo según tus necesidades.",
          },
          switchAid: {
            label: "O con la ayuda de un ícono",
          },
        },
      },
      styling: {
        name: "Estilo",
        description: "El componente puede ser configurado fácilmente.",
        outerWrapper: "1 - configura el contenedor externo del input",
        innerWrapper: "2 - configura el contenedor interno del input",
        inputDetail: "3 - configura el detalle del input",
        labelTx: "También puedes configurar el atributo labelTx",
        styleContainer: "O, configura todo el contenedor",
      },
    },
  },
  demoButton: {
    description:
      "Un componente que permite a los usuarios realizar acciones y hacer elecciones. Rodea un componente Text con otro componente Pressable.",
    useCase: {
      presets: {
        name: "Preajustes",
        description: "Hay algunos preajustes por defecto.",
      },
      passingContent: {
        name: "Entregando contenido",
        description: "Hay varias formas de entregar contenido.",
        viaTextProps: "A través del atributo `text` - Billum In",
        children: "Contenido anidado (children) - Irure Reprehenderit",
        rightAccessory: "Componente derecho - Duis Quis",
        leftAccessory: "Componente izquierdo - Duis Proident",
        nestedChildren: "Contenido anidado - proident veniam.",
        nestedChildren2: "Ullamco cupidatat officia exercitation velit non ullamco nisi..",
        nestedChildren3: "Occaecat aliqua irure proident veniam.",
        multiLine:
          "Multilínea - consequat veniam veniam reprehenderit. Fugiat id nisi quis duis sunt proident mollit dolor mollit adipisicing proident deserunt.",
      },
      styling: {
        name: "Estilo",
        description: "El componente puede ser configurando fácilmente.",
        styleContainer: "Estilo del contenedor - Exercitation",
        styleText: "Estilo del texto - Ea Anim",
        styleAccessories: "Estilo de los componentes - enim ea id fugiat anim ad.",
        pressedState: "Estilo para el estado presionado - fugiat anim",
      },
      disabling: {
        name: "Desactivado",
        description:
          "El componente puede ser desactivado y como consecuencia, estilizado. El comportamiento para hacer clic será desactivado.",
        standard: "Desactivado - estándar",
        filled: "Desactivado - relleno",
        reversed: "Desactivado - invertido",
        accessory: "Estilo del componente desactivado",
        textStyle: "Estilo del texto desactivado",
      },
    },
  },
  demoListItem: {
    description:
      "Un componente estilizado que representa una fila para ser utilizada dentro de un FlatList, SectionList o por sí solo.",
    useCase: {
      height: {
        name: "Altura",
        description: "La fila puede tener diferentes alturas.",
        defaultHeight: "Altura por defecto (56px)",
        customHeight: "Altura personalizada a través del atributo `height`",
        textHeight:
          "Altura determinada por el contenido del texto - Reprehenderit incididunt deserunt do do ea labore.",
        longText:
          "Limitar texto largo a solo una línea - Reprehenderit incididunt deserunt do do ea labore.",
      },
      separators: {
        name: "Separadores",
        description: "El separador/divisor está preconfigurado y es opcional.",
        topSeparator: "Separador solo en la parte superior",
        topAndBottomSeparator: "Separadores en la parte superior e inferior",
        bottomSeparator: "Separador solo en la parte inferior",
      },
      icons: {
        name: "Íconos",
        description: "Puedes personalizar los íconos a la izquierda o a la derecha.",
        leftIcon: "Ícono izquierdo",
        rightIcon: "Ícono derecho",
        leftRightIcons: "Íconos izquierdo y derecho",
      },
      customLeftRight: {
        name: "Componentes personalizados en la izquierda o derecha",
        description:
          "Puede pasar un componente personalizado en la izquierda o derecha, si así lo necesitas.",
        customLeft: "Componente personalizado a la izquierda",
        customRight: "Componente personalizado a la derecha",
      },
      passingContent: {
        name: "Entregando contenido",
        description: "Hay varias formas de entregar contenido.",
        text: "A través del atributo `text` - reprehenderit sint",
        children: "Contenido anidado (children) - mostrud mollit",
        nestedChildren1: "Contenido anidado 1 - proident veniam.",
        nestedChildren2: "Ullamco cupidatat officia exercitation velit non ullamco nisi..",
      },
      listIntegration: {
        name: "Integración con FlatList",
        description:
          "El componente puede ser fácilmente integrado con tu interfaz de lista preferida.",
      },
      styling: {
        name: "Estilo",
        description: "El componente puede ser configurando fácilmente.",
        styledText: "Texto estilizado",
        styledContainer: "Contenedor estilizado (separadores)",
        tintedIcons: "Íconos coloreados",
      },
    },
  },
  demoCard: {
    description:
      "Las tarjetas son útiles para mostrar información relacionada de forma englobada. Si un ListItem muestra el contenido horizontalmente, una tarjeta puede ser también utilizada para mostrar el contenido de manera vertical.",
    useCase: {
      presets: {
        name: "Preajustes",
        description: "Hay algunos ajustes preconfigurados.",
        default: {
          heading: "Preajuste por defecto (default)",
          content: "Incididunt magna ut aliquip consectetur mollit dolor.",
          footer: "Consectetur nulla non aliquip velit.",
        },
        reversed: {
          heading: "Preajuste inverso",
          content: "Reprehenderit occaecat proident amet id laboris.",
          footer: "Consectetur tempor ea non labore anim.",
        },
      },
      verticalAlignment: {
        name: "Alineamiento vertical",
        description:
          "Dependiendo del requerimiento, la tarjeta está preconfigurada con diferentes estrategias de alineación.",
        top: {
          heading: "Arriba (por defecto)",
          content: "Todo el contenido está automáticamente alineado en la parte superior.",
          footer: "Incluso en el pie de página",
        },
        center: {
          heading: "Centro",
          content: "El contenido está centrado en relación con la altura de la tarjeta.",
          footer: "¡Yo también!",
        },
        spaceBetween: {
          heading: "Espacio entre",
          content: "Todo el contenido está espaciado uniformemente.",
          footer: "Estoy donde quiero estar.",
        },
        reversed: {
          heading: "Forzar el pie de página hacia abajo",
          content: "Esto empuja el pie de página hacia donde pertenece.",
          footer: "Estoy tan solo aquí abajo.",
        },
      },
      passingContent: {
        name: "Entregando contenido",
        description: "Hay varias formas de entregar contenido.",
        heading: "A través del atributo `heading`",
        content: "A través del atributo `content`",
        footer: "Estoy tan solo aquí abajo.",
      },
      customComponent: {
        name: "Componentes personalizados",
        description:
          "Cualquier componente preconfigurado puede ser reemplazado por uno específico. Puedes agregar otros si así lo requieres.",
        rightComponent: "Componente derecho",
        leftComponent: "Componente izquierdo",
      },
      style: {
        name: "Estilo",
        description: "El componente puede ser configurado fácilmente.",
        heading: "Estilizar el encabezado",
        content: "Estilizar el contenido",
        footer: "Estilizar el pie de página",
      },
    },
  },
  demoAutoImage: {
    description:
      "Un componente que se ajusta automáticamente el tamaño de una imagen remota o utilizando el atributo data-uri.",
    useCase: {
      remoteUri: { name: "URI remota" },
      base64Uri: { name: "URI Base64" },
      scaledToFitDimensions: {
        name: "Escalado que se ajusta a las dimensiones",
        description:
          "Al proporcionar los atributos `maxWidth` y/o `maxHeight`, la imagen se redimensionará automáticamente manteniendo el ratio. ¿En qué se diferencia de `resizeMode: 'contain'`? Para empezar, puedes especificar el tamaño de un solo lado (no ambos). Segundo, la imagen se ajustará a las dimensiones deseadas en lugar de simplemente estar contenida en su contenedor.",
        heightAuto: "ancho: 60 / altura: auto",
        widthAuto: "ancho: auto / altura: 32",
        bothManual: "ancho: 60 / altura: 60",
      },
    },
  },
  demoText: {
    description:
      "Para todo tipo de requerimiento relacionado a mostrar texto. Este componente es un 'wrapper' (HOC) del componente Text de React Native.",
    useCase: {
      presets: {
        name: "Preajustes",
        description: "Hay algunos ajustes preconfigurados.",
        default:
          "ajuste por defecto - Cillum eu laboris in labore. Excepteur mollit tempor reprehenderit fugiat elit et eu consequat laborum.",
        bold: "preajuste negrita - Tempor et ullamco cupidatat in officia. Nulla ea duis elit id sunt ipsum cillum duis deserunt nostrud ut nostrud id.",
        subheading: "preajuste subtítulo - In Cupidatat Cillum.",
        heading: "preajuste título - Voluptate Adipis.",
      },
      sizes: {
        name: "Tamaños",
        description: "Hay un atributo de tamaño.",
        xs: "xs - Ea ipsum est ea ex sunt.",
        sm: "sm - Lorem sunt adipisicin.",
        md: "md - Consequat id do lorem.",
        lg: "lg - Nostrud ipsum ea.",
        xl: "xl - Eiusmod ex excepteur.",
        xxl: "xxl - Cillum eu laboris.",
      },
      weights: {
        name: "Grueso",
        description: "Hay un atributo de grueso.",
        light:
          "ligero - Nulla magna incididunt excepteur est occaecat duis culpa dolore cupidatat enim et.",
        normal:
          "normal - Magna incididunt dolor ut veniam veniam laboris aliqua velit ea incididunt.",
        medium: "medio - Non duis laborum quis laboris occaecat culpa cillum.",
        semibold: "seminegrita - Exercitation magna nostrud pariatur laborum occaecat aliqua.",
        bold: "negrita - Eiusmod ullamco magna exercitation est excepteur.",
      },
      passingContent: {
        name: "Entregando contenido",
        description: "Hay varias formas de entregar contenido.",
        viaText:
          "a través del atributo `text` - Billum in aute fugiat proident nisi pariatur est. Cupidatat anim cillum eiusmod ad. Officia eu magna aliquip labore dolore consequat.",
        viaTx: "a través del atributo `tx` -",
        children:
          "Contenido anidado (children) - Aliqua velit irure reprehenderit eu qui amet veniam consectetur.",
        nestedChildren: "Contenidos anidados -",
        nestedChildren2: "Occaecat aliqua irure proident veniam.",
        nestedChildren3: "Ullamco cupidatat officia exercitation velit non ullamco nisi..",
        nestedChildren4: "Occaecat aliqua irure proident veniam.",
      },
      styling: {
        name: "Estilo",
        description: "El componente puede ser configurando fácilmente.",
        text: "Consequat ullamco veniam velit mollit proident excepteur aliquip id culpa ipsum velit sint nostrud.",
        text2:
          "Eiusmod occaecat laboris eu ex veniam ipsum adipisicing consectetur. Magna ullamco adipisicing tempor adipisicing.",
        text3:
          "Eiusmod occaecat laboris eu ex veniam ipsum adipisicing consectetur. Magna ullamco adipisicing tempor adipisicing.",
      },
    },
  },
  demoHeader: {
    description:
      "Componente desplegado en varias pantallas. Va a contener botones de navegación y el título de la pantalla.",
    useCase: {
      actionIcons: {
        name: "Íconos de acción",
        description: "Puedes pasar fácilmente íconos a los componentes de la izquierda o derecha.",
        leftIconTitle: "Ícono izquierdo",
        rightIconTitle: "Ícono derecho",
        bothIconsTitle: "Ambos íconos",
      },
      actionText: {
        name: "Texto de acción",
        description: "Puedes pasar fácilmente texto a los componentes de la izquierda o derecha.",
        leftTxTitle: "A través de `leftTx`",
        rightTextTitle: "A través de `rightText`",
      },
      customActionComponents: {
        name: "Componentes personalizados de acción",
        description:
          "Si las opciones de ícono o texto no son suficientes, puedes pasar tu propio componente personalizado de acción.",
        customLeftActionTitle: "Acción izquierda personalizada",
      },
      titleModes: {
        name: "Alineamiento para el título",
        description:
          "El título puede ser forzado a permanecer centrado (por defecto), pero podría cortarse si es demasiado largo. También puedes hacer que se ajuste a los botones a la izquierda o derecha.",
        centeredTitle: "Título centrado",
        flexTitle: "Título flexible",
      },
      styling: {
        name: "Estilo",
        description: "El componente puede ser configurado fácilmente.",
        styledTitle: "Título estilizado",
        styledWrapperTitle: "Contenedor estilizado",
        tintedIconsTitle: "Íconos coloreados",
      },
    },
  },
  demoEmptyState: {
    description:
      "Un componente para cuando no hay información que mostrar. Puede usarse también para guiar al usuario sobre qué hacer a continuación.",
    useCase: {
      presets: {
        name: "Preajustes",
        description:
          "Puedes crear distintos conjuntos de texto/imagen. Por ejemplo, con un ajuste predefinido `generic`. Si quieres tener un EmptyState completamente personalizado, ten en cuenta que no hay un valor por defecto.",
      },
      passingContent: {
        name: "Entregando contenido",
        description: "Hay varias formas de entregar contenido.",
        customizeImageHeading: "Personalizar la imagen",
        customizeImageContent: "Puedes pasar cualquier una imagen de distintas fuentes.",
        viaHeadingProp: "A través del atributo `heading`",
        viaContentProp: "A través del atributo `content`.",
        viaButtonProp: "A través del atributo `button`",
      },
      styling: {
        name: "Estilo",
        description: "El componente puede ser configurado fácilmente.",
      },
    },
  },
}

export default demoEs

// @demo remove-file
===== END FILE: app/i18n/demo-es.ts =====


===== BEGIN FILE: app/i18n/demo-ar.ts =====
import { DemoTranslations } from "./demo-en"

export const demoAr: DemoTranslations = {
  demoIcon: {
    description:
      "مكون لعرض أيقونة مسجلة.يتم تغليفه في <TouchableOpacity> يتم توفير 'OnPress'، وإلا يتم توفير <View",
    useCase: {
      icons: {
        name: "Icons",
        description: "قائمة الرموز المسجلة داخل المكون.",
      },
      size: {
        name: "Size",
        description: "هناك حجم الدعامة.",
      },
      color: {
        name: "لون",
        description: "هناك لون الدعامة.",
      },
      styling: {
        name: "التصميم",
        description: "يمكن تصميم المكون بسهولة.",
      },
    },
  },
  demoTextField: {
    description: "TextField يسمح المكون بإدخال النص وتحريره.",
    useCase: {
      statuses: {
        name: "الحالات",
        description:
          "هناك حالة مماثلة ل 'preset' في المكونات الأخرى، ولكنها تؤثر على وظيفة المكون ايضاً.",
        noStatus: {
          label: "لا يوجد حالات",
          helper: "هذه هي الحالة الافتراضية",
          placeholder: "النص يذهب هنا",
        },
        error: {
          label: "حالة الخطأ",
          helper: "الحالة التي يجب استخدامها عند وجود خطأ",
          placeholder: "النص يذهب هنا",
        },
        disabled: {
          label: "حالة الإعاقة",
          helper: "يعطل إمكانية التحرير ويكتم النص",
          placeholder: "النص يذهب هنا",
        },
      },
      passingContent: {
        name: "محتوى عابر",
        description: "هناك عدة طرق مختلفة لتمرير المحتوى",
        viaLabel: {
          labelTx: "عبر 'label' الدعامة",
          helper: "عبر 'helper' الدعامة",
          placeholder: "عبر 'placeholder' الدعامة",
        },
        rightAccessory: {
          label: "RightAccessory",
          helper: "هذه الدعامة تأخذ دالة تقوم بإرجاع عنصر React",
        },
        leftAccessory: {
          label: "LeftAccessory",
          helper: "هذه الدعامة تأخذ دالة تقوم بإرجاع عنصر React",
        },
        supportsMultiline: {
          label: "يدعم Multiline",
          helper: "يتيح إدخالا اطول للنص متعدد الأسطر.",
        },
      },
      styling: {
        name: "التصميم",
        description: "يمكن تصميم المكون بسهولة",
        styleInput: {
          label: "أسلوب الإدخال",
          helper: "عبر دعامة 'Style'",
        },
        styleInputWrapper: {
          label: "غلاف ادخال النمط",
          helper: "عبر دعامة 'InputWrapperStyle'",
        },
        styleContainer: {
          label: "حاوية النمط",
          helper: "عبر دعامة 'containerstyle'",
        },
        styleLabel: {
          label: "تسمية النمط والمساعد",
          helper: "عبر أسلوب الدعامة 'LabelTextProps' & 'HelperTextProps'",
        },
        styleAccessories: {
          label: "اكسسورات الاناقة",
          helper: "عبر أسلوب الدعامة 'RightAccessory' & 'LeftAccessory'",
        },
      },
    },
  },
  demoToggle: {
    description:
      "يقوم بعرض ادخال منطقي.هذا مكون خاضع للتحكم ويتطلب استدعاء OnValueChanger الذي يقوم بتحديث خاصية القيمة حتى يعكس المكون إجراءات المستخدم. إذا لم يتم تحديث خاصية القيمة، فسيستمر المكون في عرض خاصية القيمة المقدمة بدلا من النتيجة المتوقعة لأي إجراءات مستخدم.",
    useCase: {
      variants: {
        name: "المتغيرات",
        description:
          "تدعم المكونات عددا قليلا من المتغيرات المختلفة. اذا كانت هناك حاجة إلى تخصيص كبير لمتغير معين، فيمكن إعادة صياغته بسهولة. الافتراضي هو 'checkbox'",
        checkbox: {
          label: "'checkbox' متغير",
          helper: "يمكن استخدامه كمدخل تشغيل \\ إيقاف واحد",
        },
        radio: {
          label: "'radio' متغير",
          helper: "استخدام هذا عندما يكون لديك خيارات متعددة",
        },
        switch: {
          label: "'switch' متغير",
          helper: "مدخل تشغيل/إيقاف أكثر بروزا. يتمتع بدعم إمكانية الوصول بشكل أفضل.",
        },
      },
      statuses: {
        name: "الحالات",
        description:
          "هناك دعامة حالة مشابهة ل 'preset' في المكونات الأخرى، لكنها تؤثر على وظائف المكونات ايضاً",
        noStatus: "لا توجد حالات- هذا هو الوضع الافتراضي",
        errorStatus: "حالة الخطأ - استخدمها عندما يكون هناك خطأ",
        disabledStatus: "حالة معطلة- تعطيل إمكانية التحرير وكتم صوت الإدخال",
      },
      passingContent: {
        name: "محتوى عابر",
        description: "هناك عدة طرق مختلفة لتمرير المحتوى",
        useCase: {
          checkBox: {
            label: "عبر دعامة 'labelTx'",
            helper: "عبر دعامة 'helpertx'",
          },
          checkBoxMultiLine: {
            helper: "يدعم خطوط متعددة-Nulla provident consectetur labore sunt ea labore ",
          },
          radioChangeSides: {
            helper: "يمكنك تغيير الجانبين - Laborum labore adipisicing in eu ipsum deserunt.",
          },
          customCheckBox: {
            label: "مرر أيقونة مربع الاختيار المخصص",
          },
          switch: {
            label: "يمكن قراءة المفاتيح كنص",
            helper:
              "بشكل افتراضي، لا يستخدم هذا الخيار \"text' نظرا لأنه اعتمادا على الخط، قد تبدو الأحرف التي يتم تشغيلها/ايقافها غريبة. قم بالتخصيص حسب الحاجة",
          },
          switchAid: {
            label: "او بمساعدة أيقونة",
          },
        },
      },
      styling: {
        name: "التصميم",
        description: "يمكن تصميم المكون بسهولة",
        outerWrapper: "١- تصميم الغلاف الخارجي للإدخال",
        innerWrapper: "٢- تصميم الغلاف الداخلي للإدخال",
        inputDetail: "٣- تصميم تفاصيل الإدخال",
        labelTx: "يمكنك ايضاً تصميم الملصق labelTx",
        styleContainer: "او، قم بتصميم الحاوية بأكملها",
      },
    },
  },
  demoButton: {
    description:
      "مكون يسمح للمستخدمين بإتخاذ الإجراءات والاختيارات. يلف مكون النص بمكون قابل للضغط",
    useCase: {
      presets: {
        name: "الإعدادات المسبقة",
        description: "هناك عدد قليل من الإعدادات المسبقة التي تم تكوينها مسبقاً",
      },
      passingContent: {
        name: "محتوى عابر",
        description: "هناك عدة طرق مختلفة لتمرير المحتوى",
        viaTextProps: "عبر الدعامة 'text'- Billum In",
        children: "أولاد- Irure Reprehenderit",
        rightAccessory: "RightAccessory - Duis Quis",
        leftAccessory: "LeftAccessory - Duis Proident",
        nestedChildren: "الأطفال المتداخلون-\tprovident genial",
        nestedChildren2: "Ullamco cupidatat officia exercitation velit non ullamco nisi..",
        nestedChildren3: "Occaecat aliqua irure proident veniam.",
        multiLine:
          "Multiline - consequat veniam veniam reprehenderit. Fugiat id nisi quis duis sunt proident mollit dolor mollit adipisicing proident deserunt.",
      },
      styling: {
        name: "التصميم",
        description: "يمكن تصميم المكون بسهولة",
        styleContainer: "حاوية الأسلوب- الإثارة",
        styleText: "نص النمط- ِEa Anim",
        styleAccessories: "اكسسوارات الاناقة - enim ea id fugiat anim ad.",
        pressedState: "نمط الحالة المضغوطة - fugiat anim",
      },
      disabling: {
        name: "تعطيل",
        description: "يمكن تعطيل المكون، وتصميمه بناء على ذلك. سيتم تعطيل سلوك الضغط",
        standard: "إبطال - معيار",
        filled: "إبطال - مملوء",
        reversed: "إبطال- معكوس",
        accessory: "نمط الملحق المعطل",
        textStyle: "نمط النص المعطل",
      },
    },
  },
  demoListItem: {
    description: "مكون صف مصمم يمكن استخدامه في FlatList او SectionList او بمفرده",
    useCase: {
      height: {
        name: "علو",
        description: "يمكن ان يكون الصف بارتفاعات مختلفة",
        defaultHeight: "الارتفاع الافتراضي (56px)",
        customHeight: "ارتفاع مخصص عبر دعامة 'height'",
        textHeight:
          "الارتفاع يتم تحديده من خلال محتوى النص - Reprehenderit incididunt deserunt do do ea labore.",
        longText: "تحديد النص إلى سطر واحد - Reprehenderit incididunt deserunt do do ea labore.",
      },
      separators: {
        name: "الفواصل",
        description: "الفاصل/ المقسم مهيّأ مسبقاً وهو اختياري",
        topSeparator: "فقط فاصل علوي",
        topAndBottomSeparator: "الفواصل العلوية والسفلية",
        bottomSeparator: "فقط فاصل سفلي",
      },
      icons: {
        name: "الأيقونات",
        description: "يمكنك تخصيص الرموز على اليسار أو اليمين",
        leftIcon: "أيقونة اليسار",
        rightIcon: "أيقونة اليمين",
        leftRightIcons: "أيقونة اليمين واليسار",
      },
      customLeftRight: {
        name: "مكونات مخصصة لليسار /اليمين",
        description: "اذا كنت بحاجة إلى مخصص لليسار/اليمين فيمكنك تمريره",
        customLeft: "مكون يسار مخصص",
        customRight: "مكون يمين مخصص",
      },
      passingContent: {
        name: "محتوى عابر",
        description: "هناك عدة طرق مختلفة لتمرير المحتوى",
        text: "عبر دعامة 'text' - reprehenderit sint",
        children: "أولاد- mostrud mollit",
        nestedChildren1: "الأولاد المتداخلون - proident veniam.",
        nestedChildren2: "Ullamco cupidatat officia exercitation velit non ullamco nisi..",
      },
      listIntegration: {
        name: "دمج مع/ FlatList",
        description: "يمكن دمج المكون بسهولة مع واجهة القائمة المفضلة لديك",
      },
      styling: {
        name: "التصميم",
        description: "يمكن تصميم المكون بسهولة.",
        styledText: "نص مصمم",
        styledContainer: "حاوية مصممة (فواصل)",
        tintedIcons: "أيقونات ملونة",
      },
    },
  },
  demoCard: {
    description:
      "البطاقات مفيدة لعرض المعلومات ذات الصلة بطريقة محددة. اذا كان ListItem يعرض المحتوى أفقياً، فيمكن استخدام البطاقة لعرض المحتوى رأسياً.",
    useCase: {
      presets: {
        name: "الإعدادات المسبقة",
        description: "هناك عدد قليل من الإعدادات المسبقة التي تم تكوينها مسبقاً",
        default: {
          heading: "الأعداد المسبق الافتراضي ( تقصير)",
          content: "Incididunt magna ut aliquip consectetur mollit dolor.",
          footer: "Consectetur nulla non aliquip velit.",
        },
        reversed: {
          heading: "الأعداد المسبق المعكوس",
          content: "Reprehenderit occaecat proident amet id laboris.",
          footer: "Consectetur tempor ea non labore anim .",
        },
      },
      verticalAlignment: {
        name: "انحياز عمودي",
        description:
          "اعتمادا على ما هو مطلوب، تأتي البطاقة مهيأة مسبقاً باستراتيجيات محاذاة مختلفة",
        top: {
          heading: "قمة (تقصير)",
          content: "يتم محاذاة كل محتوى تلقائياً إلى الأعلى",
          footer: "حتى التذييل",
        },
        center: {
          heading: "مركز",
          content: "يتم تركيز المحتوى بالنسبة لارتفاع البطاقة",
          footer: "أنا ايضاً!",
        },
        spaceBetween: {
          heading: "مسافة بين الكلمات",
          content: "يتم توزيع جميع المحتويات بالتساوي",
          footer: "أنا حيث أريد ان أكون",
        },
        reversed: {
          heading: "Force Footer Bottom",
          content: "يؤدي هذا إلى دفع التذييل إلى المكان الذي ينتمي اليه.",
          footer: "أنا وحد جداًهنا",
        },
      },
      passingContent: {
        name: "محتوى عابر",
        description: "هناك عدة طرق مختلفة لتمرير المحتوى.",
        heading: "عبر دعم 'heading'",
        content: "عبر دعم 'content'",
        footer: "أنا وحيد هنا.",
      },
      customComponent: {
        name: "مكونات مخصصة",
        description:
          "يمكن استبدال اي من المكونات المعدة مسبقاً بمكوناتك الخاصة. يمكنك ايضاً اضافة مكونات إضافية.",
        rightComponent: "RightComponent",
        leftComponent: "LeftComponent",
      },
      style: {
        name: "التصميم",
        description: "يمكن تصميم المكون بسهولة.",
        heading: "صمم العنوان",
        content: "صمم المحتوى",
        footer: "صمم التذييل",
      },
    },
  },
  demoAutoImage: {
    description: "مكون صورة يحدد حجم الصورة البعيدة او صورة data-uri",
    useCase: {
      remoteUri: {
        name: "عن بعد URI",
      },
      base64Uri: {
        name: "Base64 URI",
      },
      scaledToFitDimensions: {
        name: "تم قياسها لتناسب الأبعاد",
        description:
          " توفيرعرض  'maxWidth' و\\او 'maxHeight' ، سيتم عرض الصورة بنسبة عرض الى ارتفاع. كيف يختلف هذا عن 'resizeMode': 'contain'? اولاً،يمكنك تحديد حجم جانب واحد فقط. (ليس كلاهما). ثانياً، سيتم تغيير الصورة لتناسب الأبعاد المطلوبة بدلاً من مجرد احتوائها داخل حاوية الصورة الخاصة بها.",
        heightAuto: " عرض : ٦٠ / طول:  auto",
        widthAuto: "عرض: auto / طول: ٣٢",
        bothManual: "عرض :٦٠ / طول : ٦٠",
      },
    },
  },
  demoText: {
    description:
      "لتلبية احتياجاتك في عرض النصوص. هذا المكون عبارة عن HOC فوق المكون المدمج Native React.",
    useCase: {
      presets: {
        name: "الإعدادات المسبقة",
        description: "هناك عدد قليل من الإعدادات المسبقة التي تم تكوينها مسبقاً.",
        default:
          "الأعداد المسبق الافتراضي - Cillum eu laboris in labore. Excepteur mollit tempor reprehenderit fugiat elit et eu consequat laborum.",
        bold: "bold preset - Tempor et ullamco cupidatat in officia. Nulla ea duis elit id sunt ipsum cillum duis deserunt nostrud ut nostrud id.",
        subheading: "subheading preset - In Cupidatat Cillum.",
        heading: "heading preset - Voluptate Adipis.",
      },
      sizes: {
        name: "قياسات",
        description: "هناك حجم الدعامة",
        xs: "xs - Ea ipsum est ea ex sunt.",
        sm: "sm - Lorem sunt adipisicin.",
        md: "md - Consequat id do lorem.",
        lg: "lg - Nostrud ipsum ea.",
        xl: "xl - Eiusmod ex excepteur.",
        xxl: "xxl - Cillum eu laboris.",
      },
      weights: {
        name: "أوزان",
        description: "هناك وزن الدعامة",
        light:
          "light - Nulla magna incididunt excepteur est occaecat duis culpa dolore cupidatat enim et.",
        normal:
          "normal - Magna incididunt dolor ut veniam veniam laboris aliqua velit ea incididunt.",
        medium: "medium - Non duis laborum quis laboris occaecat culpa cillum.",
        semibold: "semiBold - Exercitation magna nostrud pariatur laborum occaecat aliqua.",
        bold: "bold - Eiusmod ullamco magna exercitation est excepteur.",
      },
      passingContent: {
        name: "محتوى عابر",
        description: "هناك عدة طرق مختلفة لتمرير المحتوى.",
        viaText:
          "via `text` prop - Billum in aute fugiat proident nisi pariatur est. Cupidatat anim cillum eiusmod ad. Officia eu magna aliquip labore dolore consequat.",
        viaTx: "عبر دعامة 'tx'",
        children: "childrenreprehenderit eu qui amet veniam consectetur.",
        nestedChildren: "الأطفال المتداخلون",
        nestedChildren2: "Occaecat aliqua irure proident veniam.",
        nestedChildren3: "Ullamco cupidatat officia exercitation velit non ullamco nisi..",
        nestedChildren4: "Occaecat aliqua irure proident veniam.",
      },
      styling: {
        name: "التصميم",
        description: "يمكن تصميم المكون بسهولة.",
        text: "Consequat ullamco veniam velit mollit proident excepteur aliquip id culpa ipsum velit sint nostrud.",
        text2:
          "Eiusmod occaecat laboris eu ex veniam ipsum adipisicing consectetur. Magna ullamco adipisicing tempor adipisicing.",
        text3:
          "Eiusmod occaecat laboris eu ex veniam ipsum adipisicing consectetur. Magna ullamco adipisicing tempor adipisicing.",
      },
    },
  },
  demoHeader: {
    description: "المكون الذي يظهر على العديد من الشاشات، سيحمل ازرار التنقل وعنوان الشاشة.",
    useCase: {
      actionIcons: {
        name: "أيقونة الإجرائات ",
        description: "يمكنك بسهولة تمرير الرموزالى مكونات الاجراء اليسرى او اليمنى.",
        leftIconTitle: "الرمز الأيسر",
        rightIconTitle: "الرمز الأيمن ",
        bothIconsTitle: "كلا الرمزين",
      },
      actionText: {
        name: "نص العمل",
        description: "يمكنك بسهولة تمرير النص الى مكونات الاجراء اليسرى او اليمنى.",
        leftTxTitle: "عبر 'leftTx' ",
        rightTextTitle: "عبر `rightText`",
      },
      customActionComponents: {
        name: "مكونات الاجراء المخصص",
        description:
          "اذا لم تكن خيارات الرمز او النسكافية، فيمكنك تمرير مكون الاجراء المخصص الخاص بك.",
        customLeftActionTitle: "عمل يسار مخصص ",
      },
      titleModes: {
        name: "اوضاع العنوان",
        description:
          "يمكن اجبار العنوان على البقاء غي المنتصف ولكن قد يتم قطعه اذا كان طويلاً للغاية. يمكنك بشكل اختياري تعديله وفقاً لأزرار الإجراء.",
        centeredTitle: "عنوان مركزي",
        flexTitle: "عنوان مرن",
      },
      styling: {
        name: "التصميم",
        description: "يمكن تصميم المكون بسهولة",
        styledTitle: "عنوان مصمم",
        styledWrapperTitle: "غلاف مصمم",
        tintedIconsTitle: "أيقونات ملونة",
      },
    },
  },
  demoEmptyState: {
    description:
      "مكون يتم استخدامه عندما لا يكون هناك بيانات لعرضها. ويمكن استخدامه لتوجيه المستخدم الى ما يجب فعله بعد ذلك.",
    useCase: {
      presets: {
        name: "الإعدادات المسبقة",
        description:
          "يمكن إنشاء نص/صورة مختلفة مجموعات. واحد محدد مسبقاً يسمى 'generic'. لاحظ انه لا يوجد اي خيار افتراضي في حال رغبتك في الحصول على كامل  EmptyState مخصصة.",
      },
      passingContent: {
        name: "محتوى عابر",
        description: "هناك عدة طرق مختلفة لتمرير المحتوى.",
        customizeImageHeading: "تخصيص الصورة",
        customizeImageContent: "يمكنك تمرير اي مصدر للصورة",
        viaHeadingProp: "عبر دعامة 'heading'",
        viaContentProp: "عبر دعامة 'content'",
        viaButtonProp: "عبر دعامة 'button'",
      },
      styling: {
        name: "التصميم",
        description: "يمكن تصميم المكون بسهولة.",
      },
    },
  },
}

export default demoAr

// @demo remove-file
===== END FILE: app/i18n/demo-ar.ts =====


===== BEGIN FILE: app/i18n/mr.ts =====
const mr = {
  common: {
    ok: "ठीक आहे",
    cancel: "रद्द",
    back: "मागे",
    save: "जतन करा",
    submit: "सबमिट",
    accept: "स्वीकारा",
    reject: "नाकार",
  },
  oolshik: {
    nearbyTasks: "जवळील कामे",
    create: "काम सांगा",
    appName: "ऊलशिक",
    home: "होम",
    feed: "जवळील कामे",
    createTask: "काम तयार करा",
    taskDetail: "काम तपशील",
    myTasks: "माझी कामे",
    chat: "चॅट",
    profile: "प्रोफाइल",
    report: "तक्रार",
    radius: "परिघ (कि.मी.)",
    radius1: "१ कि.मी.",
    radius2: "२ कि.मी.",
    radius5: "५ कि.मी.",
    descriptionOptional: "थोडक्यात मजकूर (ऐच्छिक)",
    recordAudio: "आवाज रेकॉर्ड करा (≤ 30s)",
    stop: "थांबवा",
    play: "प्ले",
    submitTask: "काम पोस्ट करा",
    locationPermissionTitle: "स्थान परवानगी",
    locationPermissionMsg: "जवळील कामे दिसण्यासाठी आम्हाला फक्त अग्रभूमी स्थानाची परवानगी हवी आहे.",
    allow: "परवानगी द्या",
    language: "भाषा",
    marathi: "मराठी",
    english: "इंग्रजी",
    consentTitle: "अटी व स्थान वापर",
    consentAgree: "मी सहमत आहे",
    rating: "रेटिंग",
    completeTask: "पूर्ण म्हणून चिन्हांकित करा",
    acceptTask: "स्वीकारा",
    alreadyAssigned: "आधीच नेमणूक झाले",
    distanceAway: "{{km}} कि.मी. अंतरावर",
    emptyNearby: "सध्या जवळ कोणतीही कामे नाहीत — मोठा परिघ निवडा.",
    nearbyForYouHeader: "तुमच्यासाठी जवळील",
    myRequestsHeader: "माझ्या विनंत्या",
    tabForYou: "तुमच्यासाठी",
    tabMyRequests: "माझ्या विनंत्या",
    emptyForYou: "सध्या जवळ कोणतीही विनंत्या नाहीत.",
    emptyMine: "तुम्ही अजून कोणतीही विनंत्या तयार केलेल्या नाहीत.",
    distanceFilter: "अंतर",
    statusFilter: "स्थिती",
    yourExperience: "तुमचा अनुभव",
    leftRightExperience: "(डावीकडे वाईट • उजवीकडे उत्तम)",
    ratingBad: "वाईट",
    ratingPoor: "ठीक नाही",
    ratingOkay: "सरासरी",
    ratingGood: "चांगले",
    ratingGreat: "उत्तम",
  },
}
export default mr
===== END FILE: app/i18n/mr.ts =====


===== BEGIN FILE: app/i18n/demo-hi.ts =====
import { DemoTranslations } from "./demo-en"

export const demoHi: DemoTranslations = {
  demoIcon: {
    description:
      "एक पंजीकृत आइकन को रेंडर करने के लिए एक कंपोनेंट। यदि `onPress` प्रदान किया जाता है तो यह <TouchableOpacity /> में लपेटा जाता है, अन्यथा <View /> में।",
    useCase: {
      icons: {
        name: "आइकन",
        description: "कंपोनेंट के अंदर पंजीकृत आइकनों की सूची।",
      },
      size: {
        name: "आकार",
        description: "एक आकार प्रॉप है।",
      },
      color: {
        name: "रंग",
        description: "एक रंग प्रॉप है।",
      },
      styling: {
        name: "स्टाइलिंग",
        description: "कंपोनेंट को आसानी से स्टाइल किया जा सकता है।",
      },
    },
  },
  demoTextField: {
    description: "टेक्स्टफील्ड कंपोनेंट टेक्स्ट दर्ज करने और संपादित करने की अनुमति देता है।",
    useCase: {
      statuses: {
        name: "स्थितियाँ",
        description:
          "एक स्थिति प्रॉप है - अन्य कंपोनेंट्स में `preset` के समान, लेकिन कंपोनेंट की कार्यक्षमता को भी प्रभावित करता है।",
        noStatus: {
          label: "कोई स्थिति नहीं",
          helper: "यह डिफ़ॉल्ट स्थिति है",
          placeholder: "टेक्स्ट यहाँ जाता है",
        },
        error: {
          label: "त्रुटि स्थिति",
          helper: "त्रुटि होने पर उपयोग करने के लिए स्थिति",
          placeholder: "टेक्स्ट यहाँ जाता है",
        },
        disabled: {
          label: "अक्षम स्थिति",
          helper: "संपादन को अक्षम करता है और टेक्स्ट को मंद करता है",
          placeholder: "टेक्स्ट यहाँ जाता है",
        },
      },
      passingContent: {
        name: "सामग्री पास करना",
        description: "सामग्री पास करने के कई तरीके हैं।",
        viaLabel: {
          labelTx: "`label` प्रॉप के माध्यम से",
          helper: "`helper` प्रॉप के माध्यम से",
          placeholder: "`placeholder` प्रॉप के माध्यम से",
        },
        rightAccessory: {
          label: "दायाँ सहायक",
          helper: "यह प्रॉप एक फ़ंक्शन लेता है जो एक React तत्व लौटाता है।",
        },
        leftAccessory: {
          label: "बायाँ सहायक",
          helper: "यह प्रॉप एक फ़ंक्शन लेता है जो एक React तत्व लौटाता है।",
        },
        supportsMultiline: {
          label: "मल्टीलाइन का समर्थन करता है",
          helper: "मल्टीलाइन टेक्स्ट के लिए एक लंबा इनपुट सक्षम करता है।",
        },
      },
      styling: {
        name: "स्टाइलिंग",
        description: "कंपोनेंट को आसानी से स्टाइल किया जा सकता है।",
        styleInput: {
          label: "इनपुट स्टाइल",
          helper: "`style` प्रॉप के माध्यम से",
        },
        styleInputWrapper: {
          label: "इनपुट रैपर स्टाइल",
          helper: "`inputWrapperStyle` प्रॉप के माध्यम से",
        },
        styleContainer: {
          label: "कंटेनर स्टाइल",
          helper: "`containerStyle` प्रॉप के माध्यम से",
        },
        styleLabel: {
          label: "लेबल और हेल्पर स्टाइल",
          helper: "`LabelTextProps` और `HelperTextProps` स्टाइल प्रॉप के माध्यम से",
        },
        styleAccessories: {
          label: "सहायक स्टाइल",
          helper: "`RightAccessory` और `LeftAccessory` स्टाइल प्रॉप के माध्यम से",
        },
      },
    },
  },
  demoToggle: {
    description:
      "एक बूलियन इनपुट रेंडर करता है। यह एक नियंत्रित कंपोनेंट है जिसे उपयोगकर्ता क्रियाओं को दर्शाने के लिए value प्रॉप को अपडेट करने वाले onValueChange कॉलबैक की आवश्यकता होती है। यदि value प्रॉप अपडेट नहीं की जाती है, तो कंपोनेंट उपयोगकर्ता क्रियाओं के अपेक्षित परिणाम के बजाय आपूर्ति की गई value प्रॉप को रेंडर करना जारी रखेगा।",
    useCase: {
      variants: {
        name: "विविधताएँ",
        description:
          "कंपोनेंट कुछ अलग-अलग विविधताओं का समर्थन करता है। यदि किसी विशिष्ट विविधता के भारी अनुकूलन की आवश्यकता है, तो इसे आसानी से पुनर्गठित किया जा सकता है। डिफ़ॉल्ट `checkbox` है।",
        checkbox: {
          label: "`checkbox` विविधता",
          helper: "इसका उपयोग एकल चालू/बंद इनपुट के लिए किया जा सकता है।",
        },
        radio: {
          label: "`radio` विविधता",
          helper: "जब आपके पास कई विकल्प हों तो इसका उपयोग करें।",
        },
        switch: {
          label: "`switch` विविधता",
          helper: "एक अधिक प्रमुख चालू/बंद इनपुट। बेहतर पहुँच समर्थन है।",
        },
      },
      statuses: {
        name: "स्थितियाँ",
        description:
          "एक स्थिति प्रॉप है - अन्य कंपोनेंट्स में `preset` के समान, लेकिन कंपोनेंट की कार्यक्षमता को भी प्रभावित करता है।",
        noStatus: "कोई स्थिति नहीं - यह डिफ़ॉल्ट है",
        errorStatus: "त्रुटि स्थिति - जब कोई त्रुटि हो तो उपयोग करें",
        disabledStatus: "अक्षम स्थिति - संपादन को अक्षम करता है और इनपुट को मंद करता है",
      },
      passingContent: {
        name: "सामग्री पास करना",
        description: "सामग्री पास करने के कई तरीके हैं।",
        useCase: {
          checkBox: {
            label: "`labelTx` प्रॉप के माध्यम से",
            helper: "`helperTx` प्रॉप के माध्यम से।",
          },
          checkBoxMultiLine: {
            helper:
              "मल्टीलाइन का समर्थन करता है - Nulla proident consectetur labore sunt ea labore. ",
          },
          radioChangeSides: {
            helper: "आप पक्ष बदल सकते हैं - Laborum labore adipisicing in eu ipsum deserunt.",
          },
          customCheckBox: {
            label: "एक कस्टम चेकबॉक्स आइकन पास करें।",
          },
          switch: {
            label: "स्विच को टेक्स्ट के रूप में पढ़ा जा सकता है",
            helper:
              "डिफ़ॉल्ट रूप से, यह विकल्प `Text` का उपयोग नहीं करता है क्योंकि फ़ॉन्ट के आधार पर, चालू/बंद अक्षर अजीब दिख सकते हैं। आवश्यकतानुसार अनुकूलित करें।",
          },
          switchAid: {
            label: "या एक आइकन की मदद से",
          },
        },
      },
      styling: {
        name: "स्टाइलिंग",
        description: "कंपोनेंट को आसानी से स्टाइल किया जा सकता है।",
        outerWrapper: "1 - इनपुट के बाहरी रैपर को स्टाइल करें",
        innerWrapper: "2 - इनपुट के आंतरिक रैपर को स्टाइल करें",
        inputDetail: "3 - इनपुट विवरण को स्टाइल करें",
        labelTx: "आप labelTx को भी स्टाइल कर सकते हैं",
        styleContainer: "या, पूरे कंटेनर को स्टाइल करें",
      },
    },
  },
  demoButton: {
    description:
      "एक कंपोनेंट जो उपयोगकर्ताओं को कार्रवाई करने और विकल्प चुनने की अनुमति देता है। Text कंपोनेंट को Pressable कंपोनेंट के साथ लपेटता है।",
    useCase: {
      presets: {
        name: "प्रीसेट",
        description: "कुछ पूर्व-कॉन्फ़िगर किए गए प्रीसेट हैं।",
      },
      passingContent: {
        name: "सामग्री पास करना",
        description: "सामग्री पास करने के कई तरीके हैं।",
        viaTextProps: "`text` प्रॉप के माध्यम से - Billum In",
        children: "चिल्ड्रन - Irure Reprehenderit",
        rightAccessory: "दायां एक्सेसरी - Duis Quis",
        leftAccessory: "बायां एक्सेसरी - Duis Proident",
        nestedChildren: "नेस्टेड चिल्ड्रन - proident veniam.",
        nestedChildren2: "Ullamco cupidatat officia exercitation velit non ullamco nisi..",
        nestedChildren3: "Occaecat aliqua irure proident veniam.",
        multiLine:
          "मल्टीलाइन - consequat veniam veniam reprehenderit. Fugiat id nisi quis duis sunt proident mollit dolor mollit adipisicing proident deserunt.",
      },
      styling: {
        name: "स्टाइलिंग",
        description: "कंपोनेंट को आसानी से स्टाइल किया जा सकता है।",
        styleContainer: "कंटेनर स्टाइल - Exercitation",
        styleText: "टेक्स्ट स्टाइल - Ea Anim",
        styleAccessories: "एक्सेसरीज़ स्टाइल - enim ea id fugiat anim ad.",
        pressedState: "दबाए गए स्थिति का स्टाइल - fugiat anim",
      },
      disabling: {
        name: "अक्षम करना",
        description:
          "कंपोनेंट को अक्षम किया जा सकता है और उसके आधार पर स्टाइल किया जा सकता है। दबाने का व्यवहार अक्षम हो जाएगा।",
        standard: "अक्षम - मानक",
        filled: "अक्षम - भरा हुआ",
        reversed: "अक्षम - उलटा",
        accessory: "अक्षम एक्सेसरी स्टाइल",
        textStyle: "अक्षम टेक्स्ट स्टाइल",
      },
    },
  },
  demoListItem: {
    description:
      "एक स्टाइल किया गया पंक्ति कंपोनेंट जो FlatList, SectionList, या अकेले उपयोग किया जा सकता है।",
    useCase: {
      height: {
        name: "ऊँचाई",
        description: "पंक्ति की विभिन्न ऊँचाइयाँ हो सकती हैं।",
        defaultHeight: "डिफ़ॉल्ट ऊँचाई (56px)",
        customHeight: "`height` प्रॉप के माध्यम से कस्टम ऊँचाई",
        textHeight:
          "टेक्स्ट सामग्री द्वारा निर्धारित ऊँचाई - Reprehenderit incididunt deserunt do do ea labore.",
        longText:
          "लंबे टेक्स्ट को एक पंक्ति तक सीमित करें - Reprehenderit incididunt deserunt do do ea labore.",
      },
      separators: {
        name: "विभाजक",
        description: "विभाजक / डिवाइडर पूर्व-कॉन्फ़िगर किया गया है और वैकल्पिक है।",
        topSeparator: "केवल ऊपरी विभाजक",
        topAndBottomSeparator: "ऊपरी और निचले विभाजक",
        bottomSeparator: "केवल निचला विभाजक",
      },
      icons: {
        name: "आइकन",
        description: "आप बाएँ या दाएँ आइकन को कस्टमाइज़ कर सकते हैं।",
        leftIcon: "बायाँ आइकन",
        rightIcon: "दायाँ आइकन",
        leftRightIcons: "बाएँ और दाएँ आइकन",
      },
      customLeftRight: {
        name: "कस्टम बायाँ/दायाँ कंपोनेंट",
        description:
          "यदि आपको कस्टम बायाँ/दायाँ कंपोनेंट की आवश्यकता है, तो आप इसे पास कर सकते हैं।",
        customLeft: "कस्टम बायाँ कंपोनेंट",
        customRight: "कस्टम दायाँ कंपोनेंट",
      },
      passingContent: {
        name: "सामग्री पास करना",
        description: "सामग्री पास करने के कई तरीके हैं।",
        text: "`text` प्रॉप के माध्यम से - reprehenderit sint",
        children: "चिल्ड्रन - mostrud mollit",
        nestedChildren1: "नेस्टेड चिल्ड्रन - proident veniam.",
        nestedChildren2: "Ullamco cupidatat officia exercitation velit non ullamco nisi..",
      },
      listIntegration: {
        name: "FlatList के साथ एकीकरण",
        description:
          "कंपोनेंट को आसानी से आपके पसंदीदा सूची इंटरफेस के साथ एकीकृत किया जा सकता है।",
      },
      styling: {
        name: "स्टाइलिंग",
        description: "कंपोनेंट को आसानी से स्टाइल किया जा सकता है।",
        styledText: "स्टाइल किया गया टेक्स्ट",
        styledContainer: "स्टाइल किया गया कंटेनर (विभाजक)",
        tintedIcons: "रंगीन आइकन",
      },
    },
  },
  demoCard: {
    description:
      "कार्ड संबंधित जानकारी को एक संयमित तरीके से प्रदर्शित करने के लिए उपयोगी हैं। यदि एक ListItem सामग्री को क्षैतिज रूप से प्रदर्शित करता है, तो एक कार्ड का उपयोग सामग्री को लंबवत रूप से प्रदर्शित करने के लिए किया जा सकता है।",
    useCase: {
      presets: {
        name: "प्रीसेट",
        description: "कुछ पूर्व-कॉन्फ़िगर किए गए प्रीसेट हैं।",
        default: {
          heading: "डिफ़ॉल्ट प्रीसेट (डिफ़ॉल्ट)",
          content: "Incididunt magna ut aliquip consectetur mollit dolor.",
          footer: "Consectetur nulla non aliquip velit.",
        },
        reversed: {
          heading: "रिवर्स्ड प्रीसेट",
          content: "Reprehenderit occaecat proident amet id laboris.",
          footer: "Consectetur tempor ea non labore anim .",
        },
      },
      verticalAlignment: {
        name: "ऊर्ध्वाधर संरेखण",
        description:
          "आवश्यकता के अनुसार, कार्ड विभिन्न संरेखण रणनीतियों के साथ पूर्व-कॉन्फ़िगर किया गया है।",
        top: {
          heading: "शीर्ष (डिफ़ॉल्ट)",
          content: "सभी सामग्री स्वचालित रूप से शीर्ष पर संरेखित होती है।",
          footer: "यहां तक कि फुटर भी",
        },
        center: {
          heading: "मध्य",
          content: "सामग्री कार्ड की ऊंचाई के सापेक्ष केंद्रित होती है।",
          footer: "मैं भी!",
        },
        spaceBetween: {
          heading: "स्पेस बिटवीन",
          content: "सभी सामग्री समान रूप से फैली हुई है।",
          footer: "मैं वहां हूं जहां मैं होना चाहता हूं।",
        },
        reversed: {
          heading: "फुटर को नीचे रखें",
          content: "यह फुटर को उसके सही स्थान पर धकेलता है।",
          footer: "मैं यहां नीचे बहुत अकेला हूं।",
        },
      },
      passingContent: {
        name: "सामग्री पास करना",
        description: "सामग्री पास करने के कई तरीके हैं।",
        heading: "`heading` प्रॉप के माध्यम से",
        content: "`content` प्रॉप के माध्यम से",
        footer: "मैं यहां नीचे बहुत अकेला हूं।",
      },
      customComponent: {
        name: "कस्टम कंपोनेंट्स",
        description:
          "किसी भी पूर्व-कॉन्फ़िगर किए गए कंपोनेंट को आपके अपने कंपोनेंट से बदला जा सकता है। आप अतिरिक्त कंपोनेंट भी जोड़ सकते हैं।",
        rightComponent: "दायाँ कंपोनेंट",
        leftComponent: "बायाँ कंपोनेंट",
      },
      style: {
        name: "स्टाइलिंग",
        description: "कंपोनेंट को आसानी से स्टाइल किया जा सकता है।",
        heading: "शीर्षक को स्टाइल करें",
        content: "सामग्री को स्टाइल करें",
        footer: "फुटर को स्टाइल करें",
      },
    },
  },
  demoAutoImage: {
    description:
      "एक छवि कंपोनेंट जो स्वचालित रूप से रिमोट या डेटा-यूआरआई छवि का आकार निर्धारित करता है।",
    useCase: {
      remoteUri: { name: "रिमोट यूआरआई" },
      base64Uri: { name: "बेस64 यूआरआई" },
      scaledToFitDimensions: {
        name: "आयामों के अनुरूप स्केल किया गया",
        description:
          "`maxWidth` और/या `maxHeight` प्रॉप्स प्रदान करने पर, छवि स्वचालित रूप से अपने आस्पेक्ट अनुपात को बनाए रखते हुए स्केल होगी। यह `resizeMode: 'contain'` से कैसे अलग है? पहला, आप केवल एक तरफ का आकार निर्दिष्ट कर सकते हैं (दोनों नहीं)। दूसरा, छवि वांछित आयामों के अनुरूप स्केल होगी, न कि केवल अपने छवि-कंटेनर के भीतर समाहित होगी।",
        heightAuto: "चौड़ाई: 60 / ऊंचाई: स्वचालित",
        widthAuto: "चौड़ाई: स्वचालित / ऊंचाई: 32",
        bothManual: "चौड़ाई: 60 / ऊंचाई: 60",
      },
    },
  },
  demoText: {
    description:
      "आपकी टेक्स्ट प्रदर्शन आवश्यकताओं के लिए। यह कंपोनेंट अंतर्निहित React Native कंपोनेंट पर एक HOC है।",
    useCase: {
      presets: {
        name: "प्रीसेट",
        description: "कुछ पूर्व-कॉन्फ़िगर किए गए प्रीसेट हैं।",
        default:
          "डिफ़ॉल्ट प्रीसेट - Cillum eu laboris in labore. Excepteur mollit tempor reprehenderit fugiat elit et eu consequat laborum.",
        bold: "बोल्ड प्रीसेट - Tempor et ullamco cupidatat in officia. Nulla ea duis elit id sunt ipsum cillum duis deserunt nostrud ut nostrud id.",
        subheading: "सबहेडिंग प्रीसेट - In Cupidatat Cillum.",
        heading: "हेडिंग प्रीसेट - Voluptate Adipis.",
      },
      sizes: {
        name: "आकार",
        description: "एक आकार प्रॉप है।",
        xs: "xs - Ea ipsum est ea ex sunt.",
        sm: "sm - Lorem sunt adipisicin.",
        md: "md - Consequat id do lorem.",
        lg: "lg - Nostrud ipsum ea.",
        xl: "xl - Eiusmod ex excepteur.",
        xxl: "xxl - Cillum eu laboris.",
      },
      weights: {
        name: "वजन",
        description: "एक वजन प्रॉप है।",
        light:
          "लाइट - Nulla magna incididunt excepteur est occaecat duis culpa dolore cupidatat enim et.",
        normal:
          "सामान्य - Magna incididunt dolor ut veniam veniam laboris aliqua velit ea incididunt.",
        medium: "मध्यम - Non duis laborum quis laboris occaecat culpa cillum.",
        semibold: "सेमीबोल्ड - Exercitation magna nostrud pariatur laborum occaecat aliqua.",
        bold: "बोल्ड - Eiusmod ullamco magna exercitation est excepteur.",
      },
      passingContent: {
        name: "सामग्री पास करना",
        description: "सामग्री पास करने के कई तरीके हैं।",
        viaText:
          "`text` प्रॉप के माध्यम से - Billum in aute fugiat proident nisi pariatur est. Cupidatat anim cillum eiusmod ad. Officia eu magna aliquip labore dolore consequat.",
        viaTx: "`tx` प्रॉप के माध्यम से -",
        children: "चिल्ड्रन - Aliqua velit irure reprehenderit eu qui amet veniam consectetur.",
        nestedChildren: "नेस्टेड चिल्ड्रन -",
        nestedChildren2: "Occaecat aliqua irure proident veniam.",
        nestedChildren3: "Ullamco cupidatat officia exercitation velit non ullamco nisi..",
        nestedChildren4: "Occaecat aliqua irure proident veniam.",
      },
      styling: {
        name: "स्टाइलिंग",
        description: "कंपोनेंट को आसानी से स्टाइल किया जा सकता है।",
        text: "Consequat ullamco veniam velit mollit proident excepteur aliquip id culpa ipsum velit sint nostrud.",
        text2:
          "Eiusmod occaecat laboris eu ex veniam ipsum adipisicing consectetur. Magna ullamco adipisicing tempor adipisicing.",
        text3:
          "Eiusmod occaecat laboris eu ex veniam ipsum adipisicing consectetur. Magna ullamco adipisicing tempor adipisicing.",
      },
    },
  },
  demoHeader: {
    description:
      "कई स्क्रीन पर दिखाई देने वाला कंपोनेंट। यह नेविगेशन बटन और स्क्रीन शीर्षक धारण करेगा।",
    useCase: {
      actionIcons: {
        name: "एक्शन आइकन",
        description: "आप आसानी से बाएँ या दाएँ एक्शन कंपोनेंट्स में आइकन पास कर सकते हैं।",
        leftIconTitle: "बायाँ आइकन",
        rightIconTitle: "दायाँ आइकन",
        bothIconsTitle: "दोनों आइकन",
      },
      actionText: {
        name: "एक्शन टेक्स्ट",
        description: "आप आसानी से बाएँ या दाएँ एक्शन कंपोनेंट्स में टेक्स्ट पास कर सकते हैं।",
        leftTxTitle: "`leftTx` के माध्यम से",
        rightTextTitle: "`rightText` के माध्यम से",
      },
      customActionComponents: {
        name: "कस्टम एक्शन कंपोनेंट्स",
        description:
          "यदि आइकन या टेक्स्ट विकल्प पर्याप्त नहीं हैं, तो आप अपना खुद का कस्टम एक्शन कंपोनेंट पास कर सकते हैं।",
        customLeftActionTitle: "कस्टम बायाँ एक्शन",
      },
      titleModes: {
        name: "शीर्षक मोड",
        description:
          "शीर्षक को मध्य में रहने के लिए मजबूर किया जा सकता है (डिफ़ॉल्ट) लेकिन यदि यह बहुत लंबा है तो काटा जा सकता है। वैकल्पिक रूप से आप इसे एक्शन बटनों के अनुसार समायोजित कर सकते हैं।",
        centeredTitle: "केंद्रित शीर्षक",
        flexTitle: "फ्लेक्स शीर्षक",
      },
      styling: {
        name: "स्टाइलिंग",
        description: "कंपोनेंट को आसानी से स्टाइल किया जा सकता है।",
        styledTitle: "स्टाइल किया गया शीर्षक",
        styledWrapperTitle: "स्टाइल किया गया रैपर",
        tintedIconsTitle: "रंगीन आइकन",
      },
    },
  },
  demoEmptyState: {
    description:
      "जब प्रदर्शित करने के लिए कोई डेटा नहीं है तो उपयोग करने के लिए एक कंपोनेंट। इसका उपयोग उपयोगकर्ता को अगला क्या करना है, यह निर्देशित करने के लिए किया जा सकता है।",
    useCase: {
      presets: {
        name: "प्रीसेट",
        description:
          "आप विभिन्न टेक्स्ट/छवि सेट बना सकते हैं। एक पूर्व-परिभाषित है जिसे `generic` कहा जाता है। ध्यान दें, कोई डिफ़ॉल्ट नहीं है यदि आप पूरी तरह से कस्टम EmptyState चाहते हैं।",
      },
      passingContent: {
        name: "सामग्री पास करना",
        description: "सामग्री पास करने के कई तरीके हैं।",
        customizeImageHeading: "छवि को अनुकूलित करें",
        customizeImageContent: "आप कोई भी छवि स्रोत पास कर सकते हैं।",
        viaHeadingProp: "`heading` प्रॉप के माध्यम से",
        viaContentProp: "`content` प्रॉप के माध्यम से।",
        viaButtonProp: "`button` प्रॉप के माध्यम से",
      },
      styling: {
        name: "स्टाइलिंग",
        description: "कंपोनेंट को आसानी से स्टाइल किया जा सकता है।",
      },
    },
  },
}

export default demoHi

// @demo remove-file
===== END FILE: app/i18n/demo-hi.ts =====


===== BEGIN FILE: app/i18n/demo-fr.ts =====
import { DemoTranslations } from "./demo-en"

export const demoFr: DemoTranslations = {
  demoIcon: {
    description:
      "Un composant pour faire le rendu d’une icône enregistrée. Il est enveloppé dans un <TouchableOpacity /> si `onPress` est fourni, sinon dans une <View />.",
    useCase: {
      icons: {
        name: "Icônes",
        description: "Liste des icônes enregistrées dans le composant.",
      },
      size: {
        name: "Taille",
        description: "Il y a une prop de taille.",
      },
      color: {
        name: "Couleur",
        description: "Il y a une prop de couleur.",
      },
      styling: {
        name: "Style",
        description: "Le composant peut être facilement stylisé.",
      },
    },
  },
  demoTextField: {
    description: "Le composant <TextField /> permet la saisie et l'édition de texte.",
    useCase: {
      statuses: {
        name: "Statuts",
        description:
          "Il y a une prop de statut - similaire à `preset` dans d'autres composants, mais affecte également la fonctionnalité du composant.",
        noStatus: {
          label: "Pas de statut",
          helper: "C'est le statut par défaut",
          placeholder: "Le texte passe par là",
        },
        error: {
          label: "Statut d'erreur",
          helper: "Statut à utiliser en cas d’erreur",
          placeholder: "Le texte passe par ici",
        },
        disabled: {
          label: "Statut désactivé",
          helper: "Désactive l’édition et atténue le texte",
          placeholder: "Le texte repasse par là",
        },
      },
      passingContent: {
        name: "Transfert de contenu",
        description: "Il y a plusieurs façons de transmettre du contenu.",
        viaLabel: {
          labelTx: "Via la prop `label`",
          helper: "Via la prop `helper`",
          placeholder: "Via la prop `placeholder`",
        },
        rightAccessory: {
          label: "Accessoire droit",
          helper: "Cette prop demande une fonction qui retourne un élément React.",
        },
        leftAccessory: {
          label: "Accessoire gauche",
          helper: "Cette prop demande une fonction qui retourne un élément React.",
        },
        supportsMultiline: {
          label: "Supporte le multiligne",
          helper: "Permet une saisie plus longue pour le texte multiligne.",
        },
      },
      styling: {
        name: "Style",
        description: "Le composant peut être facilement stylisé.",
        styleInput: {
          label: "Style de saisie",
          helper: "Via la prop `style`",
        },
        styleInputWrapper: {
          label: "Style du wrapper de saisie",
          helper: "Via la prop `inputWrapperStyle`",
        },
        styleContainer: {
          label: "Style du conteneur",
          helper: "Via la prop `containerStyle`",
        },
        styleLabel: {
          label: "Style du label et de l’aide",
          helper: "Via les props de style `LabelTextProps` et `HelperTextProps`",
        },
        styleAccessories: {
          label: "Style des accessoires",
          helper: "Via les props de style `RightAccessory` et `LeftAccessory`",
        },
      },
    },
  },
  demoToggle: {
    description:
      "Fait le rendu d’un booléen. Ce composant contrôlé nécessite un callback `onValueChange` qui met à jour la prop `value` pour que le composant reflète les actions de l'utilisateur. Si la prop `value` n'est pas mise à jour, le composant continuera à rendre la prop `value` fournie au lieu du résultat attendu des actions de l'utilisateur.",
    useCase: {
      variants: {
        name: "Variantes",
        description:
          "Le composant supporte différentes variantes. Si une personnalisation poussée d'une variante spécifique est nécessaire, elle peut être facilement refactorisée. La valeur par défaut est `checkbox`.",
        checkbox: {
          label: "Variante `checkbox`",
          helper: "Peut être utilisée pour une seule valeure on/off.",
        },
        radio: {
          label: "Variante `radio`",
          helper: "Utilisez ceci quand vous avez plusieurs options.",
        },
        switch: {
          label: "Variante `switch`",
          helper:
            "Une entrée on/off plus proéminente. Possède un meilleur support d’accessibilité.",
        },
      },
      statuses: {
        name: "Statuts",
        description:
          "Il y a une prop de statut - similaire à `preset` dans d'autres composants, mais affecte également la fonctionnalité du composant.",
        noStatus: "Pas de statut - c'est le défaut",
        errorStatus: "Statut d’erreur - à utiliser quand il y a une erreur",
        disabledStatus: "Statut désactivé - désactive l’édition et atténue le style",
      },
      passingContent: {
        name: "Transfert de contenu",
        description: "Il y a plusieurs façons de transmettre du contenu.",
        useCase: {
          checkBox: {
            label: "Via la prop `labelTx`",
            helper: "Via la prop `helperTx`.",
          },
          checkBoxMultiLine: {
            helper: "Supporte le multiligne - Nulla proident consectetur labore sunt ea labore. ",
          },
          radioChangeSides: {
            helper:
              "Vous pouvez changer de côté - Laborum labore adipisicing in eu ipsum deserunt.",
          },
          customCheckBox: {
            label: "Passez une icône de case à cocher personnalisée.",
          },
          switch: {
            label: "Les interrupteurs peuvent être lus comme du texte",
            helper:
              "Par défaut, cette option n’utilise pas `Text` car selon la police, les caractères on/off pourraient paraître étranges. Personnalisez selon vos besoins.",
          },
          switchAid: {
            label: "Ou aidé d’une icône",
          },
        },
      },
      styling: {
        name: "Style",
        description: "Le composant peut être facilement stylisé.",
        outerWrapper: "1 - styliser le wrapper extérieur de l’entrée",
        innerWrapper: "2 - styliser le wrapper intérieur de l’entrée",
        inputDetail: "3 - styliser le détail de l’entrée",
        labelTx: "Vous pouvez aussi styliser le labelTx",
        styleContainer: "Ou, styliser le conteneur entier",
      },
    },
  },
  demoButton: {
    description:
      "Un composant qui permet aux utilisateurs d’effectuer des actions et de faire des choix. Enveloppe le composant Text avec un composant Pressable.",
    useCase: {
      presets: {
        name: "Préréglages",
        description: "Il y a quelques préréglages préconfigurés.",
      },
      passingContent: {
        name: "Transfert de contenu",
        description: "Il y a plusieurs façons de transmettre du contenu.",
        viaTextProps: "Via la prop `text` - Billum In",
        children: "Enfants - Irure Reprehenderit",
        rightAccessory: "Accessoire droit - Duis Quis",
        leftAccessory: "Accessoire gauche - Duis Proident",
        nestedChildren: "Enfants imbriqués - proident veniam.",
        nestedChildren2: "Ullamco cupidatat officia exercitation velit non ullamco nisi..",
        nestedChildren3: "Occaecat aliqua irure proident veniam.",
        multiLine:
          "Multiligne - consequat veniam veniam reprehenderit. Fugiat id nisi quis duis sunt proident mollit dolor mollit adipisicing proident deserunt.",
      },
      styling: {
        name: "Style",
        description: "Le composant peut être facilement stylisé.",
        styleContainer: "Style du conteneur - Exercitation",
        styleText: "Style du texte - Ea Anim",
        styleAccessories: "Style des accessoires - enim ea id fugiat anim ad.",
        pressedState: "Style de l’état pressé - fugiat anim",
      },
      disabling: {
        name: "Désactivation",
        description:
          "Le composant peut être désactivé et stylisé en conséquence. Le comportement de pression sera désactivé.",
        standard: "Désactivé - standard",
        filled: "Désactivé - rempli",
        reversed: "Désactivé - inversé",
        accessory: "Style d’accessoire désactivé",
        textStyle: "Style de texte désactivé",
      },
    },
  },
  demoListItem: {
    description:
      "Un composant de ligne stylisé qui peut être utilisé dans FlatList, SectionList, ou seul.",
    useCase: {
      height: {
        name: "Hauteur",
        description: "La ligne peut avoir différentes hauteurs.",
        defaultHeight: "Hauteur par défaut (56px)",
        customHeight: "Hauteur personnalisée via la prop `height`",
        textHeight:
          "Hauteur déterminée par le contenu du texte - Reprehenderit incididunt deserunt do do ea labore.",
        longText:
          "Limiter le texte long à une ligne - Reprehenderit incididunt deserunt do do ea labore.",
      },
      separators: {
        name: "Séparateurs",
        description: "Le séparateur / diviseur est préconfiguré et optionnel.",
        topSeparator: "Séparateur uniquement en haut",
        topAndBottomSeparator: "Séparateurs en haut et en bas",
        bottomSeparator: "Séparateur uniquement en bas",
      },
      icons: {
        name: "Icônes",
        description: "Vous pouvez personnaliser les icônes à gauche ou à droite.",
        leftIcon: "Icône gauche",
        rightIcon: "Icône droite",
        leftRightIcons: "Icônes gauche et droite",
      },
      customLeftRight: {
        name: "Composants personnalisés gauche/droite",
        description:
          "Si vous avez besoin d’un composant personnalisé à gauche/droite, vous pouvez le passer.",
        customLeft: "Composant personnalisé à gauche",
        customRight: "Composant personnalisé à droite",
      },
      passingContent: {
        name: "Transfert de contenu",
        description: "Il y a plusieurs façons de transmettre du contenu.",
        text: "Via la prop `text` - reprehenderit sint",
        children: "Enfants - mostrud mollit",
        nestedChildren1: "Enfants imbriqués - proident veniam.",
        nestedChildren2: "Ullamco cupidatat officia exercitation velit non ullamco nisi..",
      },
      listIntegration: {
        name: "Intégration avec FlatList",
        description:
          "Le composant peut être facilement intégré avec votre interface de liste préférée.",
      },
      styling: {
        name: "Style",
        description: "Le composant peut être facilement stylisé.",
        styledText: "Texte stylisé",
        styledContainer: "Conteneur stylisé (séparateurs)",
        tintedIcons: "Icônes teintées",
      },
    },
  },
  demoCard: {
    description:
      "Les cartes sont utiles pour afficher des informations connexes de manière contenue. Si un ListItem affiche le contenu horizontalement, une Card peut être utilisée pour afficher le contenu verticalement.",
    useCase: {
      presets: {
        name: "Préréglages",
        description: "Il y a quelques préréglages préconfigurés.",
        default: {
          heading: "Préréglage par défaut (default)",
          content: "Incididunt magna ut aliquip consectetur mollit dolor.",
          footer: "Consectetur nulla non aliquip velit.",
        },
        reversed: {
          heading: "Préréglage inversé",
          content: "Reprehenderit occaecat proident amet id laboris.",
          footer: "Consectetur tempor ea non labore anim .",
        },
      },
      verticalAlignment: {
        name: "Alignement vertical",
        description:
          "Selon les besoins, la carte est préconfigurée avec différentes stratégies d’alignement.",
        top: {
          heading: "Haut (par défaut)",
          content: "Tout le contenu est automatiquement aligné en haut.",
          footer: "Même le pied de page",
        },
        center: {
          heading: "Centre",
          content: "Le contenu est centré par rapport à la hauteur de la carte.",
          footer: "Moi aussi !",
        },
        spaceBetween: {
          heading: "Espace entre",
          content: "Tout le contenu est espacé uniformément.",
          footer: "Je suis là où je veux être.",
        },
        reversed: {
          heading: "Forcer le pied de page en bas",
          content: "Cela pousse le pied de page là où il appartient.",
          footer: "Je suis si seul ici en bas.",
        },
      },
      passingContent: {
        name: "Transfert de contenu",
        description: "Il y a plusieurs façons de transmettre du contenu.",
        heading: "Via la prop `heading`",
        content: "Via la prop `content`",
        footer: "Je suis si seul ici en bas.",
      },
      customComponent: {
        name: "Composants personnalisés",
        description:
          "N’importe quels composants préconfigurés peuvent être remplacé par le vôtre. Vous pouvez également en ajouter d’autres.",
        rightComponent: "Composant droit",
        leftComponent: "Composant gauche",
      },
      style: {
        name: "Style",
        description: "Le composant peut être facilement stylisé.",
        heading: "Styliser l’en-tête",
        content: "Styliser le contenu",
        footer: "Styliser le pied de page",
      },
    },
  },
  demoAutoImage: {
    description:
      "Un composant Image qui dimensionne automatiquement une image distante ou data-uri.",
    useCase: {
      remoteUri: { name: "URI distante" },
      base64Uri: { name: "URI Base64" },
      scaledToFitDimensions: {
        name: "Mis à l’échelle pour s’adapter aux dimensions",
        description:
          "En fournissant les props `maxWidth` et/ou `maxHeight`, l’image se redimensionnera automatiquement à l’échelle tout en conservant son rapport d’aspect. En quoi est-ce différent de `resizeMode: 'contain'` ? Premièrement, vous pouvez spécifier la taille d'un seul côté (pas les deux). Deuxièmement, l'image s'adaptera aux dimensions souhaitées au lieu d'être simplement contenue dans son conteneur d'image.",
        heightAuto: "largeur: 60 / hauteur: auto",
        widthAuto: "largeur: auto / hauteur: 32",
        bothManual: "largeur: 60 / hauteur: 60",
      },
    },
  },
  demoText: {
    description:
      "Pour vos besoins d'affichage de texte. Ce composant est un HOC sur celui intégré à React Native.",
    useCase: {
      presets: {
        name: "Préréglages",
        description: "Il y a quelques réglages préconfigurés.",
        default:
          "préréglage par défaut - Cillum eu laboris in labore. Excepteur mollit tempor reprehenderit fugiat elit et eu consequat laborum.",
        bold: "préréglage gras - Tempor et ullamco cupidatat in officia. Nulla ea duis elit id sunt ipsum cillum duis deserunt nostrud ut nostrud id.",
        subheading: "préréglage sous-titre - In Cupidatat Cillum.",
        heading: "préréglage titre - Voluptate Adipis.",
      },
      sizes: {
        name: "Tailles",
        description: "Il y a une prop de taille.",
        xs: "xs - Ea ipsum est ea ex sunt.",
        sm: "sm - Lorem sunt adipisicin.",
        md: "md - Consequat id do lorem.",
        lg: "lg - Nostrud ipsum ea.",
        xl: "xl - Eiusmod ex excepteur.",
        xxl: "xxl - Cillum eu laboris.",
      },
      weights: {
        name: "Graisse",
        description: "Il y a une prop de graisse.",
        light:
          "léger - Nulla magna incididunt excepteur est occaecat duis culpa dolore cupidatat enim et.",
        normal:
          "normal - Magna incididunt dolor ut veniam veniam laboris aliqua velit ea incididunt.",
        medium: "moyen - Non duis laborum quis laboris occaecat culpa cillum.",
        semibold: "demi-gras - Exercitation magna nostrud pariatur laborum occaecat aliqua.",
        bold: "gras - Eiusmod ullamco magna exercitation est excepteur.",
      },
      passingContent: {
        name: "Transfert de contenu",
        description: "Il y a plusieurs façons de transférer du contenu.",
        viaText:
          "via la prop `text` - Billum in aute fugiat proident nisi pariatur est. Cupidatat anim cillum eiusmod ad. Officia eu magna aliquip labore dolore consequat.",
        viaTx: "via la prop `tx` -",
        children: "enfants - Aliqua velit irure reprehenderit eu qui amet veniam consectetur.",
        nestedChildren: "Enfants imbriqués -",
        nestedChildren2: "Occaecat aliqua irure proident veniam.",
        nestedChildren3: "Ullamco cupidatat officia exercitation velit non ullamco nisi..",
        nestedChildren4: "Occaecat aliqua irure proident veniam.",
      },
      styling: {
        name: "Style",
        description: "Le composant peut être facilement stylisé.",
        text: "Consequat ullamco veniam velit mollit proident excepteur aliquip id culpa ipsum velit sint nostrud.",
        text2:
          "Eiusmod occaecat laboris eu ex veniam ipsum adipisicing consectetur. Magna ullamco adipisicing tempor adipisicing.",
        text3:
          "Eiusmod occaecat laboris eu ex veniam ipsum adipisicing consectetur. Magna ullamco adipisicing tempor adipisicing.",
      },
    },
  },
  demoHeader: {
    description:
      "Composant qui apparaît sur de nombreux écrans. Contiendra les boutons de navigation et le titre de l’écran.",
    useCase: {
      actionIcons: {
        name: "Icônes d’action",
        description:
          "Vous pouvez facilement passer des icônes aux composants d’action gauche ou droit.",
        leftIconTitle: "Icône gauche",
        rightIconTitle: "Icône droite",
        bothIconsTitle: "Les deux icônes",
      },
      actionText: {
        name: "Texte d’action",
        description:
          "Vous pouvez facilement passer du texte aux composants d’action gauche ou droit.",
        leftTxTitle: "Via `leftTx`",
        rightTextTitle: "Via `rightText`",
      },
      customActionComponents: {
        name: "Composants d’action personnalisés",
        description:
          "Si les options d’icône ou de texte ne suffisent pas, vous pouvez passer votre propre composant d’action personnalisé.",
        customLeftActionTitle: "Action gauche personnalisée",
      },
      titleModes: {
        name: "Modes de titre",
        description:
          "Le titre peut être forcé à rester au centre (par défaut) mais peut être coupé s’il est trop long. Vous pouvez éventuellement le faire s’ajuster aux boutons d’action.",
        centeredTitle: "Titre centré",
        flexTitle: "Titre flexible",
      },
      styling: {
        name: "Style",
        description: "Le composant peut être facilement stylisé.",
        styledTitle: "Titre stylisé",
        styledWrapperTitle: "Wrapper stylisé",
        tintedIconsTitle: "Icônes teintées",
      },
    },
  },
  demoEmptyState: {
    description:
      "Un composant à utiliser lorsqu’il n’y a pas de données à afficher. Il peut être utilisé pour diriger l’utilisateur sur ce qu’il faut faire ensuite.",
    useCase: {
      presets: {
        name: "Préréglages",
        description:
          "Vous pouvez créer différents ensembles de texte/image. Un est prédéfini appelé `generic`. Notez qu’il n’y a pas de valeur par défaut au cas où vous voudriez avoir un EmptyState complètement personnalisé.",
      },
      passingContent: {
        name: "Transfert de contenu",
        description: "Il y a plusieurs façons de transférer du contenu.",
        customizeImageHeading: "Personnaliser l’image",
        customizeImageContent: "Vous pouvez passer n’importe quelle source d'image.",
        viaHeadingProp: "Via la prop `heading`",
        viaContentProp: "Via la prop `content`.",
        viaButtonProp: "Via la prop `button`",
      },
      styling: {
        name: "Style",
        description: "Le composant peut être facilement stylisé.",
      },
    },
  },
}

export default demoFr

// @demo remove-file
===== END FILE: app/i18n/demo-fr.ts =====


===== BEGIN FILE: app/i18n/demo-en.ts =====
export const demoEn = {
  demoIcon: {
    description:
      "A component to render a registered icon. It is wrapped in a <TouchableOpacity /> if `onPress` is provided, otherwise a <View />.",
    useCase: {
      icons: {
        name: "Icons",
        description: "List of icons registered inside the component.",
      },
      size: {
        name: "Size",
        description: "There's a size prop.",
      },
      color: {
        name: "Color",
        description: "There's a color prop.",
      },
      styling: {
        name: "Styling",
        description: "The component can be styled easily.",
      },
    },
  },
  demoTextField: {
    description: "TextField component allows for the entering and editing of text.",
    useCase: {
      statuses: {
        name: "Statuses",
        description:
          "There is a status prop - similar to `preset` in other components, but affects component functionality as well.",
        noStatus: {
          label: "No Status",
          helper: "This is the default status",
          placeholder: "Text goes here",
        },
        error: {
          label: "Error Status",
          helper: "Status to use when there is an error",
          placeholder: "Text goes here",
        },
        disabled: {
          label: "Disabled Status",
          helper: "Disables the editability and mutes text",
          placeholder: "Text goes here",
        },
      },
      passingContent: {
        name: "Passing Content",
        description: "There are a few different ways to pass content.",
        viaLabel: {
          labelTx: "Via `label` prop",
          helper: "Via `helper` prop",
          placeholder: "Via `placeholder` prop",
        },
        rightAccessory: {
          label: "RightAccessory",
          helper: "This prop takes a function that returns a React element.",
        },
        leftAccessory: {
          label: "LeftAccessory",
          helper: "This prop takes a function that returns a React element.",
        },
        supportsMultiline: {
          label: "Supports Multiline",
          helper: "Enables a taller input for multiline text.",
        },
      },
      styling: {
        name: "Styling",
        description: "The component can be styled easily.",
        styleInput: {
          label: "Style Input",
          helper: "Via `style` prop",
        },
        styleInputWrapper: {
          label: "Style Input Wrapper",
          helper: "Via `inputWrapperStyle` prop",
        },
        styleContainer: {
          label: "Style Container",
          helper: "Via `containerStyle` prop",
        },
        styleLabel: {
          label: "Style Label & Helper",
          helper: "Via `LabelTextProps` & `HelperTextProps` style prop",
        },
        styleAccessories: {
          label: "Style Accessories",
          helper: "Via `RightAccessory` & `LeftAccessory` style prop",
        },
      },
    },
  },
  demoToggle: {
    description:
      "Renders a boolean input. This is a controlled component that requires an onValueChange callback that updates the value prop in order for the component to reflect user actions. If the value prop is not updated, the component will continue to render the supplied value prop instead of the expected result of any user actions.",
    useCase: {
      variants: {
        name: "Variants",
        description:
          "The component supports a few different variants. If heavy customization of a specific variant is needed, it can be easily refactored. The default is `checkbox`.",
        checkbox: {
          label: "`checkbox` variant",
          helper: "This can be used for a single on/off input.",
        },
        radio: {
          label: "`radio` variant",
          helper: "Use this when you have multiple options.",
        },
        switch: {
          label: "`switch` variant",
          helper: "A more prominent on/off input. Has better accessibility support.",
        },
      },
      statuses: {
        name: "Statuses",
        description:
          "There is a status prop - similar to `preset` in other components, but affects component functionality as well.",
        noStatus: "No status - this is the default",
        errorStatus: "Error status - use when there is an error",
        disabledStatus: "Disabled status - disables the editability and mutes input",
      },
      passingContent: {
        name: "Passing Content",
        description: "There are a few different ways to pass content.",
        useCase: {
          checkBox: {
            label: "Via `labelTx` prop",
            helper: "Via `helperTx` prop.",
          },
          checkBoxMultiLine: {
            helper: "Supports multiline - Nulla proident consectetur labore sunt ea labore. ",
          },
          radioChangeSides: {
            helper: "You can change sides - Laborum labore adipisicing in eu ipsum deserunt.",
          },
          customCheckBox: {
            label: "Pass in a custom checkbox icon.",
          },
          switch: {
            label: "Switches can be read as text",
            helper:
              "By default, this option doesn't use `Text` since depending on the font, the on/off characters might look weird. Customize as needed.",
          },
          switchAid: {
            label: "Or aided with an icon",
          },
        },
      },
      styling: {
        name: "Styling",
        description: "The component can be styled easily.",
        outerWrapper: "1 - style the input outer wrapper",
        innerWrapper: "2 - style the input inner wrapper",
        inputDetail: "3 - style the input detail",
        labelTx: "You can also style the labelTx",
        styleContainer: "Or, style the entire container",
      },
    },
  },
  demoButton: {
    description:
      "A component that allows users to take actions and make choices. Wraps the Text component with a Pressable component.",
    useCase: {
      presets: {
        name: "Presets",
        description: "There are a few presets that are preconfigured.",
      },
      passingContent: {
        name: "Passing Content",
        description: "There are a few different ways to pass content.",
        viaTextProps: "Via `text` Prop - Billum In",
        children: "Children - Irure Reprehenderit",
        rightAccessory: "RightAccessory - Duis Quis",
        leftAccessory: "LeftAccessory - Duis Proident",
        nestedChildren: "Nested children - proident veniam.",
        nestedChildren2: "Ullamco cupidatat officia exercitation velit non ullamco nisi..",
        nestedChildren3: "Occaecat aliqua irure proident veniam.",
        multiLine:
          "Multiline - consequat veniam veniam reprehenderit. Fugiat id nisi quis duis sunt proident mollit dolor mollit adipisicing proident deserunt.",
      },
      styling: {
        name: "Styling",
        description: "The component can be styled easily.",
        styleContainer: "Style Container - Exercitation",
        styleText: "Style Text - Ea Anim",
        styleAccessories: "Style Accessories - enim ea id fugiat anim ad.",
        pressedState: "Style Pressed State - fugiat anim",
      },
      disabling: {
        name: "Disabling",
        description:
          "The component can be disabled, and styled based on that. Press behavior will be disabled.",
        standard: "Disabled - standard",
        filled: "Disabled - filled",
        reversed: "Disabled - reversed",
        accessory: "Disabled accessory style",
        textStyle: "Disabled text style",
      },
    },
  },
  demoListItem: {
    description: "A styled row component that can be used in FlatList, SectionList, or by itself.",
    useCase: {
      height: {
        name: "Height",
        description: "The row can be different heights.",
        defaultHeight: "Default height (56px)",
        customHeight: "Custom height via `height` prop",
        textHeight:
          "Height determined by text content - Reprehenderit incididunt deserunt do do ea labore.",
        longText:
          "Limit long text to one line - Reprehenderit incididunt deserunt do do ea labore.",
      },
      separators: {
        name: "Separators",
        description: "The separator / divider is preconfigured and optional.",
        topSeparator: "Only top separator",
        topAndBottomSeparator: "Top and bottom separators",
        bottomSeparator: "Only bottom separator",
      },
      icons: {
        name: "Icons",
        description: "You can customize the icons on the left or right.",
        leftIcon: "Left icon",
        rightIcon: "Right Icon",
        leftRightIcons: "Left & Right Icons",
      },
      customLeftRight: {
        name: "Custom Left/Right Components",
        description: "If you need a custom left/right component, you can pass it in.",
        customLeft: "Custom left component",
        customRight: "Custom right component",
      },
      passingContent: {
        name: "Passing Content",
        description: "There are a few different ways to pass content.",
        text: "Via `text` prop - reprehenderit sint",
        children: "Children - mostrud mollit",
        nestedChildren1: "Nested children - proident veniam.",
        nestedChildren2: "Ullamco cupidatat officia exercitation velit non ullamco nisi..",
      },
      listIntegration: {
        name: "Integrating w/ FlatList",
        description: "The component can be easily integrated with your favorite list interface.",
      },
      styling: {
        name: "Styling",
        description: "The component can be styled easily.",
        styledText: "Styled Text",
        styledContainer: "Styled Container (separators)",
        tintedIcons: "Tinted Icons",
      },
    },
  },
  demoCard: {
    description:
      "Cards are useful for displaying related information in a contained way. If a ListItem displays content horizontally, a Card can be used to display content vertically.",
    useCase: {
      presets: {
        name: "Presets",
        description: "There are a few presets that are preconfigured.",
        default: {
          heading: "Default Preset (default)",
          content: "Incididunt magna ut aliquip consectetur mollit dolor.",
          footer: "Consectetur nulla non aliquip velit.",
        },
        reversed: {
          heading: "Reversed Preset",
          content: "Reprehenderit occaecat proident amet id laboris.",
          footer: "Consectetur tempor ea non labore anim .",
        },
      },
      verticalAlignment: {
        name: "Vertical Alignment",
        description:
          "Depending on what's required, the card comes preconfigured with different alignment strategies.",
        top: {
          heading: "Top (default)",
          content: "All content is automatically aligned to the top.",
          footer: "Even the footer",
        },
        center: {
          heading: "Center",
          content: "Content is centered relative to the card's height.",
          footer: "Me too!",
        },
        spaceBetween: {
          heading: "Space Between",
          content: "All content is spaced out evenly.",
          footer: "I am where I want to be.",
        },
        reversed: {
          heading: "Force Footer Bottom",
          content: "This pushes the footer where it belongs.",
          footer: "I'm so lonely down here.",
        },
      },
      passingContent: {
        name: "Passing Content",
        description: "There are a few different ways to pass content.",
        heading: "Via `heading` Prop",
        content: "Via `content` Prop",
        footer: "I'm so lonely down here.",
      },
      customComponent: {
        name: "Custom Components",
        description:
          "Any of the preconfigured components can be replaced with your own. You can also add additional ones.",
        rightComponent: "RightComponent",
        leftComponent: "LeftComponent",
      },
      style: {
        name: "Styling",
        description: "The component can be styled easily.",
        heading: "Style the Heading",
        content: "Style the Content",
        footer: "Style the Footer",
      },
    },
  },
  demoAutoImage: {
    description: "An Image component that automatically sizes a remote or data-uri image.",
    useCase: {
      remoteUri: { name: "Remote URI" },
      base64Uri: { name: "Base64 URI" },
      scaledToFitDimensions: {
        name: "Scaled to Fit Dimensions",
        description:
          "Providing a `maxWidth` and/or `maxHeight` props, the image will automatically scale while retaining it's aspect ratio. How is this different from `resizeMode: 'contain'`? Firstly, you can specify only one side's size (not both). Secondly, the image will scale to fit the desired dimensions instead of just being contained within its image-container.",
        heightAuto: "width: 60 / height: auto",
        widthAuto: "width: auto / height: 32",
        bothManual: "width: 60 / height: 60",
      },
    },
  },
  demoText: {
    description:
      "For your text displaying needs. This component is a HOC over the built-in React Native one.",
    useCase: {
      presets: {
        name: "Presets",
        description: "There are a few presets that are preconfigured.",
        default:
          "default preset - Cillum eu laboris in labore. Excepteur mollit tempor reprehenderit fugiat elit et eu consequat laborum.",
        bold: "bold preset - Tempor et ullamco cupidatat in officia. Nulla ea duis elit id sunt ipsum cillum duis deserunt nostrud ut nostrud id.",
        subheading: "subheading preset - In Cupidatat Cillum.",
        heading: "heading preset - Voluptate Adipis.",
      },
      sizes: {
        name: "Sizes",
        description: "There's a size prop.",
        xs: "xs - Ea ipsum est ea ex sunt.",
        sm: "sm - Lorem sunt adipisicin.",
        md: "md - Consequat id do lorem.",
        lg: "lg - Nostrud ipsum ea.",
        xl: "xl - Eiusmod ex excepteur.",
        xxl: "xxl - Cillum eu laboris.",
      },
      weights: {
        name: "Weights",
        description: "There's a weight prop.",
        light:
          "light - Nulla magna incididunt excepteur est occaecat duis culpa dolore cupidatat enim et.",
        normal:
          "normal - Magna incididunt dolor ut veniam veniam laboris aliqua velit ea incididunt.",
        medium: "medium - Non duis laborum quis laboris occaecat culpa cillum.",
        semibold: "semiBold - Exercitation magna nostrud pariatur laborum occaecat aliqua.",
        bold: "bold - Eiusmod ullamco magna exercitation est excepteur.",
      },
      passingContent: {
        name: "Passing Content",
        description: "There are a few different ways to pass content.",
        viaText:
          "via `text` prop - Billum in aute fugiat proident nisi pariatur est. Cupidatat anim cillum eiusmod ad. Officia eu magna aliquip labore dolore consequat.",
        viaTx: "via `tx` prop -",
        children: "children - Aliqua velit irure reprehenderit eu qui amet veniam consectetur.",
        nestedChildren: "Nested children -",
        nestedChildren2: "Occaecat aliqua irure proident veniam.",
        nestedChildren3: "Ullamco cupidatat officia exercitation velit non ullamco nisi..",
        nestedChildren4: "Occaecat aliqua irure proident veniam.",
      },
      styling: {
        name: "Styling",
        description: "The component can be styled easily.",
        text: "Consequat ullamco veniam velit mollit proident excepteur aliquip id culpa ipsum velit sint nostrud.",
        text2:
          "Eiusmod occaecat laboris eu ex veniam ipsum adipisicing consectetur. Magna ullamco adipisicing tempor adipisicing.",
        text3:
          "Eiusmod occaecat laboris eu ex veniam ipsum adipisicing consectetur. Magna ullamco adipisicing tempor adipisicing.",
      },
    },
  },
  demoHeader: {
    description:
      "Component that appears on many screens. Will hold navigation buttons and screen title.",
    useCase: {
      actionIcons: {
        name: "Action Icons",
        description: "You can easily pass in icons to the left or right action components.",
        leftIconTitle: "Left Icon",
        rightIconTitle: "Right Icon",
        bothIconsTitle: "Both Icons",
      },
      actionText: {
        name: "Action Text",
        description: "You can easily pass in text to the left or right action components.",
        leftTxTitle: "Via `leftTx`",
        rightTextTitle: "Via `rightText`",
      },
      customActionComponents: {
        name: "Custom Action Components",
        description:
          "If the icon or text options are not enough, you can pass in your own custom action component.",
        customLeftActionTitle: "Custom Left Action",
      },
      titleModes: {
        name: "Title Modes",
        description:
          "Title can be forced to stay in center (default) but may be cut off if it's too long. You can optionally make it adjust to the action buttons.",
        centeredTitle: "Centered Title",
        flexTitle: "Flex Title",
      },
      styling: {
        name: "Styling",
        description: "The component can be styled easily.",
        styledTitle: "Styled Title",
        styledWrapperTitle: "Styled Wrapper",
        tintedIconsTitle: "Tinted Icons",
      },
    },
  },
  demoEmptyState: {
    description:
      "A component to use when there is no data to display. It can be utilized to direct the user what to do next",
    useCase: {
      presets: {
        name: "Presets",
        description:
          "You can create different text/image sets. One is predefined called `generic`. Note, there's no default in case you want to have a completely custom EmptyState.",
      },
      passingContent: {
        name: "Passing Content",
        description: "There are a few different ways to pass content.",
        customizeImageHeading: "Customize Image",
        customizeImageContent: "You can pass in any image source.",
        viaHeadingProp: "Via `heading` Prop",
        viaContentProp: "Via `content` prop.",
        viaButtonProp: "Via `button` Prop",
      },
      styling: {
        name: "Styling",
        description: "The component can be styled easily.",
      },
    },
  },
}

export default demoEn
export type DemoTranslations = typeof demoEn

// @demo remove-file
===== END FILE: app/i18n/demo-en.ts =====


===== BEGIN FILE: app/i18n/ko.ts =====
import demoKo from "./demo-ko" // @demo remove-current-line
import { Translations } from "./en"

const ko: Translations = {
  common: {
    ok: "확인!",
    cancel: "취소",
    back: "뒤로",
    logOut: "로그아웃", // @demo remove-current-line
  },
  welcomeScreen: {
    postscript:
      "잠깐! — 지금 보시는 것은 아마도 당신의 앱의 모양새가 아닐겁니다. (디자이너분이 이렇게 건내주셨다면 모를까요. 만약에 그렇다면, 이대로 가져갑시다!) ",
    readyForLaunch: "출시 준비가 거의 끝난 나만의 앱!",
    exciting: "(오, 이거 신나는데요!)",
    letsGo: "가보자구요!", // @demo remove-current-line
  },
  errorScreen: {
    title: "뭔가 잘못되었습니다!",
    friendlySubtitle:
      "이 화면은 오류가 발생할 때 프로덕션에서 사용자에게 표시됩니다. 이 메시지를 커스터마이징 할 수 있고(해당 파일은 `app/i18n/ko.ts` 에 있습니다) 레이아웃도 마찬가지로 수정할 수 있습니다(`app/screens/error`). 만약 이 오류화면을 완전히 없에버리고 싶다면 `app/app.tsx` 파일에서 <ErrorBoundary> 컴포넌트를 확인하기 바랍니다.",
    reset: "초기화",
    traceTitle: "%{name} 스택에서의 오류", // @demo remove-current-line
  },
  emptyStateComponent: {
    generic: {
      heading: "너무 텅 비어서.. 너무 슬퍼요..",
      content: "데이터가 없습니다. 버튼을 눌러서 리프레쉬 하시거나 앱을 리로드하세요.",
      button: "다시 시도해봅시다",
    },
  },
  // @demo remove-block-start
  errors: {
    invalidEmail: "잘못된 이메일 주소 입니다.",
  },
  loginScreen: {
    logIn: "로그인",
    enterDetails:
      "일급비밀 정보를 해제하기 위해 상세 정보를 입력하세요. 무엇이 기다리고 있는지 절대 모를겁니다. 혹은 알 수 있을지도 모르겠군요. 엄청 복잡한 뭔가는 아닙니다.",
    emailFieldLabel: "이메일",
    passwordFieldLabel: "비밀번호",
    emailFieldPlaceholder: "이메일을 입력하세요",
    passwordFieldPlaceholder: "엄청 비밀스러운 암호를 입력하세요",
    tapToLogIn: "눌러서 로그인 하기!",
    hint: "힌트: 가장 좋아하는 암호와 아무런 아무 이메일 주소나 사용할 수 있어요 :)",
  },
  demoNavigator: {
    componentsTab: "컴포넌트",
    debugTab: "디버그",
    communityTab: "커뮤니티",
    podcastListTab: "팟캐스트",
  },
  demoCommunityScreen: {
    title: "커뮤니티와 함께해요",
    tagLine:
      "전문적인 React Native 엔지니어들로 구성된 Infinite Red 커뮤니티에 접속해서 함께 개발 실력을 향상시켜 보세요!",
    joinUsOnSlackTitle: "Slack 에 참여하세요",
    joinUsOnSlack:
      "전 세계 React Native 엔지니어들과 함께할 수 있는 곳이 있었으면 좋겠죠? Infinite Red Community Slack 에서 대화에 참여하세요! 우리의 성장하는 커뮤니티는 질문을 던지고, 다른 사람들로부터 배우고, 네트워크를 확장할 수 있는 안전한 공간입니다. ",
    joinSlackLink: "Slack 에 참여하기",
    makeIgniteEvenBetterTitle: "Ignite 을 향상시켜요",
    makeIgniteEvenBetter:
      "Ignite 을 더 좋게 만들 아이디어가 있나요? 기쁜 소식이네요. 우리는 항상 최고의 React Native 도구를 구축하는데 도움을 줄 수 있는 분들을 찾고 있습니다. GitHub 에서 Ignite 의 미래를 만들어 가는것에 함께해 주세요.",
    contributeToIgniteLink: "Ignite 에 기여하기",
    theLatestInReactNativeTitle: "React Native 의 최신정보",
    theLatestInReactNative: "React Native 가 제공하는 모든 최신 정보를 알려드립니다.",
    reactNativeRadioLink: "React Native 라디오",
    reactNativeNewsletterLink: "React Native 뉴스레터",
    reactNativeLiveLink: "React Native 라이브 스트리밍",
    chainReactConferenceLink: "Chain React 컨퍼런스",
    hireUsTitle: "다음 프로젝트에 Infinite Red 를 고용하세요",
    hireUs:
      "프로젝트 전체를 수행하든, 실무 교육을 통해 팀의 개발 속도에 박차를 가하든 상관없이, Infinite Red 는 React Native 프로젝트의 모든 분야의 에서 도움을 드릴 수 있습니다.",
    hireUsLink: "메세지 보내기",
  },
  demoShowroomScreen: {
    jumpStart: "프로젝트를 바로 시작할 수 있는 컴포넌트들!",
    lorem2Sentences:
      "별 하나에 추억과, 별 하나에 사랑과, 별 하나에 쓸쓸함과, 별 하나에 동경(憧憬)과, 별 하나에 시와, 별 하나에 어머니, 어머니",
    demoHeaderTxExample: "야호",
    demoViaTxProp: "`tx` Prop 을 통해",
    demoViaSpecifiedTxProp: "`{{prop}}Tx` Prop 을 통해",
  },
  demoDebugScreen: {
    howTo: "사용방법",
    title: "디버그",
    tagLine:
      "축하합니다. 여기 아주 고급스러운 React Native 앱 템플릿이 있습니다. 이 보일러 플레이트를 사용해보세요!",
    reactotron: "Reactotron 으로 보내기",
    reportBugs: "버그 보고하기",
    demoList: "데모 목록",
    demoPodcastList: "데모 팟캐스트 목록",
    androidReactotronHint:
      "만약에 동작하지 않는 경우, Reactotron 데스크탑 앱이 실행중인지 확인 후, 터미널에서 adb reverse tcp:9090 tcp:9090 을 실행한 다음 앱을 다시 실행해보세요.",
    iosReactotronHint:
      "만약에 동작하지 않는 경우, Reactotron 데스크탑 앱이 실행중인지 확인 후 앱을 다시 실행해보세요.",
    macosReactotronHint:
      "만약에 동작하지 않는 경우, Reactotron 데스크탑 앱이 실행중인지 확인 후 앱을 다시 실행해보세요.",
    webReactotronHint:
      "만약에 동작하지 않는 경우, Reactotron 데스크탑 앱이 실행중인지 확인 후 앱을 다시 실행해보세요.",
    windowsReactotronHint:
      "만약에 동작하지 않는 경우, Reactotron 데스크탑 앱이 실행중인지 확인 후 앱을 다시 실행해보세요.",
  },
  demoPodcastListScreen: {
    title: "React Native 라디오 에피소드",
    onlyFavorites: "즐겨찾기만 보기",
    favoriteButton: "즐겨찾기",
    unfavoriteButton: "즐겨찾기 해제",
    accessibility: {
      cardHint:
        "에피소드를 들으려면 두 번 탭하세요. 이 에피소드를 좋아하거나 싫어하려면 두 번 탭하고 길게 누르세요.",
      switch: "즐겨찾기를 사용하려면 스위치를 사용하세요.",
      favoriteAction: "즐겨찾기 토글",
      favoriteIcon: "좋아하는 에피소드",
      unfavoriteIcon: "즐겨찾기하지 않은 에피소드",
      publishLabel: "{{date}} 에 발행됨",
      durationLabel: "소요시간: {{hours}}시간 {{minutes}}분 {{seconds}}초",
    },
    noFavoritesEmptyState: {
      heading: "조금 텅 비어 있네요.",
      content: "즐겨찾기가 없습니다. 에피소드에 있는 하트를 눌러서 즐겨찾기에 추가하세요.",
    },
  },
  // @demo remove-block-start
  ...demoKo,
  // @demo remove-block-end
}

export default ko
===== END FILE: app/i18n/ko.ts =====


===== BEGIN FILE: app/i18n/index.ts =====
import { I18nManager } from "react-native"
import * as Localization from "expo-localization"
import i18n from "i18next"
import { initReactI18next } from "react-i18next"
import "intl-pluralrules"

// if English isn't your default language, move Translations to the appropriate language file.
import ar from "./ar"
import en, { Translations } from "./en"
import es from "./es"
import fr from "./fr"
import hi from "./hi"
import ja from "./ja"
import ko from "./ko"
import mr from "./mr"

const fallbackLocale = "en-US"

const systemLocales = Localization.getLocales()

const resources = { mr, ar, en, ko, es, fr, ja, hi }
const supportedTags = Object.keys(resources)

// Checks to see if the device locale matches any of the supported locales
// Device locale may be more specific and still match (e.g., en-US matches en)
const systemTagMatchesSupportedTags = (deviceTag: string) => {
  const primaryTag = deviceTag.split("-")[0]
  return supportedTags.includes(primaryTag)
}

const pickSupportedLocale: () => Localization.Locale | undefined = () => {
  return systemLocales.find((locale) => systemTagMatchesSupportedTags(locale.languageTag))
}

const locale = pickSupportedLocale()

export let isRTL = false

// Need to set RTL ASAP to ensure the app is rendered correctly. Waiting for i18n to init is too late.
if (locale?.languageTag && locale?.textDirection === "rtl") {
  I18nManager.allowRTL(true)
  isRTL = true
} else {
  I18nManager.allowRTL(false)
}

export const initI18n = async () => {
  i18n.use(initReactI18next)

  await i18n.init({
    resources,
    lon: locale?.languageTag ?? fallbackLocale,
    fallbacklon: fallbackLocale,
    interpolation: {
      escapeValue: false,
    },
  })

  return i18n
}

/**
 * Builds up valid keypaths for translations.
 */

export type TxKeyPath = RecursiveKeyOf<Translations>

// via: https://stackoverflow.com/a/65333050
type RecursiveKeyOf<TObj extends object> = {
  [TKey in keyof TObj & (string | number)]: RecursiveKeyOfHandleValue<TObj[TKey], `${TKey}`, true>
}[keyof TObj & (string | number)]

type RecursiveKeyOfInner<TObj extends object> = {
  [TKey in keyof TObj & (string | number)]: RecursiveKeyOfHandleValue<TObj[TKey], `${TKey}`, false>
}[keyof TObj & (string | number)]

type RecursiveKeyOfHandleValue<
  TValue,
  Text extends string,
  IsFirstLevel extends boolean,
> = TValue extends any[]
  ? Text
  : TValue extends object
    ? IsFirstLevel extends true
      ? Text | `${Text}:${RecursiveKeyOfInner<TValue>}`
      : Text | `${Text}.${RecursiveKeyOfInner<TValue>}`
    : Text
===== END FILE: app/i18n/index.ts =====


===== BEGIN FILE: app/i18n/translate.ts =====
import i18n from "i18next"
import type { TOptions } from "i18next"

import { TxKeyPath } from "."

/**
 * Translates text.
 * @param {TxKeyPath} key - The i18n key.
 * @param {TOptions} options - The i18n options.
 * @returns {string} - The translated text.
 * @example
 * Translations:
 *
 * ```en.ts
 * {
 *  "hello": "Hello, {{name}}!"
 * }
 * ```
 *
 * Usage:
 * ```ts
 * import { translate } from "./i18n"
 *
 * translate("hello", { name: "world" })
 * // => "Hello world!"
 * ```
 */
export function translate(key: TxKeyPath, options?: TOptions): string {
  if (i18n.isInitialized) {
    return i18n.t(key, options)
  }
  return key
}
===== END FILE: app/i18n/translate.ts =====


===== BEGIN FILE: app/i18n/ja.ts =====
import demoJa from "./demo-ja" // @demo remove-current-line
import { Translations } from "./en"

const ja: Translations = {
  common: {
    ok: "OK",
    cancel: "キャンセル",
    back: "戻る",
    logOut: "ログアウト", // @demo remove-current-line
  },
  welcomeScreen: {
    postscript:
      "注目！ — このアプリはお好みの見た目では無いかもしれません(デザイナーがこのスクリーンを送ってこない限りは。もしそうなら公開しちゃいましょう！)",
    readyForLaunch: "このアプリはもう少しで公開できます！",
    exciting: "(楽しみですね！)",
    letsGo: "レッツゴー！", // @demo remove-current-line
  },
  errorScreen: {
    title: "問題が発生しました",
    friendlySubtitle:
      "本番では、エラーが投げられた時にこのページが表示されます。もし使うならこのメッセージに変更を加えてください(`app/i18n/jp.ts`)レイアウトはこちらで変更できます(`app/screens/ErrorScreen`)。もしこのスクリーンを取り除きたい場合は、`app/app.tsx`にある<ErrorBoundary>コンポーネントをチェックしてください",
    reset: "リセット",
    traceTitle: "エラーのスタック: %{name}", // @demo remove-current-line
  },
  emptyStateComponent: {
    generic: {
      heading: "静かだ...悲しい。",
      content:
        "データが見つかりません。ボタンを押してアプリをリロード、またはリフレッシュしてください。",
      button: "もう一度やってみよう",
    },
  },
  // @demo remove-block-start
  errors: {
    invalidEmail: "有効なメールアドレスを入力してください.",
  },
  loginScreen: {
    logIn: "ログイン",
    enterDetails:
      "ここにあなたの情報を入力してトップシークレットをアンロックしましょう。何が待ち構えているか予想もつかないはずです。はたまたそうでも無いかも - ロケットサイエンスほど複雑なものではありません。",
    emailFieldLabel: "メールアドレス",
    passwordFieldLabel: "パスワード",
    emailFieldPlaceholder: "メールアドレスを入力してください",
    passwordFieldPlaceholder: "パスワードを入力してください",
    tapToLogIn: "タップしてログインしよう！",
    hint: "ヒント: お好みのメールアドレスとパスワードを使ってください :)",
  },
  demoNavigator: {
    componentsTab: "コンポーネント",
    debugTab: "デバッグ",
    communityTab: "コミュニティ",
    podcastListTab: "ポッドキャスト",
  },
  demoCommunityScreen: {
    title: "コミュニティと繋がろう",
    tagLine:
      "Infinite RedのReact Nativeエンジニアコミュニティに接続して、一緒にあなたのアプリ開発をレベルアップしましょう！",
    joinUsOnSlackTitle: "私たちのSlackに参加しましょう",
    joinUsOnSlack:
      "世界中のReact Nativeエンジニアと繋がりたいを思いませんか？Infinite RedのコミュニティSlackに参加しましょう！私達のコミュニティは安全に質問ができ、お互いから学び、あなたのネットワークを広げることができます。",
    joinSlackLink: "Slackコミュニティに参加する",
    makeIgniteEvenBetterTitle: "Igniteをより良くする",
    makeIgniteEvenBetter:
      "Igniteをより良くする為のアイデアはありますか? そうであれば聞きたいです！ 私たちはいつでも最良のReact Nativeのツールを開発する為に助けを求めています。GitHubで私たちと一緒にIgniteの未来を作りましょう。",
    contributeToIgniteLink: "Igniteにコントリビュートする",
    theLatestInReactNativeTitle: "React Nativeの今",
    theLatestInReactNative: "React Nativeの現在をあなたにお届けします。",
    reactNativeRadioLink: "React Native Radio",
    reactNativeNewsletterLink: "React Native Newsletter",
    reactNativeLiveLink: "React Native Live",
    chainReactConferenceLink: "Chain React Conference",
    hireUsTitle: "あなたの次のプロジェクトでInfinite Redと契約する",
    hireUs:
      "それがプロジェクト全体でも、チームにトレーニングをしてあげたい時でも、Infinite RedはReact Nativeのことであればなんでもお手伝いができます。",
    hireUsLink: "メッセージを送る",
  },
  demoShowroomScreen: {
    jumpStart: "あなたのプロジェクトをスタートさせるコンポーネントです！",
    lorem2Sentences:
      "Nulla cupidatat deserunt amet quis aliquip nostrud do adipisicing. Adipisicing excepteur elit laborum Lorem adipisicing do duis.",
    demoHeaderTxExample: "Yay",
    demoViaTxProp: "`tx`から",
    demoViaSpecifiedTxProp: "`{{prop}}Tx`から",
  },
  demoDebugScreen: {
    howTo: "ハウツー",
    title: "デバッグ",
    tagLine:
      "おめでとうございます、あなたはとてもハイレベルなReact Nativeのテンプレートを使ってます。このボイラープレートを活用してください！",
    reactotron: "Reactotronに送る",
    reportBugs: "バグをレポートする",
    demoList: "デモリスト",
    demoPodcastList: "デモのポッドキャストリスト",
    androidReactotronHint:
      "もし動かなければ、Reactotronのデスクトップアプリが実行されていることを確認して, このコマンドをターミナルで実行した後、アプリをアプリをリロードしてください。 adb reverse tcp:9090 tcp:9090",
    iosReactotronHint:
      "もし動かなければ、Reactotronのデスクトップアプリが実行されていることを確認して、アプリをリロードしてください。",
    macosReactotronHint:
      "もし動かなければ、Reactotronのデスクトップアプリが実行されていることを確認して、アプリをリロードしてください。",
    webReactotronHint:
      "もし動かなければ、Reactotronのデスクトップアプリが実行されていることを確認して、アプリをリロードしてください。",
    windowsReactotronHint:
      "もし動かなければ、Reactotronのデスクトップアプリが実行されていることを確認して、アプリをリロードしてください。",
  },
  demoPodcastListScreen: {
    title: "React Native Radioのエピソード",
    onlyFavorites: "お気に入り表示",
    favoriteButton: "お気に入り",
    unfavoriteButton: "お気に入りを外す",
    accessibility: {
      cardHint: "ダブルタップで再生します。 ダブルタップと長押しで {{action}}",
      switch: "スイッチオンでお気に入りを表示する",
      favoriteAction: "お気に入りの切り替え",
      favoriteIcon: "お気に入りのエピソードではありません",
      unfavoriteIcon: "お気に入りのエピソードです",
      publishLabel: "公開日 {{date}}",
      durationLabel: "再生時間: {{hours}} 時間 {{minutes}} 分 {{seconds}} 秒",
    },
    noFavoritesEmptyState: {
      heading: "どうやら空っぽのようですね",
      content:
        "お気に入りのエピソードがまだありません。エピソードにあるハートマークにタップして、お気に入りに追加しましょう！",
    },
  },
  // @demo remove-block-start
  ...demoJa,
  // @demo remove-block-end
}

export default ja
===== END FILE: app/i18n/ja.ts =====


===== BEGIN FILE: app/services/api/apiProblem.ts =====
import { ApiResponse } from "apisauce"

export type GeneralApiProblem =
  /**
   * Times up.
   */
  | { kind: "timeout"; temporary: true }
  /**
   * Cannot connect to the server for some reason.
   */
  | { kind: "cannot-connect"; temporary: true }
  /**
   * The server experienced a problem. Any 5xx error.
   */
  | { kind: "server" }
  /**
   * We're not allowed because we haven't identified ourself. This is 401.
   */
  | { kind: "unauthorized" }
  /**
   * We don't have access to perform that request. This is 403.
   */
  | { kind: "forbidden" }
  /**
   * Unable to find that resource.  This is a 404.
   */
  | { kind: "not-found" }
  /**
   * All other 4xx series errors.
   */
  | { kind: "rejected" }
  /**
   * Something truly unexpected happened. Most likely can try again. This is a catch all.
   */
  | { kind: "unknown"; temporary: true }
  /**
   * The data we received is not in the expected format.
   */
  | { kind: "bad-data" }

/**
 * Attempts to get a common cause of problems from an api response.
 *
 * @param response The api response.
 */
export function getGeneralApiProblem(response: ApiResponse<any>): GeneralApiProblem | null {
  switch (response.problem) {
    case "CONNECTION_ERROR":
      return { kind: "cannot-connect", temporary: true }
    case "NETWORK_ERROR":
      return { kind: "cannot-connect", temporary: true }
    case "TIMEOUT_ERROR":
      return { kind: "timeout", temporary: true }
    case "SERVER_ERROR":
      return { kind: "server" }
    case "UNKNOWN_ERROR":
      return { kind: "unknown", temporary: true }
    case "CLIENT_ERROR":
      switch (response.status) {
        case 401:
          return { kind: "unauthorized" }
        case 403:
          return { kind: "forbidden" }
        case 404:
          return { kind: "not-found" }
        default:
          return { kind: "rejected" }
      }
    case "CANCEL_ERROR":
      return null
  }

  return null
}
===== END FILE: app/services/api/apiProblem.ts =====


===== BEGIN FILE: app/services/api/types.ts =====
/**
 * These types indicate the shape of the data you expect to receive from your
 * API endpoint, assuming it's a JSON object like we have.
 */
export interface EpisodeItem {
  title: string
  pubDate: string
  link: string
  guid: string
  author: string
  thumbnail: string
  description: string
  content: string
  enclosure: {
    link: string
    type: string
    length: number
    duration: number
    rating: { scheme: string; value: string }
  }
  categories: string[]
}

export interface ApiFeedResponse {
  status: string
  feed: {
    url: string
    title: string
    link: string
    author: string
    description: string
    image: string
  }
  items: EpisodeItem[]
}

/**
 * The options used to configure apisauce.
 */
export interface ApiConfig {
  /**
   * The URL of the api.
   */
  url: string

  /**
   * Milliseconds before we timeout the request.
   */
  timeout: number
}
===== END FILE: app/services/api/types.ts =====


===== BEGIN FILE: app/services/api/apiProblem.test.ts =====
import { ApiErrorResponse } from "apisauce"

import { getGeneralApiProblem } from "./apiProblem"

test("handles connection errors", () => {
  expect(getGeneralApiProblem({ problem: "CONNECTION_ERROR" } as ApiErrorResponse<null>)).toEqual({
    kind: "cannot-connect",
    temporary: true,
  })
})

test("handles network errors", () => {
  expect(getGeneralApiProblem({ problem: "NETWORK_ERROR" } as ApiErrorResponse<null>)).toEqual({
    kind: "cannot-connect",
    temporary: true,
  })
})

test("handles timeouts", () => {
  expect(getGeneralApiProblem({ problem: "TIMEOUT_ERROR" } as ApiErrorResponse<null>)).toEqual({
    kind: "timeout",
    temporary: true,
  })
})

test("handles server errors", () => {
  expect(getGeneralApiProblem({ problem: "SERVER_ERROR" } as ApiErrorResponse<null>)).toEqual({
    kind: "server",
  })
})

test("handles unknown errors", () => {
  expect(getGeneralApiProblem({ problem: "UNKNOWN_ERROR" } as ApiErrorResponse<null>)).toEqual({
    kind: "unknown",
    temporary: true,
  })
})

test("handles unauthorized errors", () => {
  expect(
    getGeneralApiProblem({ problem: "CLIENT_ERROR", status: 401 } as ApiErrorResponse<null>),
  ).toEqual({
    kind: "unauthorized",
  })
})

test("handles forbidden errors", () => {
  expect(
    getGeneralApiProblem({ problem: "CLIENT_ERROR", status: 403 } as ApiErrorResponse<null>),
  ).toEqual({
    kind: "forbidden",
  })
})

test("handles not-found errors", () => {
  expect(
    getGeneralApiProblem({ problem: "CLIENT_ERROR", status: 404 } as ApiErrorResponse<null>),
  ).toEqual({
    kind: "not-found",
  })
})

test("handles other client errors", () => {
  expect(
    getGeneralApiProblem({ problem: "CLIENT_ERROR", status: 418 } as ApiErrorResponse<null>),
  ).toEqual({
    kind: "rejected",
  })
})

test("handles cancellation errors", () => {
  expect(getGeneralApiProblem({ problem: "CANCEL_ERROR" } as ApiErrorResponse<null>)).toBeNull()
})
===== END FILE: app/services/api/apiProblem.test.ts =====


===== BEGIN FILE: app/services/api/index.ts =====
/**
 * This Api class lets you define an API endpoint and methods to request
 * data and process it.
 *
 * See the [Backend API Integration](https://docs.infinite.red/ignite-cli/boilerplate/app/services/#backend-api-integration)
 * documentation for more details.
 */
import {
  ApiResponse, // @demo remove-current-line
  ApisauceInstance,
  create,
} from "apisauce"

import Config from "@/config"
import type { EpisodeItem } from "@/services/api/types" // @demo remove-current-line

import { GeneralApiProblem, getGeneralApiProblem } from "./apiProblem" // @demo remove-current-line
import type {
  ApiConfig,
  ApiFeedResponse, // @demo remove-current-line
} from "./types"

/**
 * Configuring the apisauce instance.
 */
export const DEFAULT_API_CONFIG: ApiConfig = {
  url: Config.API_URL,
  timeout: 10000,
}

/**
 * Manages all requests to the API. You can use this class to build out
 * various requests that you need to call from your backend API.
 */
export class Api {
  apisauce: ApisauceInstance
  config: ApiConfig

  /**
   * Set up our API instance. Keep this lightweight!
   */
  constructor(config: ApiConfig = DEFAULT_API_CONFIG) {
    this.config = config
    this.apisauce = create({
      baseURL: this.config.url,
      timeout: this.config.timeout,
      headers: {
        Accept: "application/json",
      },
    })
  }

  // @demo remove-block-start
  /**
   * Gets a list of recent React Native Radio episodes.
   */
  async getEpisodes(): Promise<{ kind: "ok"; episodes: EpisodeItem[] } | GeneralApiProblem> {
    // make the api call
    const response: ApiResponse<ApiFeedResponse> = await this.apisauce.get(
      `api.json?rss_url=https%3A%2F%2Ffeeds.simplecast.com%2FhEI_f9Dx`,
    )

    // the typical ways to die when calling an api
    if (!response.ok) {
      const problem = getGeneralApiProblem(response)
      if (problem) return problem
    }

    // transform the data into the format we are expecting
    try {
      const rawData = response.data

      // This is where we transform the data into the shape we expect for our model.
      const episodes: EpisodeItem[] =
        rawData?.items.map((raw) => ({
          ...raw,
        })) ?? []

      return { kind: "ok", episodes }
    } catch (e) {
      if (__DEV__ && e instanceof Error) {
        console.error(`Bad data: ${e.message}\n${response.data}`, e.stack)
      }
      return { kind: "bad-data" }
    }
  }
  // @demo remove-block-end
}

// Singleton instance of the API for convenience
export const api = new Api()
===== END FILE: app/services/api/index.ts =====


===== BEGIN FILE: app/store/authStore.ts =====

===== END FILE: app/store/authStore.ts =====


===== BEGIN FILE: app/store/taskStore.ts =====
import { create } from "zustand"
import { FLAGS } from "@/config/flags"
import { MOCK_NEARBY_TASKS } from "@/mocks/nearbyTasks"
import { OolshikApi } from "@/api"

type Task = {
  id: string
  voiceUrl?: string | null
  title?: string
  description?: string
  distanceMtr?: number
  status: "PENDING" | "ASSIGNED" | "COMPLETED" | "OPEN" | "CANCELLED" | "CANCELED"
  createdById?: string
  createdByName?: string
  createdAt?: string // ISO
  createdByPhoneNumber?: string
  ratingValue?: number | null
  helperAvgRating?: number | null
}

type TaskTab = "ALL" | "CREATED" | "ACCEPTED" | "COMPLETED"

type State = {
  radiusMeters: 1 | 2 | 5
  tasks: Task[]
  myTasks: Task[]
  loading: boolean
  tab: TaskTab
  setRadius: (r: 1 | 2 | 5) => void
  setTab: (t: TaskTab) => void
  fetchNearby: (lat: number, lng: number, statuses?: string[]) => Promise<void>
  accept: (id: string) => Promise<"OK" | "ALREADY" | "ERROR">
  complete: (id: string) => Promise<"OK" | "FORBIDDEN" | "ERROR">
}

export const useTaskStore = create<State>((set, get) => ({
  radiusMeters: 1,
  tasks: [],
  myTasks: [],
  loading: false,
  tab: "ALL",
  setRadius: (r) => set({ radiusMeters: r }),
  setTab: (t) => set({ tab: t }),

  fetchNearby: async (lat, lon, statuses?: string[]) => {
    set({ loading: true })
    try {
      if (FLAGS.USE_MOCK_NEARBY) {
        await new Promise((r) => setTimeout(r, 300))
        const r = get().radiusMeters
        const allowed = new Set(
          (statuses?.length ? statuses : ["OPEN", "ASSIGNED", "COMPLETED", "CANCELLED"]) as any,
        )
        const filtered = MOCK_NEARBY_TASKS.filter(
          (t) => (t.distanceMtr ?? 0) <= r && allowed.has(t.status),
        ).sort((a, b) => (a.distanceMtr ?? 0) - (b.distanceMtr ?? 0))
        set({ tasks: filtered })
      } else {
        const r = get().radiusMeters
        const res = await OolshikApi.nearbyTasks(lat, lon, 1000 * r, statuses)
        if (res.ok) set({ tasks: res.data ?? [] })
      }
    } finally {
      set({ loading: false })
    }
  },

  accept: async (id) => {
    if (FLAGS.USE_MOCK_NEARBY) {
      // optimistic accept in mock mode
      set((s) => ({
        tasks: s.tasks.map((t) => (t.id === id ? { ...t, status: "ASSIGNED" } : t)),
      }))
      return "OK"
    } else {
      const res = await OolshikApi.acceptTask(id)
      if (res.ok) {
        set((s) => ({
          tasks: s.tasks.map((t) => (t.id === id ? { ...t, status: "ASSIGNED" } : t)),
        }))
        return "OK"
      }
      if (res.status === 409) return "ALREADY"
      return "ERROR"
    }
  },

  complete: async (id) => {
    if (FLAGS.USE_MOCK_NEARBY) {
      // In mock mode, allow completion if requester unknown; otherwise block (no auth context here)
      let updated = false
      set((s) => {
        const next = s.tasks.map((t) => {
          if (t.id !== id) return t
          const meId = undefined // no auth lookup in this store
          const allowed = !t.createdById || (meId && t.createdById === meId)
          if (allowed) {
            updated = true
            return { ...t, status: "COMPLETED" as const }
          }
          return t
        })
        return { tasks: next }
      })
      return updated ? "OK" : "FORBIDDEN"
    } else {
      const res = await OolshikApi.completeTask(id)
      if (res.ok) {
        set((s) => ({
          tasks: s.tasks.map((t) => (t.id === id ? { ...t, status: "COMPLETED" } : t)),
        }))
        return "OK"
      }
      // Backend throws when non-requester completes
      if (
        res.status === 403 ||
        res.status === 409 ||
        String(res.data || "").includes("Only requester can complete")
      ) {
        return "FORBIDDEN"
      }
      return "ERROR"
    }
  },
}))
===== END FILE: app/store/taskStore.ts =====


===== BEGIN FILE: test/test-tsconfig.json =====
{
  "extends": "../tsconfig.json",
  "compilerOptions": {
    "noImplicitAny": false,
    "noUnusedLocals": false
  },
  "include": ["**/*.test.ts", "**/*.test.tsx"]
}
===== END FILE: test/test-tsconfig.json =====


===== BEGIN FILE: test/setup.ts =====
// we always make sure 'react-native' gets included first
// eslint-disable-next-line no-restricted-imports
import * as ReactNative from "react-native"

import mockFile from "./mockFile"

// libraries to mock
jest.doMock("react-native", () => {
  // Extend ReactNative
  return Object.setPrototypeOf(
    {
      Image: {
        ...ReactNative.Image,
        resolveAssetSource: jest.fn((_source) => mockFile), // eslint-disable-line @typescript-eslint/no-unused-vars
        getSize: jest.fn(
          (
            uri: string, // eslint-disable-line @typescript-eslint/no-unused-vars
            success: (width: number, height: number) => void,
            failure?: (_error: any) => void, // eslint-disable-line @typescript-eslint/no-unused-vars
          ) => success(100, 100),
        ),
      },
    },
    ReactNative,
  )
})

jest.mock("i18next", () => ({
  currentLocale: "en",
  t: (key: string, params: Record<string, string>) => {
    return `${key} ${JSON.stringify(params)}`
  },
  translate: (key: string, params: Record<string, string>) => {
    return `${key} ${JSON.stringify(params)}`
  },
}))

jest.mock("expo-localization", () => ({
  ...jest.requireActual("expo-localization"),
  getLocales: () => [{ languageTag: "en-US", textDirection: "ltr" }],
}))

jest.mock("../app/i18n/index.ts", () => ({
  i18n: {
    isInitialized: true,
    language: "en",
    t: (key: string, params: Record<string, string>) => {
      return `${key} ${JSON.stringify(params)}`
    },
    numberToCurrency: jest.fn(),
  },
}))

declare const tron // eslint-disable-line @typescript-eslint/no-unused-vars

declare global {
  let __TEST__: boolean
}
===== END FILE: test/setup.ts =====


===== BEGIN FILE: test/mockFile.ts =====
export default {
  height: 100,
  width: 100,
  scale: 2.0,
  uri: "https://placecats.com/200/200",
}
===== END FILE: test/mockFile.ts =====


===== BEGIN FILE: test/i18n.test.ts =====
import { exec } from "child_process"

import en from "../app/i18n/en"

// Use this array for keys that for whatever reason aren't greppable so they
// don't hold your test suite hostage by always failing.
const EXCEPTIONS: string[] = [
  // "welcomeScreen:readyForLaunch",

  /**
   * This translation key actually shows up in a comment describing the usage of the translate
   * function in the app/i18n/translate.ts file. Because the grep command in the i18n test below
   * doesn't account for commented out code, we must manually exclude it so tests don't fail
   * because of a comment.
   */
  "hello",
]

function iterate(obj, stack, array) {
  for (const property in obj) {
    if (Object.prototype.hasOwnProperty.call(obj, property)) {
      if (typeof (obj as object)[property] === "object") {
        iterate(obj[property], `${stack}.${property}`, array)
      } else {
        array.push(`${stack.slice(1)}.${property}`)
      }
    }
  }

  return array
}

/**
 * This tests your codebase for missing i18n strings so you can avoid error strings at render time
 *
 * It was taken from https://gist.github.com/Michaelvilleneuve/8808ba2775536665d95b7577c9d8d5a1
 * and modified slightly to account for our Ignite higher order components,
 * which take 'tx' and 'fooTx' props.
 * The grep command is nasty looking, but it's essentially searching the codebase for a few different things:
 *
 * tx="*"
 * Tx=""
 * tx={""}
 * Tx={""}
 * translate(""
 *
 * and then grabs the i18n key between the double quotes
 *
 * This approach isn't 100% perfect. If you are storing your key string in a variable because you
 * are setting it conditionally, then it won't be picked up.
 *
 */

describe("i18n", () => {
  test("There are no missing keys", (done) => {
    // Actual command output:
    // grep "[T\|t]x=[{]\?\"\S*\"[}]\?\|translate(\"\S*\"" -ohr './app' | grep -o "\".*\""
    const command = `grep "[T\\|t]x=[{]\\?\\"\\S*\\"[}]\\?\\|translate(\\"\\S*\\"" -ohr './app' | grep -o "\\".*\\""`
    exec(command, (_, stdout) => {
      const allTranslationsDefinedOld = iterate(en, "", [])
      // Replace first instance of "." because of i18next namespace separator
      const allTranslationsDefined = allTranslationsDefinedOld.map((key) => key.replace(".", ":"))
      const allTranslationsUsed = stdout.replace(/"/g, "").split("\n")
      allTranslationsUsed.splice(-1, 1)

      for (let i = 0; i < allTranslationsUsed.length; i += 1) {
        if (!EXCEPTIONS.includes(allTranslationsUsed[i])) {
          // You can add keys to EXCEPTIONS (above) if you don't want them included in the test
          expect(allTranslationsDefined).toContainEqual(allTranslationsUsed[i])
        }
      }
      done()
    })
  }, 240000)
})
===== END FILE: test/i18n.test.ts =====


===== BEGIN FILE: plugins/withSplashScreen.ts =====
import { ConfigPlugin, withStringsXml, AndroidConfig, withAndroidStyles } from "expo/config-plugins"

/**
 *
 * Expo Config Plugin to help address the double splash screen issue with `expo-splash-screen`
 * See more information about this issue here: https://github.com/expo/expo/issues/16084
 *
 * How it works:
 *   1) Replace the default splash screen with a transparent screen
 *   2) Set the splash screen status bar to translucent
 */
export const withSplashScreen: ConfigPlugin = (config) => {
  config = withAndroidSplashScreen(config)
  return config
}

/**
 * Android implementation of the config plugin - the only platform needed for this plugin.
 * However, it is good practice to break up your config plugins from the exported
 * function into parts by platform. For example, if it was needed, we would also
 * add `withIosSplashScreen` for the iOS implementation.
 */
const withAndroidSplashScreen: ConfigPlugin = (config) => {
  config = withCustomStylesXml(config)
  config = withCustomStringsXml(config)
  return config
}

/**
 * Modifies the `android/app/src/main/res/values/strings.xml` file to add the following string:
 *
 * <string name="expo_splash_screen_status_bar_translucent" translatable="false">true</string>
 */
const withCustomStringsXml: ConfigPlugin = (config) =>
  withStringsXml(config, (modConfig) => {
    modConfig.modResults = AndroidConfig.Strings.setStringItem(
      [
        {
          _: "true",
          $: {
            name: "expo_splash_screen_status_bar_translucent",
            translatable: "false",
          },
        },
      ],
      modConfig.modResults,
    )
    return modConfig
  })

/**
 * Modifies the `android/app/src/main/res/values/styles.xml` file to append the
 * the following to the Theme.App.SplashScreen style:
 *
 * <item name="android:windowIsTranslucent">true</item>
 */
const withCustomStylesXml: ConfigPlugin = (config) =>
  withAndroidStyles(config, async (modConfig) => {
    modConfig.modResults = AndroidConfig.Styles.assignStylesValue(modConfig.modResults, {
      add: true,
      name: "android:windowIsTranslucent",
      value: "true",
      parent: {
        name: "Theme.App.SplashScreen",
        parent: "AppTheme",
      },
    })
    return modConfig
  })
===== END FILE: plugins/withSplashScreen.ts =====


===== BEGIN FILE: .maestro/shared/_OnFlowStart.yaml =====
# flow: Shared _OnFlowStart
#intent:
# launch the app with a completely clear state, wait for animations to settle,
# and click through the expo dev screens if needed.
# These conditionals slow the app launch down a little but are necessary because the expo
# dev server and launch screen are only shown when the new architecture is turned off in expo 53.
# So we check to see if we need to connect to the metro server... that loads the app and then we
# check if the dev menu is showing and dismiss it if necessary.
# Then the app is then launched and ready for the maestro tests to run.
#
# This flow should be included in every maestro test header as `onFlowStart` to ensure expo screens
# are bypassed if necessary. Example:
#
# appId: ${MAESTRO_APP_ID}
# onFlowStart:
#   - runFlow: ../shared/_OnFlowStart.yaml
# ---
# [your maestro flow]
#
appId: ${MAESTRO_APP_ID}
---
# launch the app with a clean slate
- launchApp:
    clearState: true
    clearKeychain: true
    stopApp: true

- waitForAnimationToEnd

# conditionally run the dev client flow if the words "Development servers" is present.
# this uses the default maestro timeout and moves on if it doesn't see the text.
- runFlow:
    when:
      visible: 'Development servers'
    commands:
      # this regex allows for different hosts and ports
      - tapOn: "http://.*:.*" 
      - waitForAnimationToEnd

- runFlow:
    when:
      platform: Android
      visible:
        id: "${MAESTRO_APP_ID}:id/bottom_sheet" # id of the android bottom sheet we want to dismiss
    commands:
      - swipe:
          direction: DOWN
      - waitForAnimationToEnd
- runFlow:
    when:
      platform: iOS
      visible: 
        id: "SBSwitcherWindow:Main" # id of the iOS bottom sheet we want to dismiss
    commands:
      - swipe:
          direction: DOWN
      - waitForAnimationToEnd
===== END FILE: .maestro/shared/_OnFlowStart.yaml =====


===== BEGIN FILE: .maestro/shared/_Login.yaml =====
#flow: Shared _Login
#intent: shared login flow for any flow that needs to start with a log in.
appId: ${MAESTRO_APP_ID} 
---
- assertVisible: "Log In"
- tapOn:
    text: "Tap to Log in!"
- assertVisible: "Your app, almost ready for launch!"
- tapOn:
    text: "Let's go!"
- assertVisible: "Components to jump start your project!"
# @demo remove-file
===== END FILE: .maestro/shared/_Login.yaml =====


===== BEGIN FILE: .maestro/flows/FavoritePodcast.yaml =====
# flow: run the login flow and then navigate to the demo podcast list screen, favorite a podcast, and then switch the list to only be favorites.

appId: ${MAESTRO_APP_ID}
env:
  FAVORITES_TEXT: "Switch on to only show favorites" # en.demoPodcastListScreen.accessibility.switch
onFlowStart:
  - runFlow: ../shared/_OnFlowStart.yaml
---
- runFlow: ../shared/_Login.yaml
- tapOn: "Podcast"
- assertVisible: "React Native Radio episodes"
- tapOn:
    text: ${FAVORITES_TEXT}
- assertVisible: "This looks a bit empty"
- tapOn:
    text: ${FAVORITES_TEXT}
    # https://maestro.mobile.dev/troubleshooting/known-issues#android-accidental-double-tap
    retryTapIfNoChange: false
- repeat:
    times: 2
    commands:
      - scroll
- copyTextFrom:
    text: "RNR .*" # assumes all podcast titles start with RNR
    index: 2 # grab the third one, others might not be fully visible
- longPressOn: ${maestro.copiedText}
- scrollUntilVisible:
    element:
      text: ${FAVORITES_TEXT}
    direction: UP
    timeout: 50000
    speed: 90
    visibilityPercentage: 100
- tapOn:
    text: ${FAVORITES_TEXT}
- assertVisible: ${maestro.copiedText}
# @demo remove-file
===== END FILE: .maestro/flows/FavoritePodcast.yaml =====


===== BEGIN FILE: .maestro/flows/Login.yaml =====
#flow: Login
#intent:
# Open up our app and use the default credentials to login
# and navigate to the demo screen

appId: ${MAESTRO_APP_ID} # the app id of the app we want to test
# You can find the appId of an Ignite app in the `app.json` file
# as the "package" under the "android" section and "bundleIdentifier" under the "ios" section
onFlowStart:
  - runFlow: ../shared/_OnFlowStart.yaml
---
- runFlow: ../shared/_Login.yaml
# @demo remove-file
===== END FILE: .maestro/flows/Login.yaml =====


===== BEGIN FILE: android/.gitignore =====
# OSX
#
.DS_Store

# Android/IntelliJ
#
build/
.idea
.gradle
local.properties
*.iml
*.hprof
.cxx/

# Bundle artifacts
*.jsbundle
===== END FILE: android/.gitignore =====


===== BEGIN FILE: android/build.gradle =====
// Top-level build file where you can add configuration options common to all sub-projects/modules.

buildscript {
  repositories {
    google()
    mavenCentral()
  }
  dependencies {
    classpath('com.android.tools.build:gradle')
    classpath('com.facebook.react:react-native-gradle-plugin')
    classpath('org.jetbrains.kotlin:kotlin-gradle-plugin')
  }
}

def reactNativeAndroidDir = new File(
  providers.exec {
    workingDir(rootDir)
    commandLine("node", "--print", "require.resolve('react-native/package.json')")
  }.standardOutput.asText.get().trim(),
  "../android"
)

allprojects {
  repositories {
    maven {
      // All of React Native (JS, Obj-C sources, Android binaries) is installed from npm
      url(reactNativeAndroidDir)
    }

    google()
    mavenCentral()
    maven { url 'https://www.jitpack.io' }
  }
}

apply plugin: "expo-root-project"
apply plugin: "com.facebook.react.rootproject"
===== END FILE: android/build.gradle =====


===== BEGIN FILE: android/gradle.properties =====
# Project-wide Gradle settings.

# IDE (e.g. Android Studio) users:
# Gradle settings configured through the IDE *will override*
# any settings specified in this file.

# For more details on how to configure your build environment visit
# http://www.gradle.org/docs/current/userguide/build_environment.html

# Specifies the JVM arguments used for the daemon process.
# The setting is particularly useful for tweaking memory settings.
# Default value: -Xmx512m -XX:MaxMetaspaceSize=256m
org.gradle.jvmargs=-Xmx2048m -XX:MaxMetaspaceSize=512m

# When configured, Gradle will run in incubating parallel mode.
# This option should only be used with decoupled projects. More details, visit
# http://www.gradle.org/docs/current/userguide/multi_project_builds.html#sec:decoupled_projects
# org.gradle.parallel=true

# AndroidX package structure to make it clearer which packages are bundled with the
# Android operating system, and which are packaged with your app's APK
# https://developer.android.com/topic/libraries/support-library/androidx-rn
android.useAndroidX=true

# Enable AAPT2 PNG crunching
android.enablePngCrunchInReleaseBuilds=true

# Use this property to specify which architecture you want to build.
# You can also override it from the CLI using
# ./gradlew <task> -PreactNativeArchitectures=x86_64
reactNativeArchitectures=armeabi-v7a,arm64-v8a,x86,x86_64

# Use this property to enable support to the new architecture.
# This will allow you to use TurboModules and the Fabric render in
# your application. You should enable this flag either if you want
# to write custom TurboModules/Fabric components OR use libraries that
# are providing them.
newArchEnabled=true

# Use this property to enable or disable the Hermes JS engine.
# If set to false, you will be using JSC instead.
hermesEnabled=true

# Enable GIF support in React Native images (~200 B increase)
expo.gif.enabled=true
# Enable webp support in React Native images (~85 KB increase)
expo.webp.enabled=true
# Enable animated webp support (~3.4 MB increase)
# Disabled by default because iOS doesn't support animated webp
expo.webp.animated=false

# Enable network inspector
EX_DEV_CLIENT_NETWORK_INSPECTOR=true

# Use legacy packaging to compress native libraries in the resulting APK.
expo.useLegacyPackaging=false

# Whether the app is configured to use edge-to-edge via the app config or `react-native-edge-to-edge` plugin
expo.edgeToEdgeEnabled=true
===== END FILE: android/gradle.properties =====


===== BEGIN FILE: android/gradlew.bat =====
@rem
@rem Copyright 2015 the original author or authors.
@rem
@rem Licensed under the Apache License, Version 2.0 (the "License");
@rem you may not use this file except in compliance with the License.
@rem You may obtain a copy of the License at
@rem
@rem      https://www.apache.org/licenses/LICENSE-2.0
@rem
@rem Unless required by applicable law or agreed to in writing, software
@rem distributed under the License is distributed on an "AS IS" BASIS,
@rem WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
@rem See the License for the specific language governing permissions and
@rem limitations under the License.
@rem
@rem SPDX-License-Identifier: Apache-2.0
@rem

@if "%DEBUG%"=="" @echo off
@rem ##########################################################################
@rem
@rem  Gradle startup script for Windows
@rem
@rem ##########################################################################

@rem Set local scope for the variables with windows NT shell
if "%OS%"=="Windows_NT" setlocal

set DIRNAME=%~dp0
if "%DIRNAME%"=="" set DIRNAME=.
@rem This is normally unused
set APP_BASE_NAME=%~n0
set APP_HOME=%DIRNAME%

@rem Resolve any "." and ".." in APP_HOME to make it shorter.
for %%i in ("%APP_HOME%") do set APP_HOME=%%~fi

@rem Add default JVM options here. You can also use JAVA_OPTS and GRADLE_OPTS to pass JVM options to this script.
set DEFAULT_JVM_OPTS="-Xmx64m" "-Xms64m"

@rem Find java.exe
if defined JAVA_HOME goto findJavaFromJavaHome

set JAVA_EXE=java.exe
%JAVA_EXE% -version >NUL 2>&1
if %ERRORLEVEL% equ 0 goto execute

echo. 1>&2
echo ERROR: JAVA_HOME is not set and no 'java' command could be found in your PATH. 1>&2
echo. 1>&2
echo Please set the JAVA_HOME variable in your environment to match the 1>&2
echo location of your Java installation. 1>&2

goto fail

:findJavaFromJavaHome
set JAVA_HOME=%JAVA_HOME:"=%
set JAVA_EXE=%JAVA_HOME%/bin/java.exe

if exist "%JAVA_EXE%" goto execute

echo. 1>&2
echo ERROR: JAVA_HOME is set to an invalid directory: %JAVA_HOME% 1>&2
echo. 1>&2
echo Please set the JAVA_HOME variable in your environment to match the 1>&2
echo location of your Java installation. 1>&2

goto fail

:execute
@rem Setup the command line

set CLASSPATH=%APP_HOME%\gradle\wrapper\gradle-wrapper.jar


@rem Execute Gradle
"%JAVA_EXE%" %DEFAULT_JVM_OPTS% %JAVA_OPTS% %GRADLE_OPTS% "-Dorg.gradle.appname=%APP_BASE_NAME%" -classpath "%CLASSPATH%" org.gradle.wrapper.GradleWrapperMain %*

:end
@rem End local scope for the variables with windows NT shell
if %ERRORLEVEL% equ 0 goto mainEnd

:fail
rem Set variable GRADLE_EXIT_CONSOLE if you need the _script_ return code instead of
rem the _cmd.exe /c_ return code!
set EXIT_CODE=%ERRORLEVEL%
if %EXIT_CODE% equ 0 set EXIT_CODE=1
if not ""=="%GRADLE_EXIT_CONSOLE%" exit %EXIT_CODE%
exit /b %EXIT_CODE%

:mainEnd
if "%OS%"=="Windows_NT" endlocal

:omega
===== END FILE: android/gradlew.bat =====


===== BEGIN FILE: android/settings.gradle =====
pluginManagement {
  def reactNativeGradlePlugin = new File(
    providers.exec {
      workingDir(rootDir)
      commandLine("node", "--print", "require.resolve('@react-native/gradle-plugin/package.json', { paths: [require.resolve('react-native/package.json')] })")
    }.standardOutput.asText.get().trim()
  ).getParentFile().absolutePath
  includeBuild(reactNativeGradlePlugin)
  
  def expoPluginsPath = new File(
    providers.exec {
      workingDir(rootDir)
      commandLine("node", "--print", "require.resolve('expo-modules-autolinking/package.json', { paths: [require.resolve('expo/package.json')] })")
    }.standardOutput.asText.get().trim(),
    "../android/expo-gradle-plugin"
  ).absolutePath
  includeBuild(expoPluginsPath)
}

plugins {
  id("com.facebook.react.settings")
  id("expo-autolinking-settings")
}

extensions.configure(com.facebook.react.ReactSettingsExtension) { ex ->
  if (System.getenv('EXPO_USE_COMMUNITY_AUTOLINKING') == '1') {
    ex.autolinkLibrariesFromCommand()
  } else {
    ex.autolinkLibrariesFromCommand(expoAutolinking.rnConfigCommand)
  }
}
expoAutolinking.useExpoModules()

rootProject.name = 'Oolshik'

expoAutolinking.useExpoVersionCatalog()

include ':app'
includeBuild(expoAutolinking.reactNativeGradlePlugin)
===== END FILE: android/settings.gradle =====


===== BEGIN FILE: android/app/build.gradle =====
apply plugin: "com.android.application"
apply plugin: "org.jetbrains.kotlin.android"
apply plugin: "com.facebook.react"

def projectRoot = rootDir.getAbsoluteFile().getParentFile().getAbsolutePath()

/**
 * This is the configuration block to customize your React Native Android app.
 * By default you don't need to apply any configuration, just uncomment the lines you need.
 */
react {
    entryFile = file(["node", "-e", "require('expo/scripts/resolveAppEntry')", projectRoot, "android", "absolute"].execute(null, rootDir).text.trim())
    reactNativeDir = new File(["node", "--print", "require.resolve('react-native/package.json')"].execute(null, rootDir).text.trim()).getParentFile().getAbsoluteFile()
    hermesCommand = new File(["node", "--print", "require.resolve('react-native/package.json')"].execute(null, rootDir).text.trim()).getParentFile().getAbsolutePath() + "/sdks/hermesc/%OS-BIN%/hermesc"
    codegenDir = new File(["node", "--print", "require.resolve('@react-native/codegen/package.json', { paths: [require.resolve('react-native/package.json')] })"].execute(null, rootDir).text.trim()).getParentFile().getAbsoluteFile()

    enableBundleCompression = (findProperty('android.enableBundleCompression') ?: false).toBoolean()
    // Use Expo CLI to bundle the app, this ensures the Metro config
    // works correctly with Expo projects.
    cliFile = new File(["node", "--print", "require.resolve('@expo/cli', { paths: [require.resolve('expo/package.json')] })"].execute(null, rootDir).text.trim())
    bundleCommand = "export:embed"

    /* Folders */
     //   The root of your project, i.e. where "package.json" lives. Default is '../..'
    // root = file("../../")
    //   The folder where the react-native NPM package is. Default is ../../node_modules/react-native
    // reactNativeDir = file("../../node_modules/react-native")
    //   The folder where the react-native Codegen package is. Default is ../../node_modules/@react-native/codegen
    // codegenDir = file("../../node_modules/@react-native/codegen")

    /* Variants */
    //   The list of variants to that are debuggable. For those we're going to
    //   skip the bundling of the JS bundle and the assets. By default is just 'debug'.
    //   If you add flavors like lite, prod, etc. you'll have to list your debuggableVariants.
    // debuggableVariants = ["liteDebug", "prodDebug"]

    /* Bundling */
    //   A list containing the node command and its flags. Default is just 'node'.
    // nodeExecutableAndArgs = ["node"]
    //
    //   The path to the CLI configuration file. Default is empty.
    // bundleConfig = file(../rn-cli.config.js)
    //
    //   The name of the generated asset file containing your JS bundle
    // bundleAssetName = "MyApplication.android.bundle"
    //
    //   The entry file for bundle generation. Default is 'index.android.js' or 'index.js'
    // entryFile = file("../js/MyApplication.android.js")
    //
    //   A list of extra flags to pass to the 'bundle' commands.
    //   See https://github.com/react-native-community/cli/blob/main/docs/commands.md#bundle
    // extraPackagerArgs = []

    /* Hermes Commands */
    //   The hermes compiler command to run. By default it is 'hermesc'
    // hermesCommand = "$rootDir/my-custom-hermesc/bin/hermesc"
    //
    //   The list of flags to pass to the Hermes compiler. By default is "-O", "-output-source-map"
    // hermesFlags = ["-O", "-output-source-map"]

    /* Autolinking */
    autolinkLibrariesWithApp()
}

/**
 * Set this to true to Run Proguard on Release builds to minify the Java bytecode.
 */
def enableProguardInReleaseBuilds = (findProperty('android.enableProguardInReleaseBuilds') ?: false).toBoolean()

/**
 * The preferred build flavor of JavaScriptCore (JSC)
 *
 * For example, to use the international variant, you can use:
 * `def jscFlavor = 'org.webkit:android-jsc-intl:+'`
 *
 * The international variant includes ICU i18n library and necessary data
 * allowing to use e.g. `Date.toLocaleString` and `String.localeCompare` that
 * give correct results when using with locales other than en-US. Note that
 * this variant is about 6MiB larger per architecture than default.
 */
def jscFlavor = 'io.github.react-native-community:jsc-android:2026004.+'

android {
    ndkVersion rootProject.ext.ndkVersion

    buildToolsVersion rootProject.ext.buildToolsVersion
    compileSdk rootProject.ext.compileSdkVersion

    namespace 'com.oolshik.aan'
    defaultConfig {
        applicationId 'com.oolshik.aan'
        minSdkVersion rootProject.ext.minSdkVersion
        targetSdkVersion rootProject.ext.targetSdkVersion
        versionCode 1
        versionName "1.0.0"
    }
    signingConfigs {
        debug {
            storeFile file('debug.keystore')
            storePassword 'android'
            keyAlias 'androiddebugkey'
            keyPassword 'android'
        }
    }
    buildTypes {
        debug {
            signingConfig signingConfigs.debug
        }
        release {
            // Caution! In production, you need to generate your own keystore file.
            // see https://reactnative.dev/docs/signed-apk-android.
            signingConfig signingConfigs.debug
            shrinkResources (findProperty('android.enableShrinkResourcesInReleaseBuilds')?.toBoolean() ?: false)
            minifyEnabled enableProguardInReleaseBuilds
            proguardFiles getDefaultProguardFile("proguard-android.txt"), "proguard-rules.pro"
            crunchPngs (findProperty('android.enablePngCrunchInReleaseBuilds')?.toBoolean() ?: true)
        }
    }
    packagingOptions {
        jniLibs {
            useLegacyPackaging (findProperty('expo.useLegacyPackaging')?.toBoolean() ?: false)
        }
    }
    androidResources {
        ignoreAssetsPattern '!.svn:!.git:!.ds_store:!*.scc:!CVS:!thumbs.db:!picasa.ini:!*~'
    }
}

// Apply static values from `gradle.properties` to the `android.packagingOptions`
// Accepts values in comma delimited lists, example:
// android.packagingOptions.pickFirsts=/LICENSE,**/picasa.ini
["pickFirsts", "excludes", "merges", "doNotStrip"].each { prop ->
    // Split option: 'foo,bar' -> ['foo', 'bar']
    def options = (findProperty("android.packagingOptions.$prop") ?: "").split(",");
    // Trim all elements in place.
    for (i in 0..<options.size()) options[i] = options[i].trim();
    // `[] - ""` is essentially `[""].filter(Boolean)` removing all empty strings.
    options -= ""

    if (options.length > 0) {
        println "android.packagingOptions.$prop += $options ($options.length)"
        // Ex: android.packagingOptions.pickFirsts += '**/SCCS/**'
        options.each {
            android.packagingOptions[prop] += it
        }
    }
}

dependencies {
    // The version of react-native is set by the React Native Gradle Plugin
    implementation("com.facebook.react:react-android")

    def isGifEnabled = (findProperty('expo.gif.enabled') ?: "") == "true";
    def isWebpEnabled = (findProperty('expo.webp.enabled') ?: "") == "true";
    def isWebpAnimatedEnabled = (findProperty('expo.webp.animated') ?: "") == "true";

    if (isGifEnabled) {
        // For animated gif support
        implementation("com.facebook.fresco:animated-gif:${expoLibs.versions.fresco.get()}")
    }

    if (isWebpEnabled) {
        // For webp support
        implementation("com.facebook.fresco:webpsupport:${expoLibs.versions.fresco.get()}")
        if (isWebpAnimatedEnabled) {
            // Animated webp support
            implementation("com.facebook.fresco:animated-webp:${expoLibs.versions.fresco.get()}")
        }
    }

    if (hermesEnabled.toBoolean()) {
        implementation("com.facebook.react:hermes-android")
    } else {
        implementation jscFlavor
    }
}
===== END FILE: android/app/build.gradle =====


===== BEGIN FILE: android/app/src/main/AndroidManifest.xml =====
<manifest xmlns:android="http://schemas.android.com/apk/res/android">
  <uses-permission android:name="android.permission.INTERNET"/>
  <uses-permission android:name="android.permission.READ_EXTERNAL_STORAGE"/>
  <uses-permission android:name="android.permission.SYSTEM_ALERT_WINDOW"/>
  <uses-permission android:name="android.permission.VIBRATE"/>
  <uses-permission android:name="android.permission.WRITE_EXTERNAL_STORAGE"/>
  <uses-permission android:name="android.permission.RECORD_AUDIO" />
  <queries>
    <intent>
      <action android:name="android.intent.action.VIEW"/>
      <category android:name="android.intent.category.BROWSABLE"/>
      <data android:scheme="https"/>
    </intent>
  </queries>
  <application android:name=".MainApplication" android:label="@string/app_name" android:icon="@mipmap/ic_launcher" android:roundIcon="@mipmap/ic_launcher_round" android:allowBackup="false" android:theme="@style/AppTheme" android:supportsRtl="true">
    <meta-data android:name="expo.modules.updates.ENABLED" android:value="false"/>
    <meta-data android:name="expo.modules.updates.EXPO_UPDATES_CHECK_ON_LAUNCH" android:value="ALWAYS"/>
    <meta-data android:name="expo.modules.updates.EXPO_UPDATES_LAUNCH_WAIT_MS" android:value="0"/>
    <activity android:name=".MainActivity" android:configChanges="keyboard|keyboardHidden|orientation|screenSize|screenLayout|uiMode|locale|layoutDirection" android:launchMode="singleTask" android:windowSoftInputMode="adjustResize" android:theme="@style/Theme.App.SplashScreen" android:exported="true" android:screenOrientation="portrait">
      <intent-filter>
        <action android:name="android.intent.action.MAIN"/>
        <category android:name="android.intent.category.LAUNCHER"/>
      </intent-filter>
      <intent-filter>
        <action android:name="android.intent.action.VIEW"/>
        <category android:name="android.intent.category.DEFAULT"/>
        <category android:name="android.intent.category.BROWSABLE"/>
        <data android:scheme="oolshik"/>
        <data android:scheme="exp+oolshik"/>
      </intent-filter>
    </activity>
  </application>
</manifest>
===== END FILE: android/app/src/main/AndroidManifest.xml =====


===== BEGIN FILE: android/app/src/main/res/drawable/rn_edit_text_material.xml =====
<?xml version="1.0" encoding="utf-8"?>
<!-- Copyright (C) 2014 The Android Open Source Project

     Licensed under the Apache License, Version 2.0 (the "License");
     you may not use this file except in compliance with the License.
     You may obtain a copy of the License at

          http://www.apache.org/licenses/LICENSE-2.0

     Unless required by applicable law or agreed to in writing, software
     distributed under the License is distributed on an "AS IS" BASIS,
     WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
     See the License for the specific language governing permissions and
     limitations under the License.
-->
<inset xmlns:android="http://schemas.android.com/apk/res/android"
       android:insetLeft="@dimen/abc_edit_text_inset_horizontal_material"
       android:insetRight="@dimen/abc_edit_text_inset_horizontal_material"
       android:insetTop="@dimen/abc_edit_text_inset_top_material"
       android:insetBottom="@dimen/abc_edit_text_inset_bottom_material"
       >

    <selector>
        <!--
          This file is a copy of abc_edit_text_material (https://bit.ly/3k8fX7I).
          The item below with state_pressed="false" and state_focused="false" causes a NullPointerException.
          NullPointerException:tempt to invoke virtual method 'android.graphics.drawable.Drawable android.graphics.drawable.Drawable$ConstantState.newDrawable(android.content.res.Resources)'

          <item android:state_pressed="false" android:state_focused="false" android:drawable="@drawable/abc_textfield_default_mtrl_alpha"/>

          For more info, see https://bit.ly/3CdLStv (react-native/pull/29452) and https://bit.ly/3nxOMoR.
        -->
        <item android:state_enabled="false" android:drawable="@drawable/abc_textfield_default_mtrl_alpha"/>
        <item android:drawable="@drawable/abc_textfield_activated_mtrl_alpha"/>
    </selector>

</inset>
===== END FILE: android/app/src/main/res/drawable/rn_edit_text_material.xml =====


===== BEGIN FILE: android/app/src/main/res/drawable/ic_launcher_background.xml =====
<layer-list xmlns:android="http://schemas.android.com/apk/res/android">
  <item android:drawable="@color/splashscreen_background"/>
  <item>
    <bitmap android:gravity="center" android:src="@drawable/splashscreen_logo"/>
  </item>
</layer-list>
===== END FILE: android/app/src/main/res/drawable/ic_launcher_background.xml =====


===== BEGIN FILE: android/app/src/main/res/values-night/colors.xml =====
<resources/>
===== END FILE: android/app/src/main/res/values-night/colors.xml =====


===== BEGIN FILE: android/app/src/main/res/values/colors.xml =====
<resources>
    <!-- Splash / Launch Screen background -->
    <color name="splashscreen_background">#FF6B2C</color> <!-- Vibrant orange -->

    <!-- Icon background (kept white for contrast) -->
    <color name="iconBackground">#FFFFFF</color>

    <!-- Primary brand color (deep orange tone from your icon) -->
    <color name="colorPrimary">#E65100</color> <!-- Deep orange -->

    <!-- Darker variant for status bar / dark surfaces -->
    <color name="colorPrimaryDark">#BF360C</color> <!-- Dark burnt orange -->

    <!-- Accent / secondary (lighter orange for highlights) -->
    <color name="colorAccent">#FF8A50</color>

    <!-- Neutral background (light gray for cards if needed) -->
    <color name="colorSurface">#FAFAFA</color>
</resources>
===== END FILE: android/app/src/main/res/values/colors.xml =====


===== BEGIN FILE: android/app/src/main/res/values/styles.xml =====
<resources xmlns:tools="http://schemas.android.com/tools">
  <style name="AppTheme" parent="Theme.EdgeToEdge.Light">
    <item name="android:editTextBackground">@drawable/rn_edit_text_material</item>
    <item name="colorPrimary">@color/colorPrimary</item>
    <item name="enforceNavigationBarContrast">false</item>
    <item name="android:textColor">#FF6B2C</item>
  </style>
  <style name="Theme.App.SplashScreen" parent="Theme.SplashScreen">
    <item name="windowSplashScreenBackground">@color/splashscreen_background</item>
    <item name="windowSplashScreenAnimatedIcon">@drawable/splashscreen_logo</item>
    <item name="postSplashScreenTheme">@style/AppTheme</item>
  </style>
</resources>
===== END FILE: android/app/src/main/res/values/styles.xml =====


===== BEGIN FILE: android/app/src/main/res/values/strings.xml =====
<resources>
  <string name="app_name">Oolshik</string>
  <string name="expo_system_ui_user_interface_style" translatable="false">automatic</string>
  <string name="expo_splash_screen_status_bar_translucent" translatable="false">false</string>
  <string name="expo_splash_screen_resize_mode" translatable="false">contain</string>
</resources>
===== END FILE: android/app/src/main/res/values/strings.xml =====


===== BEGIN FILE: android/app/src/main/res/mipmap-anydpi-v26/ic_launcher.xml =====
<?xml version="1.0" encoding="utf-8"?>
<adaptive-icon xmlns:android="http://schemas.android.com/apk/res/android">
    <background android:drawable="@drawable/ic_launcher_background"/>
    <foreground android:drawable="@mipmap/ic_launcher_foreground"/>
</adaptive-icon>
===== END FILE: android/app/src/main/res/mipmap-anydpi-v26/ic_launcher.xml =====


===== BEGIN FILE: android/app/src/main/res/mipmap-anydpi-v26/ic_launcher_round.xml =====
<?xml version="1.0" encoding="utf-8"?>
<adaptive-icon xmlns:android="http://schemas.android.com/apk/res/android">
    <background android:drawable="@drawable/ic_launcher_background"/>
    <foreground android:drawable="@mipmap/ic_launcher_foreground"/>
</adaptive-icon>
===== END FILE: android/app/src/main/res/mipmap-anydpi-v26/ic_launcher_round.xml =====


===== BEGIN FILE: android/app/src/main/java/com/oolshik/aan/MainActivity.kt =====
package com.oolshik.aan
import expo.modules.splashscreen.SplashScreenManager

import android.os.Build
import android.os.Bundle

import com.facebook.react.ReactActivity
import com.facebook.react.ReactActivityDelegate
import com.facebook.react.defaults.DefaultNewArchitectureEntryPoint.fabricEnabled
import com.facebook.react.defaults.DefaultReactActivityDelegate

import expo.modules.ReactActivityDelegateWrapper

class MainActivity : ReactActivity() {
  override fun onCreate(savedInstanceState: Bundle?) {
    // Set the theme to AppTheme BEFORE onCreate to support
    // coloring the background, status bar, and navigation bar.
    // This is required for expo-splash-screen.
    // setTheme(R.style.AppTheme);
    // @generated begin expo-splashscreen - expo prebuild (DO NOT MODIFY) sync-f3ff59a738c56c9a6119210cb55f0b613eb8b6af
    SplashScreenManager.registerOnActivity(this)
    // @generated end expo-splashscreen
    super.onCreate(null)
  }

  /**
   * Returns the name of the main component registered from JavaScript. This is used to schedule
   * rendering of the component.
   */
  override fun getMainComponentName(): String = "main"

  /**
   * Returns the instance of the [ReactActivityDelegate]. We use [DefaultReactActivityDelegate]
   * which allows you to enable New Architecture with a single boolean flags [fabricEnabled]
   */
  override fun createReactActivityDelegate(): ReactActivityDelegate {
    return ReactActivityDelegateWrapper(
          this,
          BuildConfig.IS_NEW_ARCHITECTURE_ENABLED,
          object : DefaultReactActivityDelegate(
              this,
              mainComponentName,
              fabricEnabled
          ){})
  }

  /**
    * Align the back button behavior with Android S
    * where moving root activities to background instead of finishing activities.
    * @see <a href="https://developer.android.com/reference/android/app/Activity#onBackPressed()">onBackPressed</a>
    */
  override fun invokeDefaultOnBackPressed() {
      if (Build.VERSION.SDK_INT <= Build.VERSION_CODES.R) {
          if (!moveTaskToBack(false)) {
              // For non-root activities, use the default implementation to finish them.
              super.invokeDefaultOnBackPressed()
          }
          return
      }

      // Use the default back button implementation on Android S
      // because it's doing more than [Activity.moveTaskToBack] in fact.
      super.invokeDefaultOnBackPressed()
  }
}
===== END FILE: android/app/src/main/java/com/oolshik/aan/MainActivity.kt =====


===== BEGIN FILE: android/app/src/main/java/com/oolshik/aan/MainApplication.kt =====
package com.oolshik.aan

import android.app.Application
import android.content.res.Configuration

import com.facebook.react.PackageList
import com.facebook.react.ReactApplication
import com.facebook.react.ReactNativeHost
import com.facebook.react.ReactPackage
import com.facebook.react.ReactHost
import com.facebook.react.defaults.DefaultNewArchitectureEntryPoint.load
import com.facebook.react.defaults.DefaultReactNativeHost
import com.facebook.react.soloader.OpenSourceMergedSoMapping
import com.facebook.soloader.SoLoader

import expo.modules.ApplicationLifecycleDispatcher
import expo.modules.ReactNativeHostWrapper

class MainApplication : Application(), ReactApplication {

  override val reactNativeHost: ReactNativeHost = ReactNativeHostWrapper(
        this,
        object : DefaultReactNativeHost(this) {
          override fun getPackages(): List<ReactPackage> {
            val packages = PackageList(this).packages
            // Packages that cannot be autolinked yet can be added manually here, for example:
            // packages.add(MyReactNativePackage())
            return packages
          }

          override fun getJSMainModuleName(): String = ".expo/.virtual-metro-entry"

          override fun getUseDeveloperSupport(): Boolean = BuildConfig.DEBUG

          override val isNewArchEnabled: Boolean = BuildConfig.IS_NEW_ARCHITECTURE_ENABLED
          override val isHermesEnabled: Boolean = BuildConfig.IS_HERMES_ENABLED
      }
  )

  override val reactHost: ReactHost
    get() = ReactNativeHostWrapper.createReactHost(applicationContext, reactNativeHost)

  override fun onCreate() {
    super.onCreate()
    SoLoader.init(this, OpenSourceMergedSoMapping)
    if (BuildConfig.IS_NEW_ARCHITECTURE_ENABLED) {
      // If you opted-in for the New Architecture, we load the native entry point for this app.
      load()
    }
    ApplicationLifecycleDispatcher.onApplicationCreate(this)
  }

  override fun onConfigurationChanged(newConfig: Configuration) {
    super.onConfigurationChanged(newConfig)
    ApplicationLifecycleDispatcher.onConfigurationChanged(this, newConfig)
  }
}
===== END FILE: android/app/src/main/java/com/oolshik/aan/MainApplication.kt =====


===== BEGIN FILE: android/app/src/debug/AndroidManifest.xml =====
<manifest xmlns:android="http://schemas.android.com/apk/res/android"
    xmlns:tools="http://schemas.android.com/tools">

    <uses-permission android:name="android.permission.SYSTEM_ALERT_WINDOW"/>

    <application android:usesCleartextTraffic="true" tools:targetApi="28" tools:ignore="GoogleAppIndexingWarning" tools:replace="android:usesCleartextTraffic" />
</manifest>
===== END FILE: android/app/src/debug/AndroidManifest.xml =====


===== BEGIN FILE: android/gradle/wrapper/gradle-wrapper.properties =====
distributionBase=GRADLE_USER_HOME
distributionPath=wrapper/dists
distributionUrl=https\://services.gradle.org/distributions/gradle-8.13-bin.zip
networkTimeout=10000
validateDistributionUrl=true
zipStoreBase=GRADLE_USER_HOME
zipStorePath=wrapper/dists
===== END FILE: android/gradle/wrapper/gradle-wrapper.properties =====


===== BEGIN FILE: src/app/index.tsx =====
import { WelcomeScreen } from '@/screens/WelcomeScreen'

export default function Index() {
  return <WelcomeScreen />
}
===== END FILE: src/app/index.tsx =====


===== BEGIN FILE: src/app/_layout.tsx =====
import { useEffect, useState } from "react"
import { Slot, SplashScreen } from "expo-router"
import { useFonts } from "@expo-google-fonts/space-grotesk"
import { KeyboardProvider } from "react-native-keyboard-controller"
import { initialWindowMetrics, SafeAreaProvider } from "react-native-safe-area-context"

import { initI18n } from "@/i18n"
import { ThemeProvider } from "@/theme/context"
import { customFontsToLoad } from "@/theme/typography"
import { loadDateFnsLocale } from "@/utils/formatDate"

SplashScreen.preventAutoHideAsync()

if (__DEV__) {
  // Load Reactotron configuration in development. We don't want to
  // include this in our production bundle, so we are using `if (__DEV__)`
  // to only execute this in development.
  require("src/devtools/ReactotronConfig.ts")
}

export { ErrorBoundary } from "@/components/ErrorBoundary/ErrorBoundary"

export default function Root() {
  const [fontsLoaded, fontError] = useFonts(customFontsToLoad)
  const [isI18nInitialized, setIsI18nInitialized] = useState(false)

  useEffect(() => {
    initI18n()
      .then(() => setIsI18nInitialized(true))
      .then(() => loadDateFnsLocale())
  }, [])

  const loaded = fontsLoaded && isI18nInitialized

  useEffect(() => {
    if (fontError) throw fontError
  }, [fontError])

  useEffect(() => {
    if (loaded) {
      SplashScreen.hideAsync()
    }
  }, [loaded])

  if (!loaded) {
    return null
  }

  return (
    <SafeAreaProvider initialMetrics={initialWindowMetrics}>
      <ThemeProvider>
        <KeyboardProvider>
          <Slot />
        </KeyboardProvider>
      </ThemeProvider>
    </SafeAreaProvider>
  )
}
===== END FILE: src/app/_layout.tsx =====
